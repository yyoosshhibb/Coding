-- VHDL Entity axi_sbus_bridge.test_axi_mst.symbol
--
-- Created:
--          by - net.UNKNOWN (KPERSM7467)
--          at - 13:39:04 04.12.2017
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

entity test_axi_mst is
   generic( 
      C_S00_AXI_ADDR_WIDTH   : integer := 6;
      C_S00_AXI_ARUSER_WIDTH : integer := 1;
      C_S00_AXI_AWUSER_WIDTH : integer := 1;
      C_S00_AXI_BUSER_WIDTH  : integer := 1;
      C_S00_AXI_DATA_WIDTH   : integer := 32;
      -- Users to add parameters here
      
      -- User parameters ends
      -- Do not modify the parameters beyond this line
      
      
      -- Parameters of Axi Slave Bus Interface S00_AXI
      C_S00_AXI_ID_WIDTH     : integer := 1;
      C_S00_AXI_RUSER_WIDTH  : integer := 1;
      C_S00_AXI_WUSER_WIDTH  : integer := 1;
      clk_period_g           : time    := 8ps;
      COMMANDS               : string  := "buscommands.txt"
   );
   port( 
      s00_axi_arready  : in     std_logic;
      s00_axi_awready  : in     std_logic;
      s00_axi_bid      : in     std_logic_vector (C_S00_AXI_ID_WIDTH-1 downto 0);
      s00_axi_bresp    : in     std_logic_vector (1 downto 0);
      s00_axi_buser    : in     std_logic_vector (C_S00_AXI_BUSER_WIDTH-1 downto 0);
      s00_axi_bvalid   : in     std_logic;
      s00_axi_rdata    : in     std_logic_vector (C_S00_AXI_DATA_WIDTH-1 downto 0);
      s00_axi_rid      : in     std_logic_vector (C_S00_AXI_ID_WIDTH-1 downto 0);
      s00_axi_rlast    : in     std_logic;
      s00_axi_rresp    : in     std_logic_vector (1 downto 0);
      s00_axi_ruser    : in     std_logic_vector (C_S00_AXI_RUSER_WIDTH-1 downto 0);
      s00_axi_rvalid   : in     std_logic;
      s00_axi_wready   : in     std_logic;
      -- User ports ends
      -- Do not modify the ports beyond this line
      
      
      -- Ports of Axi Slave Bus Interface S00_AXI
      s00_axi_aclk     : out    std_logic;
      s00_axi_araddr   : out    std_logic_vector (C_S00_AXI_ADDR_WIDTH-1 downto 0);
      s00_axi_arburst  : out    std_logic_vector (1 downto 0);
      s00_axi_arcache  : out    std_logic_vector (3 downto 0);
      s00_axi_aresetn  : out    std_logic;
      s00_axi_arid     : out    std_logic_vector (C_S00_AXI_ID_WIDTH-1 downto 0);
      s00_axi_arlen    : out    std_logic_vector (7 downto 0);
      s00_axi_arlock   : out    std_logic;
      s00_axi_arprot   : out    std_logic_vector (2 downto 0);
      s00_axi_arqos    : out    std_logic_vector (3 downto 0);
      s00_axi_arregion : out    std_logic_vector (3 downto 0);
      s00_axi_arsize   : out    std_logic_vector (2 downto 0);
      s00_axi_aruser   : out    std_logic_vector (C_S00_AXI_ARUSER_WIDTH-1 downto 0);
      s00_axi_arvalid  : out    std_logic;
      s00_axi_awaddr   : out    std_logic_vector (C_S00_AXI_ADDR_WIDTH-1 downto 0);
      s00_axi_awburst  : out    std_logic_vector (1 downto 0);
      s00_axi_awcache  : out    std_logic_vector (3 downto 0);
      s00_axi_awid     : out    std_logic_vector (C_S00_AXI_ID_WIDTH-1 downto 0);
      s00_axi_awlen    : out    std_logic_vector (7 downto 0);
      s00_axi_awlock   : out    std_logic;
      s00_axi_awprot   : out    std_logic_vector (2 downto 0);
      s00_axi_awqos    : out    std_logic_vector (3 downto 0);
      s00_axi_awregion : out    std_logic_vector (3 downto 0);
      s00_axi_awsize   : out    std_logic_vector (2 downto 0);
      s00_axi_awuser   : out    std_logic_vector (C_S00_AXI_AWUSER_WIDTH-1 downto 0);
      s00_axi_awvalid  : out    std_logic;
      s00_axi_bready   : out    std_logic;
      s00_axi_rready   : out    std_logic;
      s00_axi_wdata    : out    std_logic_vector (C_S00_AXI_DATA_WIDTH-1 downto 0);
      s00_axi_wlast    : out    std_logic;
      s00_axi_wstrb    : out    std_logic_vector ((C_S00_AXI_DATA_WIDTH/8)-1 downto 0);
      s00_axi_wuser    : out    std_logic_vector (C_S00_AXI_WUSER_WIDTH-1 downto 0);
      s00_axi_wvalid   : out    std_logic
   );

-- Declarations

end test_axi_mst ;

--
-- VHDL Architecture axi_sbus_bridge.test_axi_mst.fsm
--
-- Created:
--          by - net.Personal AEE (KPERSM7467)
--          at - 13:45:05 12/15/15
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
library std;
use std.textio.all;
 
architecture fsm of test_axi_mst is

   -- Architecture Declarations
   signal clk: std_logic;
   signal reset: std_logic;
   
   
   signal bus_address_int: std_logic_vector(31 downto 0) := (others => '0');
   signal bus_data_int: std_logic_vector(31 downto 0) := (others => '0');
   signal bus_din_int: std_logic_vector(31 downto 0);
   signal bus_data_en: std_logic;
   signal next_cmd: std_logic := '0';
   signal rnw: std_logic;
   signal stop: std_logic := '0';
   signal halt: std_logic := '0';
   signal data_en: std_logic;
   
   
   ------convert string with 8 elements to 32-bit standard logic vector 
   
   function STR8_2VEC (str: string (8 downto 1)) return std_logic_vector is
      variable vec: std_logic_vector(31 downto 0);
      variable tmp: std_logic_vector(3 downto 0);
   begin
       for i in 0 to 7 loop
          case str(i+1) is
             when '0'=> tmp := "0000";
             when '1'=> tmp := "0001";
             when '2'=> tmp := "0010";
             when '3'=> tmp := "0011";
             when '4'=> tmp := "0100";
             when '5'=> tmp := "0101";
             when '6'=> tmp := "0110";
             when '7'=> tmp := "0111";
             when '8'=> tmp := "1000";
             when '9'=> tmp := "1001";
             when 'A'=> tmp := "1010";
             when 'B'=> tmp := "1011";
             when 'C'=> tmp := "1100";
             when 'D'=> tmp := "1101";
             when 'E'=> tmp := "1110";
             when 'F'=> tmp := "1111";
             when others =>  tmp := "XXXX";
           end case;
           vec(4*i+3 downto 4*i) := tmp;
       end loop;
       return(vec);
   end STR8_2VEC;

   type state_type is (
      s_reset,
      s_fetch,
      s_busarb,
      s_exec,
      s_wr0,
      s_read,
      s_wr1,
      s_wr2,
      s_wr3
   );
 
   -- Declare current and next state signals
   signal current_state : state_type;
   signal next_state : state_type;

begin

   -----------------------------------------------------------------
   clocked_proc : process ( 
      clk
   )
   -----------------------------------------------------------------
   begin
      if (clk'event and clk = '1') then
         if (reset = '1') then
            current_state <= s_reset;
         else
            current_state <= next_state;

            -- Combined Actions
            case current_state is
               when s_reset => 
                  data_en <= '0';
               when s_fetch => 
                  data_en <= '0';
                  if (halt = '0' and stop = '0') then 
                     next_cmd <= not next_cmd;
                  end if;
               when s_busarb => 
                  data_en <= '0';
               when s_wr2 => 
                  bus_din_int <= s00_axi_rdata;
               when others =>
                  null;
            end case;
         end if;
      end if;
   end process clocked_proc;
 
   -----------------------------------------------------------------
   nextstate_proc : process ( 
      current_state,
      halt,
      rnw,
      s00_axi_arready,
      s00_axi_awready,
      s00_axi_rlast,
      s00_axi_rvalid,
      s00_axi_wready,
      stop
   )
   -----------------------------------------------------------------
   begin
      case current_state is
         when s_reset => 
            next_state <= s_fetch;
         when s_fetch => 
            if (halt = '0' and stop = '0') then 
               next_state <= s_busarb;
            else
               next_state <= s_fetch;
            end if;
         when s_busarb => 
            if (stop = '1' or halt = '1') then 
               next_state <= s_fetch;
            else
               next_state <= s_exec;
            end if;
         when s_exec => 
            if (rnw = '0') then 
               next_state <= s_wr0;
            else
               next_state <= s_read;
            end if;
         when s_wr0 => 
            if (s00_axi_awready = '1') then 
               next_state <= s_wr1;
            else
               next_state <= s_wr0;
            end if;
         when s_read => 
            if (s00_axi_arready = '1') then 
               next_state <= s_wr2;
            else
               next_state <= s_read;
            end if;
         when s_wr1 => 
            if (s00_axi_wready = '1') then 
               next_state <= s_fetch;
            else
               next_state <= s_wr1;
            end if;
         when s_wr2 => 
            if (s00_axi_rvalid = '1' and s00_axi_rlast = '1') then 
               next_state <= s_wr3;
            else
               next_state <= s_wr2;
            end if;
         when s_wr3 => 
            next_state <= s_fetch;
         when others =>
            next_state <= s_reset;
      end case;
   end process nextstate_proc;
 
   -----------------------------------------------------------------
   output_proc : process ( 
      bus_address_int,
      bus_data_int,
      current_state
   )
   -----------------------------------------------------------------
   begin
      -- Default Assignment
      s00_axi_arburst <= (others => '0');
      s00_axi_arcache <= (others => '0');
      s00_axi_arid <= (others => '0');
      s00_axi_arlen <= (others => '0');
      s00_axi_arlock <= '0';
      s00_axi_arprot <= (others => '0');
      s00_axi_arqos <= (others => '0');
      s00_axi_arregion <= (others => '0');
      s00_axi_arsize <= (others => '0');
      s00_axi_aruser <= (others => '0');
      s00_axi_arvalid <= '0';
      s00_axi_awburst <= (others => '0');
      s00_axi_awcache <= (others => '0');
      s00_axi_awid <= (others => '0');
      s00_axi_awlen <= (others => '0');
      s00_axi_awlock <= '0';
      s00_axi_awprot <= (others => '0');
      s00_axi_awqos <= (others => '0');
      s00_axi_awregion <= (others => '0');
      s00_axi_awsize <= (others => '0');
      s00_axi_awuser <= (others => '0');
      s00_axi_awvalid <= '0';
      s00_axi_wlast <= '0';
      s00_axi_wstrb <= (others => '0');
      s00_axi_wuser <= (others => '0');
      s00_axi_wvalid <= '0';

      -- Combined Actions
      case current_state is
         when s_wr0 => 
            s00_axi_awvalid <= '1';
            s00_axi_awaddr <= bus_address_int(s00_axi_awaddr'range);
            s00_axi_wdata <= bus_data_int;
         when s_read => 
            s00_axi_arvalid <= '1';
            s00_axi_araddr <= bus_address_int(s00_axi_araddr'range );
         when s_wr1 => 
            s00_axi_wvalid <= '1';
            s00_axi_wlast <= '1';
            s00_axi_wstrb <= (others => '1');
            s00_axi_awaddr <= bus_address_int(s00_axi_awaddr'range);
            s00_axi_wdata <= bus_data_int;
         when s_wr2 => 
            s00_axi_araddr <= bus_address_int(s00_axi_araddr'range);
         when s_wr3 => 
            s00_axi_rready <= '1';
         when others =>
            null;
      end case;
   end process output_proc;
 
   -- Concurrent Statements
   process
   begin
      clk <= '0';
      wait for clk_period_g/2;
      clk <= '1';
      wait for clk_period_g/2;
   end process;
   
   process
   begin
      reset <= '1';
      wait for 10*clk_period_g;
      reset <= '0';
      wait;
   end process;
   
   s00_axi_aclk <= clk;
   s00_axi_aresetn <= not reset;
   
   
   -- synthesis translate_off
   ------------------------------------------------------------------------------
   ---Read Command File
   ------------------------------------------------------------------------------
   
       readcmd:process
       file textfile:   text is in COMMANDS;
       variable l: line;
       variable cmd:  string(1 to 4);
       variable address: string(1 to 8);
       variable data: string(1 to 8);
       variable num: integer;
       variable separator: character;
       variable timestamp_v, waittime_v: time;
       variable byte_addr: std_logic_vector(31 downto 0);
       begin
          while not endfile(textfile) loop
             wait until next_cmd'event;  
            readline(textfile, l);
            read(l, cmd);
            case cmd is
               when "MEMW" =>    read(l,separator);
                                 read(l,address);
                                 read(l,separator);
                                 read(l,data);
                                 byte_addr := STR8_2VEC(address);
                              bus_address_int <=  byte_addr(29 downto 0) & "00";
                                bus_data_int <= STR8_2VEC(data); 
                                 rnw <= '0';
                 when "MEMR" =>  read(l,separator);
                                 read(l,address);
                                 byte_addr := STR8_2VEC(address);
                                 bus_address_int <=  byte_addr(29 downto 0) & "00";
                                 rnw <= '1';
                 when "TIME" =>  read(l,separator);
                                 read(l,timestamp_v);
                                waittime_v := timestamp_v - now;
                                halt <= '1';
                                wait for waittime_v;  
                                halt <= '0';
    
   
                when others =>   assert false report "Unrecognised Instruction"
                                 severity failure;
            end case;                    
         
         end loop;
         stop <= '1';
         assert false report "Simulation complete" severity note;
   
         wait;
   
       end process readcmd;
   
   
   --eof <= not stop;
   
   -- synthesis translate_on
end fsm;
