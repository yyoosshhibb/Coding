-- VHDL Entity sbus_awfg_lib.bus_bridge_16.symbol
--
-- Created:
--          by - Net.UNKNOWN (M00443)
--          at - 11:51:58 15.06.2022
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2017.1a (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

entity bus_bridge_16 is
   port( 
      bus_ack     : in     std_logic;
      bus_din     : in     std_logic_vector (31 downto 0);
      bus_grant   : in     std_logic;
      clk         : in     std_logic;
      cmd         : in     std_logic_vector (7 downto 0);
      cmd_we      : in     std_logic;
      reset       : in     std_logic;
      slv_cs      : in     std_logic;
      slv_din     : in     std_logic;
      slv_we      : in     std_logic;
      tx_ack      : in     std_logic;
      bus_addr    : out    std_logic_vector ( 15 downto 0 );
      bus_dout    : out    std_logic_vector (31 downto 0);
      bus_rd      : out    std_logic;
      bus_request : out    std_logic;
      bus_we      : out    std_logic;
      response    : out    std_logic_vector (7 downto 0);
      response_en : out    std_logic;
      slv_ack     : out    std_logic
   );

-- Declarations

end bus_bridge_16 ;

--
-- VHDL Architecture sbus_awfg_lib.bus_bridge_16.fsm
--
-- Created:
--          by - Net.UNKNOWN (M00443)
--          at - 11:51:33 15.06.2022
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2017.1a (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;
 
architecture fsm of bus_bridge_16 is

   -- Architecture Declarations
   signal cmd_write: std_logic;
   signal cmd_fifowrite: std_logic;
   signal cmd_blockwrite: std_logic;
   signal cmd_read: std_logic;
   signal cmd_blockread: std_logic;
   signal cmd_fiforead: std_logic;
   signal cmd_escape: std_logic;
   signal cmd_par: std_logic;
   signal num: std_logic_vector(7 downto 0);
   signal nibble: std_logic_vector(3 downto 0);
   signal response_nibble: std_logic_vector(3 downto 0);
   signal response_nibble_rx: std_logic_vector(3 downto 0);
   signal response_nibble_tx: std_logic_vector(3 downto 0);
   signal response_en_rx, response_en_tx: std_logic;
   signal bus_addr_int: std_logic_vector(bus_addr'range);
   signal bus_dout_int: std_logic_vector(bus_dout'range);
   signal response_int: std_logic_vector(response'range);
   signal bus_din_tmp: std_logic_vector(bus_dout'range);
   signal data_en: std_logic;
   signal lock_rx, lock_tx: std_logic;
   signal slv_txd: std_logic_vector(bus_dout'range);
   
   function to_ascii(arg: std_logic_vector(7 downto 0)) return std_logic_vector is
      variable offset: std_logic_vector(7 downto 0);
      variable result:  std_logic_vector(7 downto 0);
   begin
      if arg < "00001010" then
          offset := X"30";
      else
          offset := X"37";
      end if;
      result := (arg) + offset;
      return(result);
   end to_ascii;

   type rx_csm_state_type is (
      s_write,
      s_addr0,
      s_addr1,
      s_data0,
      s_data1,
      s_read,
      s_addr2,
      s_addr3,
      s_data2,
      s_data3,
      s_addr4,
      s_addr5,
      s_addr6,
      s_addr7,
      s_data4,
      s_data5,
      s_data6,
      s_data7,
      s_reg,
      s_read1,
      s_addr8,
      s_addr9,
      s_addr10,
      s_addr11,
      s_num0,
      s_num1,
      s_reg1,
      s_data10,
      s_data11,
      s_data12,
      s_data13,
      s0,
      s_halt,
      s_arb0,
      s_arb1,
      s_arb2,
      s_fwrite,
      s_fwaddr0,
      s_fwaddr1,
      s_fwaddr2,
      s_fwaddr3,
      s_fwdata0,
      s_fwdata1,
      s_fwdata2,
      s_data15,
      s_arb3,
      s_escape,
      s_data8,
      s_data9,
      s_data14,
      s_data16,
      s_data17,
      s_data18,
      s_data19,
      s_data20
   );
   type csm_state_type is (
      s1,
      s2
   );
 
   -- Declare current and next state signals
   signal rx_csm_current_state : rx_csm_state_type;
   signal rx_csm_next_state : rx_csm_state_type;
   signal csm_current_state : csm_state_type;
   signal csm_next_state : csm_state_type;

   -- Declare any pre-registered internal signals
   signal slv_ack_cld : std_logic ;

begin

   -----------------------------------------------------------------
   rx_csm_clocked_proc : process ( 
      clk
   )
   -----------------------------------------------------------------
   begin
      if (clk'event and clk = '1') then
         if (reset = '1') then
            rx_csm_current_state <= s_halt;
            -- Default Reset Values
            bus_dout_int <= (others => '0');
            lock_rx <= '0';
            response_en_rx <= '0';
         else
            rx_csm_current_state <= rx_csm_next_state;
            -- Default Assignment To Internals
            response_en_rx <= '0';

            -- Combined Actions
            case rx_csm_current_state is
               when s_write => 
                  if (cmd_we = '1') then 
                     bus_addr_int(15 downto 12) <= nibble;
                  end if;
               when s_addr0 => 
                  if (cmd_we = '1') then 
                     bus_addr_int(11 downto 8) <= nibble;
                  end if;
               when s_addr1 => 
                  if (cmd_we = '1') then 
                     bus_addr_int(7 downto 4) <= nibble;
                  end if;
               when s_data0 => 
                  if (cmd_we = '1') then 
                     bus_dout_int(11 downto 8) <= nibble;
                  end if;
               when s_data1 => 
                  if (cmd_we = '1') then 
                     bus_dout_int(7 downto 4) <= nibble;
                  end if;
               when s_read => 
                  if (cmd_we = '1') then 
                     bus_addr_int(15 downto 12) <= nibble;
                  end if;
               when s_addr2 => 
                  if (cmd_we = '1') then 
                     bus_addr_int(11 downto 8) <= nibble;
                  end if;
               when s_addr3 => 
                  if (cmd_we = '1') then 
                     bus_addr_int(7 downto 4) <= nibble;
                  end if;
               when s_data2 => 
                  if (tx_ack = '1') then 
                     response_nibble_rx <= bus_din_tmp(27 downto 24);
                     response_en_rx <= '1';
                  end if;
               when s_data3 => 
                  if (tx_ack = '1') then 
                     response_nibble_rx <= bus_din_tmp(23 downto 20);
                     response_en_rx <= '1';
                  end if;
               when s_addr4 => 
                  if (cmd_we = '1') then 
                     bus_addr_int(3 downto 0) <= nibble;
                  end if;
               when s_addr5 => 
                  if (cmd_we = '1') then 
                     bus_addr_int(3 downto 0) <= nibble;
                  end if;
               when s_addr6 => 
                  if (cmd_we = '1') then 
                     bus_dout_int(31 downto 28) <= nibble;
                  end if;
               when s_addr7 => 
                  if (bus_ack = '1') then 
                     bus_din_tmp <= bus_din;
                  end if;
               when s_data4 => 
                  if (tx_ack = '1') then 
                     response_nibble_rx <= bus_din_tmp(19 downto 16);
                     response_en_rx <= '1';
                  end if;
               when s_data5 => 
                  if (cmd_we = '1') then 
                     bus_dout_int(3 downto 0) <= nibble;
                  end if;
               when s_data7 => 
                  if (tx_ack = '1') then 
                     response_nibble_rx <= bus_din_tmp(15 downto 12);
                     response_en_rx <= '1';
                  end if;
               when s_reg => 
                  if (lock_tx = '0') then 
                     response_nibble_rx <= bus_din_tmp(31 downto 28);
                     response_en_rx <= '1';
                     lock_rx <= '1';
                  end if;
               when s_read1 => 
                  if (cmd_we = '1') then 
                     bus_addr_int(15 downto 12) <= nibble;
                  end if;
               when s_addr8 => 
                  if (cmd_we = '1') then 
                     bus_addr_int(11 downto 8) <= nibble;
                  end if;
               when s_addr9 => 
                  if (cmd_we = '1') then 
                     bus_addr_int(7 downto 4) <= nibble;
                  end if;
               when s_addr10 => 
                  if (cmd_we = '1') then 
                     bus_addr_int(3 downto 0) <= nibble;
                  end if;
               when s_addr11 => 
                  if (cmd_we = '1') then 
                     num(7 downto 4) <= nibble;
                  end if;
               when s_num0 => 
                  if (cmd_we = '1') then 
                     num(3 downto 0) <= nibble;
                  end if;
               when s_reg1 => 
                  if (lock_tx = '0') then 
                     response_nibble_rx <= bus_din_tmp(15 downto 12);
                     response_en_rx <= '1';
                     lock_rx <= '1';
                  end if;
               when s_data10 => 
                  if (tx_ack = '1') then 
                     response_nibble_rx <= bus_din_tmp(11 downto 8);
                     response_en_rx <= '1';
                  end if;
               when s_data11 => 
                  if (tx_ack = '1') then 
                     response_nibble_rx <= bus_din_tmp(7 downto 4);
                     response_en_rx <= '1';
                  end if;
               when s_data12 => 
                  if (tx_ack = '1') then 
                     response_nibble_rx <= bus_din_tmp(3 downto 0);
                     response_en_rx <= '1';
                  end if;
               when s_data13 => 
                  if (tx_ack = '1') then 
                     num <= num-1;
                     if cmd_par = '0' then -- increment
                        bus_addr_int <= bus_addr_int+1;
                     end if;
                  end if;
               when s0 => 
                  if (not(num /= 0)) then 
                     lock_rx <= '0';
                  end if;
               when s_arb2 => 
                  if (bus_ack = '1') then 
                     bus_din_tmp <= bus_din;
                  end if;
               when s_fwrite => 
                  if (cmd_we = '1') then 
                     bus_addr_int(15 downto 12) <= nibble;
                  end if;
               when s_fwaddr0 => 
                  if (cmd_we = '1') then 
                     bus_addr_int(11 downto 8) <= nibble;
                  end if;
               when s_fwaddr1 => 
                  if (cmd_we = '1') then 
                     bus_addr_int(7 downto 4) <= nibble;
                  end if;
               when s_fwaddr2 => 
                  if (cmd_we = '1') then 
                     bus_addr_int(3 downto 0) <= nibble;
                  end if;
               when s_fwaddr3 => 
                  if (cmd_we = '1') then 
                     bus_dout_int(15 downto 12) <= nibble;
                  end if;
               when s_fwdata0 => 
                  if (cmd_we = '1') then 
                     bus_dout_int(11 downto 8) <= nibble;
                  end if;
               when s_fwdata1 => 
                  if (cmd_we = '1') then 
                     bus_dout_int(7 downto 4) <= nibble;
                  end if;
               when s_fwdata2 => 
                  if (cmd_we = '1') then 
                     bus_dout_int(3 downto 0) <= nibble;
                  end if;
               when s_arb3 => 
                  if (bus_ack = '1') then 
                     bus_addr_int <= bus_addr_int+1;
                  end if;
               when s_data8 => 
                  if (cmd_we = '1') then 
                     bus_dout_int(27 downto 24) <= nibble;
                  end if;
               when s_data9 => 
                  if (cmd_we = '1') then 
                     bus_dout_int(23 downto 20) <= nibble;
                  end if;
               when s_data14 => 
                  if (cmd_we = '1') then 
                     bus_dout_int(19 downto 16) <= nibble;
                  end if;
               when s_data16 => 
                  if (cmd_we = '1') then 
                     bus_dout_int(15 downto 12) <= nibble;
                  end if;
               when s_data17 => 
                  if (tx_ack = '1') then 
                     response_nibble_rx <= bus_din_tmp(11 downto 8);
                     response_en_rx <= '1';
                  end if;
               when s_data18 => 
                  if (tx_ack = '1') then 
                     response_nibble_rx <= bus_din_tmp(7 downto 4);
                     response_en_rx <= '1';
                  end if;
               when s_data19 => 
                  if (tx_ack = '1') then 
                     response_nibble_rx <= bus_din_tmp(3 downto 0);
                     response_en_rx <= '1';
                  end if;
               when s_data20 => 
                  if (tx_ack = '1') then 
                     lock_rx <= '0';
                  end if;
               when others =>
                  null;
            end case;

            -- Interrupts
            if (cmd_read = '1') then
               null;
            elsif (cmd_write = '1') then
               null;
            elsif (cmd_blockread = '1') then
               cmd_par <= '0';
            elsif (cmd_fiforead = '1') then
               cmd_par <= '1';
            elsif (cmd_blockwrite = '1') then
               null;
            elsif (cmd_escape = '1') then
               null;
            end if;
         end if;
      end if;
   end process rx_csm_clocked_proc;
 
   -----------------------------------------------------------------
   rx_csm_nextstate_proc : process ( 
      bus_ack,
      bus_grant,
      cmd_blockread,
      cmd_blockwrite,
      cmd_escape,
      cmd_fiforead,
      cmd_read,
      cmd_we,
      cmd_write,
      lock_tx,
      num,
      rx_csm_current_state,
      tx_ack
   )
   -----------------------------------------------------------------
   begin
      -- Default state assignment
      rx_csm_next_state <= rx_csm_current_state;
      case rx_csm_current_state is
         when s_write => 
            if (cmd_we = '1') then 
               rx_csm_next_state <= s_addr0;
            else
               rx_csm_next_state <= s_write;
            end if;
         when s_addr0 => 
            if (cmd_we = '1') then 
               rx_csm_next_state <= s_addr1;
            else
               rx_csm_next_state <= s_addr0;
            end if;
         when s_addr1 => 
            if (cmd_we = '1') then 
               rx_csm_next_state <= s_addr4;
            else
               rx_csm_next_state <= s_addr1;
            end if;
         when s_data0 => 
            if (cmd_we = '1') then 
               rx_csm_next_state <= s_data1;
            else
               rx_csm_next_state <= s_data0;
            end if;
         when s_data1 => 
            if (cmd_we = '1') then 
               rx_csm_next_state <= s_data5;
            else
               rx_csm_next_state <= s_data1;
            end if;
         when s_read => 
            if (cmd_we = '1') then 
               rx_csm_next_state <= s_addr2;
            else
               rx_csm_next_state <= s_read;
            end if;
         when s_addr2 => 
            if (cmd_we = '1') then 
               rx_csm_next_state <= s_addr3;
            else
               rx_csm_next_state <= s_addr2;
            end if;
         when s_addr3 => 
            if (cmd_we = '1') then 
               rx_csm_next_state <= s_addr5;
            else
               rx_csm_next_state <= s_addr3;
            end if;
         when s_data2 => 
            if (tx_ack = '1') then 
               rx_csm_next_state <= s_data3;
            else
               rx_csm_next_state <= s_data2;
            end if;
         when s_data3 => 
            if (tx_ack = '1') then 
               rx_csm_next_state <= s_data4;
            else
               rx_csm_next_state <= s_data3;
            end if;
         when s_addr4 => 
            if (cmd_we = '1') then 
               rx_csm_next_state <= s_addr6;
            else
               rx_csm_next_state <= s_addr4;
            end if;
         when s_addr5 => 
            if (cmd_we = '1') then 
               rx_csm_next_state <= s_arb1;
            else
               rx_csm_next_state <= s_addr5;
            end if;
         when s_addr6 => 
            if (cmd_we = '1') then 
               rx_csm_next_state <= s_data8;
            else
               rx_csm_next_state <= s_addr6;
            end if;
         when s_addr7 => 
            if (bus_ack = '1') then 
               rx_csm_next_state <= s_reg;
            else
               rx_csm_next_state <= s_addr7;
            end if;
         when s_data4 => 
            if (tx_ack = '1') then 
               rx_csm_next_state <= s_data7;
            else
               rx_csm_next_state <= s_data4;
            end if;
         when s_data5 => 
            if (cmd_we = '1') then 
               rx_csm_next_state <= s_data6;
            else
               rx_csm_next_state <= s_data5;
            end if;
         when s_data6 => 
            if (bus_grant = '1') then 
               rx_csm_next_state <= s_arb0;
            else
               rx_csm_next_state <= s_data6;
            end if;
         when s_data7 => 
            if (tx_ack = '1') then 
               rx_csm_next_state <= s_data17;
            else
               rx_csm_next_state <= s_data7;
            end if;
         when s_reg => 
            if (lock_tx = '0') then 
               rx_csm_next_state <= s_data2;
            else
               rx_csm_next_state <= s_reg;
            end if;
         when s_read1 => 
            if (cmd_we = '1') then 
               rx_csm_next_state <= s_addr8;
            else
               rx_csm_next_state <= s_read1;
            end if;
         when s_addr8 => 
            if (cmd_we = '1') then 
               rx_csm_next_state <= s_addr9;
            else
               rx_csm_next_state <= s_addr8;
            end if;
         when s_addr9 => 
            if (cmd_we = '1') then 
               rx_csm_next_state <= s_addr10;
            else
               rx_csm_next_state <= s_addr9;
            end if;
         when s_addr10 => 
            if (cmd_we = '1') then 
               rx_csm_next_state <= s_addr11;
            else
               rx_csm_next_state <= s_addr10;
            end if;
         when s_addr11 => 
            if (cmd_we = '1') then 
               rx_csm_next_state <= s_num0;
            else
               rx_csm_next_state <= s_addr11;
            end if;
         when s_num0 => 
            if (cmd_we = '1') then 
               rx_csm_next_state <= s_num1;
            else
               rx_csm_next_state <= s_num0;
            end if;
         when s_num1 => 
            if (bus_grant = '1') then 
               rx_csm_next_state <= s_arb2;
            else
               rx_csm_next_state <= s_num1;
            end if;
         when s_reg1 => 
            if (lock_tx = '0') then 
               rx_csm_next_state <= s_data10;
            else
               rx_csm_next_state <= s_reg1;
            end if;
         when s_data10 => 
            if (tx_ack = '1') then 
               rx_csm_next_state <= s_data11;
            else
               rx_csm_next_state <= s_data10;
            end if;
         when s_data11 => 
            if (tx_ack = '1') then 
               rx_csm_next_state <= s_data12;
            else
               rx_csm_next_state <= s_data11;
            end if;
         when s_data12 => 
            if (tx_ack = '1') then 
               rx_csm_next_state <= s_data13;
            else
               rx_csm_next_state <= s_data12;
            end if;
         when s_data13 => 
            if (tx_ack = '1') then 
               rx_csm_next_state <= s0;
            else
               rx_csm_next_state <= s_data13;
            end if;
         when s0 => 
            if (num /= 0) then 
               rx_csm_next_state <= s_num1;
            else
               rx_csm_next_state <= s_halt;
            end if;
         when s_halt => 
            rx_csm_next_state <= s_halt;
         when s_arb0 => 
            if (bus_ack = '1') then 
               rx_csm_next_state <= s_halt;
            else
               rx_csm_next_state <= s_arb0;
            end if;
         when s_arb1 => 
            if (bus_grant = '1') then 
               rx_csm_next_state <= s_addr7;
            else
               rx_csm_next_state <= s_arb1;
            end if;
         when s_arb2 => 
            if (bus_ack = '1') then 
               rx_csm_next_state <= s_reg1;
            else
               rx_csm_next_state <= s_arb2;
            end if;
         when s_fwrite => 
            if (cmd_we = '1') then 
               rx_csm_next_state <= s_fwaddr0;
            else
               rx_csm_next_state <= s_fwrite;
            end if;
         when s_fwaddr0 => 
            if (cmd_we = '1') then 
               rx_csm_next_state <= s_fwaddr1;
            else
               rx_csm_next_state <= s_fwaddr0;
            end if;
         when s_fwaddr1 => 
            if (cmd_we = '1') then 
               rx_csm_next_state <= s_fwaddr2;
            else
               rx_csm_next_state <= s_fwaddr1;
            end if;
         when s_fwaddr2 => 
            if (cmd_we = '1') then 
               rx_csm_next_state <= s_fwaddr3;
            else
               rx_csm_next_state <= s_fwaddr2;
            end if;
         when s_fwaddr3 => 
            if (cmd_we = '1') then 
               rx_csm_next_state <= s_fwdata0;
            else
               rx_csm_next_state <= s_fwaddr3;
            end if;
         when s_fwdata0 => 
            if (cmd_we = '1') then 
               rx_csm_next_state <= s_fwdata1;
            else
               rx_csm_next_state <= s_fwdata0;
            end if;
         when s_fwdata1 => 
            if (cmd_we = '1') then 
               rx_csm_next_state <= s_fwdata2;
            else
               rx_csm_next_state <= s_fwdata1;
            end if;
         when s_fwdata2 => 
            if (cmd_we = '1') then 
               rx_csm_next_state <= s_data15;
            else
               rx_csm_next_state <= s_fwdata2;
            end if;
         when s_data15 => 
            if (bus_grant = '1') then 
               rx_csm_next_state <= s_arb3;
            else
               rx_csm_next_state <= s_data15;
            end if;
         when s_arb3 => 
            if (bus_ack = '1') then 
               rx_csm_next_state <= s_fwaddr3;
            else
               rx_csm_next_state <= s_arb3;
            end if;
         when s_escape => 
            rx_csm_next_state <= s_escape;
         when s_data8 => 
            if (cmd_we = '1') then 
               rx_csm_next_state <= s_data9;
            else
               rx_csm_next_state <= s_data8;
            end if;
         when s_data9 => 
            if (cmd_we = '1') then 
               rx_csm_next_state <= s_data14;
            else
               rx_csm_next_state <= s_data9;
            end if;
         when s_data14 => 
            if (cmd_we = '1') then 
               rx_csm_next_state <= s_data16;
            else
               rx_csm_next_state <= s_data14;
            end if;
         when s_data16 => 
            if (cmd_we = '1') then 
               rx_csm_next_state <= s_data0;
            else
               rx_csm_next_state <= s_data16;
            end if;
         when s_data17 => 
            if (tx_ack = '1') then 
               rx_csm_next_state <= s_data18;
            else
               rx_csm_next_state <= s_data17;
            end if;
         when s_data18 => 
            if (tx_ack = '1') then 
               rx_csm_next_state <= s_data19;
            else
               rx_csm_next_state <= s_data18;
            end if;
         when s_data19 => 
            if (tx_ack = '1') then 
               rx_csm_next_state <= s_data20;
            else
               rx_csm_next_state <= s_data19;
            end if;
         when s_data20 => 
            if (tx_ack = '1') then 
               rx_csm_next_state <= s_halt;
            else
               rx_csm_next_state <= s_data20;
            end if;
         when others =>
            rx_csm_next_state <= s_halt;
      end case;

      -- Interrupts
      if (cmd_read = '1') then
         rx_csm_next_state <= s_read;
      elsif (cmd_write = '1') then
         rx_csm_next_state <= s_write;
      elsif (cmd_blockread = '1') then
         rx_csm_next_state <= s_read1;
      elsif (cmd_fiforead = '1') then
         rx_csm_next_state <= s_read1;
      elsif (cmd_blockwrite = '1') then
         rx_csm_next_state <= s_fwrite;
      elsif (cmd_escape = '1') then
         rx_csm_next_state <= s_escape;
      end if;
   end process rx_csm_nextstate_proc;
 
   -----------------------------------------------------------------
   rx_csm_output_proc : process ( 
      rx_csm_current_state
   )
   -----------------------------------------------------------------
   begin
      -- Default Assignment
      bus_rd <= '0';
      bus_request <= '0';
      bus_we <= '0';
      -- Default Assignment To Internals
      data_en <= '0';

      -- Combined Actions
      case rx_csm_current_state is
         when s_addr7 => 
            bus_rd <= '1';
            bus_request <= '1';
            data_en <= '1';
         when s_data6 => 
            bus_request <=  '1';
         when s_num1 => 
            bus_request <= '1';
         when s_arb0 => 
            bus_request <=  '1';
            data_en <= '1';
            bus_we <= '1';
         when s_arb1 => 
            bus_request <= '1';
         when s_arb2 => 
            bus_rd <= '1';
            bus_request <= '1';
            data_en <= '1';
         when s_data15 => 
            bus_request <=  '1';
         when s_arb3 => 
            bus_request <=  '1';
            data_en <= '1';
            bus_we <= '1';
         when others =>
            null;
      end case;
   end process rx_csm_output_proc;
 
   -----------------------------------------------------------------
   csm_clocked_proc : process ( 
      clk
   )
   -----------------------------------------------------------------
   begin
      if (clk'event and clk = '1') then
         if (reset = '1') then
            csm_current_state <= s1;
         else
            csm_current_state <= csm_next_state;
         end if;
      end if;
   end process csm_clocked_proc;
 
   -----------------------------------------------------------------
   csm_nextstate_proc : process ( 
      csm_current_state,
      slv_cs,
      slv_we
   )
   -----------------------------------------------------------------
   begin
      -- Default state assignment
      csm_next_state <= csm_current_state;
      case csm_current_state is
         when s1 => 
            if (slv_we = '1' and slv_cs = '1') then 
               csm_next_state <= s2;
            else
               csm_next_state <= s1;
            end if;
         when s2 => 
            csm_next_state <= s2;
         when others =>
            csm_next_state <= s1;
      end case;
   end process csm_nextstate_proc;
 
   -- Concurrent Statements
   -- Clocked output assignments
   slv_ack <= slv_ack_cld;
   -- command decoder ----------------------
       cmd_write <= '1' when cmd = X"77" else '0'; -- 'W'
       cmd_blockwrite <= '1' when cmd = X"76" else '0'; -- 'V'
       cmd_read <= '1' when cmd = X"72" else '0';  --'R'
       cmd_blockread <= '1' when cmd = X"62" else '0';  --'B'
       cmd_fiforead <= '1' when cmd = X"66" else '0';  --'F'
       cmd_escape <= '1' when cmd < X"20" else '0';
   
       -- calculate nibble from ASCII-code ------------------------------------
       nibble <= cmd(3 downto 0) when cmd(6) = '0' else cmd(3 downto 0) + "1001";
       bus_dout <=bus_dout_int when data_en = '1' else (others => '0');
       bus_addr <= bus_addr_int when data_en = '1' else (others => '0');
   
   ---calculate ASCII-code from nibble -----------------------------------------
      response_nibble <= response_nibble_rx when lock_rx='1' else
                                      response_nibble_tx; 
      response_int <= to_ascii("0000"&response_nibble);
       response <= response_int;
      response_en <= response_en_rx or response_en_tx;
end fsm;
