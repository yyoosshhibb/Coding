-- VHDL Entity sbus_awfg_lib.top_awfg.symbol
--
-- Created:
--          by - Net.UNKNOWN (M00443)
--          at - 11:48:56 22.06.2022
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2017.1a (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

entity top_awfg is
   generic( 
      C_SLV_ADDR_BASE      : std_logic_vector := X"0000";
      C_SLV_ADDR_RANGE     : std_logic_vector := X"0000";
      C_CORE_CLK_FREQUENCY : integer          := 100000000;
      simulation_g         : boolean          := false
   );
   port( 
      buttons    : in     std_logic_vector (3 downto 0);
      clk        : in     std_logic;
      reset      : in     std_logic;
      rxd        : in     std_logic;
      sbus_addr  : in     std_logic_vector (15 downto 0);
      sbus_be    : in     std_logic_vector (3 downto 0);
      sbus_rd    : in     std_logic;
      sbus_wdata : in     std_logic_vector (31 downto 0);
      sbus_we    : in     std_logic;
      sliders    : in     std_logic_vector (3 downto 0);
      dac_sclk   : out    std_logic;
      dac_sdin0  : out    std_logic;
      dac_sdin1  : out    std_logic;
      dac_sync   : out    std_logic;
      leds       : out    std_logic_vector (3 downto 0);
      pmod_jc    : out    std_logic_vector (7 downto 0);
      sbus_ack   : out    std_logic;
      sbus_rdata : out    std_logic_vector (31 downto 0);
      txd        : out    std_logic
   );

-- Declarations

end top_awfg ;

--
-- VHDL Architecture sbus_awfg_lib.top_awfg.struct
--
-- Created:
--          by - Net.UNKNOWN (M00443)
--          at - 11:48:56 22.06.2022
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2017.1a (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
use IEEE.numeric_std.ALL;
library sbus_awfg_lib;
use sbus_awfg_lib.FPGA_pkg.ALL;
library work;
use work.utilities.all;


architecture struct of top_awfg is

   -- Architecture declarations

   -- Internal signal declarations
   signal C0             : std_logic_vector(31 downto 0);
   signal C1             : std_logic_vector(31 downto 0);
   signal C2             : std_logic_vector(31 downto 0);
   signal C3             : std_logic_vector(31 downto 0);
   signal M              : std_logic_vector(31 downto 0);
   signal Reset_HDL      : std_logic_vector(31 downto 0);
   signal amplitude      : std_logic_vector(31 downto 0);
   signal amplitude_cpu  : std_logic_vector(31 downto 0);
   signal amplitude_uart : std_logic_vector(31 downto 0);
   signal bus_ack        : std_logic;
   signal bus_addr       : std_logic_vector(15 downto 0);
   signal bus_be         : std_logic_vector(3 downto 0);
   signal bus_din        : std_logic_vector(31 downto 0);
   signal bus_dout       : std_logic_vector(31 downto 0);
   signal bus_rd         : std_logic;
   signal bus_we         : std_logic;
   signal buttons_s      : std_logic_vector(3 downto 0);
   signal buttons_stb    : std_logic_vector(3 downto 0);
   signal cc_addr        : std_logic_vector(31 downto 0);
   signal cc_write       : std_logic;
   signal cnt            : std_logic_vector(15 downto 0);
   signal dac0           : std_logic_vector(15 downto 0);
   signal dac1           : std_logic_vector(15 downto 0);
   signal encoder0       : std_logic_vector(1 downto 0);
   signal encoder0_s     : std_logic_vector(1 downto 0);
   signal encoder0_stb   : std_logic_vector(1 downto 0);
   signal encoder1       : std_logic_vector(1 downto 0);
   signal encoder1_s     : std_logic_vector(1 downto 0);
   signal encoder1_stb   : std_logic_vector(1 downto 0);
   signal frequency      : std_logic_vector(31 downto 0);
   signal frequency_cpu  : std_logic_vector(31 downto 0);
   signal frequency_uart : std_logic_vector(31 downto 0);
   signal hi             : std_logic;
   signal lo             : std_logic;
   signal pmod_o         : std_logic_vector(7 downto 0);
   signal sample_daq     : std_logic;
   signal sbus_o_null    : sbus_o_t;
   signal sbus_o_null1   : sbus_o_t;
   signal sliders_s      : std_logic_vector(3 downto 0);
   signal sliders_stb    : std_logic_vector(3 downto 0);
   signal tper_cnt       : std_logic_vector(31 downto 0);
   signal wf             : std_logic_vector(31 downto 0);


   -- Component Declarations
   component FPGA
   port (
      Addr       : in     std_logic_vector (31 downto 0);
      C0         : in     std_logic_vector (31 downto 0);
      C1         : in     std_logic_vector (31 downto 0);
      C2         : in     std_logic_vector (31 downto 0);
      C3         : in     std_logic_vector (31 downto 0);
      M          : in     std_logic_vector (31 downto 0);
      Reset_HDL  : in     std_logic_vector (31 downto 0);
      Write      : in     std_logic;
      amplitude  : in     std_logic_vector (31 downto 0);
      clk        : in     std_logic;
      clk_enable : in     std_logic;
      frequency  : in     std_logic_vector (31 downto 0);
      reset      : in     std_logic;
      tper_cnt   : in     std_logic_vector (31 downto 0);
      WF         : out    std_logic_vector (31 downto 0);
      ce_out     : out    std_logic
   );
   end component;
   component cnt_modulus
   generic (
      n_dout_g : integer := 8;
      module_g : integer := 256
   );
   port (
      clk    : in     std_logic ;
      enable : in     std_logic ;
      reset  : in     std_logic ;
      dout   : out    std_logic_vector (n_dout_g-1 downto 0);
      tc     : out    std_logic 
   );
   end component;
   component comp_signal_synchr
   generic (
      simulation_g : boolean := false
   );
   port (
      buttons      : in     std_logic_vector (3 downto 0);
      sliders      : in     std_logic_vector (3 downto 0);
      encoder0     : in     std_logic_vector (1 downto 0);
      encoder1     : in     std_logic_vector (1 downto 0);
      buttons_s    : out    std_logic_vector (3 downto 0);
      sliders_s    : out    std_logic_vector (3 downto 0);
      encoder0_s   : out    std_logic_vector (1 downto 0);
      encoder1_s   : out    std_logic_vector (1 downto 0);
      buttons_stb  : out    std_logic_vector (3 downto 0);
      sliders_stb  : out    std_logic_vector (3 downto 0);
      encoder0_stb : out    std_logic_vector (1 downto 0);
      encoder1_stb : out    std_logic_vector (1 downto 0);
      clk          : in     std_logic 
   );
   end component;
   component comp_timer
   generic (
      core_clk_freq_g : integer := 125000000;
      timer_freq_g    : integer := 1000
   );
   port (
      clk       : in     std_logic ;
      reset     : in     std_logic ;
      timer_wav : out    std_logic ;
      timer_stb : out    std_logic 
   );
   end component;
   component dac_ctrl
   port (
      -- Users to add ports here
      clk           : in     std_logic ;
      dac0          : in     std_logic_vector (15 downto 0);
      dac1          : in     std_logic_vector (15 downto 0);
      format_signed : in     std_logic ;
      reset         : in     std_logic ;
      sample_dac    : in     std_logic ;
      dac_sclk      : out    std_logic ;
      dac_sdin0     : out    std_logic ;
      dac_sdin1     : out    std_logic ;
      dac_sync      : out    std_logic 
   );
   end component;
   component registers
   generic (
      addr_width_g : integer := 16;      --width of address
      data_width_g : integer := 32;      --width of data
      addr_base_g  : std_logic_vector;
      addr_range_g : std_logic_vector;
      --$nregs_g
      nregs_g      : integer := 16
   );
   port (
      amplitude   : in     std_logic_vector (31 downto 0);
      buttons     : in     std_logic_vector (3 downto 0);
      clk         : in     std_logic;
      frequency   : in     std_logic_vector (31 downto 0);
      reset       : in     std_logic;
      sbus_addr   : in     std_logic_vector (15 downto 0);
      sbus_be     : in     std_logic_vector (3 downto 0);
      sbus_o_mst  : in     sbus_o_t;
      sbus_rd     : in     std_logic;
      sbus_wdata  : in     std_logic_vector (31 downto 0);
      sbus_we     : in     std_logic;
      sliders     : in     std_logic_vector (3 downto 0);
      amplitude_o : out    std_logic_vector (31 downto 0);
      c0          : out    std_logic_vector (31 downto 0);
      c1          : out    std_logic_vector (31 downto 0);
      c2          : out    std_logic_vector (31 downto 0);
      c3          : out    std_logic_vector (31 downto 0);
      cc_addr     : out    std_logic_vector (31 downto 0);
      cc_write    : out    std_logic;
      frequency_o : out    std_logic_vector (31 downto 0);
      leds        : out    std_logic_vector (3 downto 0);
      m           : out    std_logic_vector (31 downto 0);
      pmod_o      : out    std_logic_vector (7 downto 0);
      reset_hdl   : out    std_logic_vector (31 downto 0);
      sbus_ack    : out    std_logic;
      sbus_i_mst  : out    sbus_i_t;
      sbus_o_null : out    sbus_o_t;
      sbus_rdata  : out    std_logic_vector (31 downto 0);
      tper_cnt    : out    std_logic_vector (31 downto 0)
   );
   end component;
   component uart_bridge_32
   generic (
      core_clk_freq_g : integer := 50000000;
      baudrate_g      : integer := 115200;
      simulate_g      : boolean := false;
      commandfile_g   : string  := "command.txt"
   );
   port (
      bus_ack  : in     std_logic ;
      bus_din  : in     std_logic_vector (31 downto 0);
      clk      : in     std_logic ;
      reset    : in     std_logic ;
      rxd      : in     std_logic ;
      bus_addr : out    std_logic_vector (15 downto 0);
      bus_be   : out    std_logic_vector (3 downto 0);
      bus_dout : out    std_logic_vector (31 downto 0);
      bus_rd   : out    std_logic ;
      bus_we   : out    std_logic ;
      txd      : out    std_logic 
   );
   end component;
   component uart_regs
   generic (
      addr_width_g : integer := 16;      --width of address
      data_width_g : integer := 32;      --width of data
      addr_base_g  : std_logic_vector;
      addr_range_g : std_logic_vector;
      --$nregs_g
      nregs_g      : integer := 4
   );
   port (
      clk         : in     std_logic;
      reset       : in     std_logic;
      sbus_addr   : in     std_logic_vector (15 downto 0);
      sbus_be     : in     std_logic_vector (3 downto 0);
      sbus_o_mst  : in     sbus_o_t;
      sbus_rd     : in     std_logic;
      sbus_wdata  : in     std_logic_vector (31 downto 0);
      sbus_we     : in     std_logic;
      amplitude   : out    std_logic_vector (31 downto 0);
      frequency   : out    std_logic_vector (31 downto 0);
      sbus_ack    : out    std_logic;
      sbus_i_mst  : out    sbus_i_t;
      sbus_o_null : out    sbus_o_t;
      sbus_rdata  : out    std_logic_vector (31 downto 0)
   );
   end component;

   -- Optional embedded configurations
   -- pragma synthesis_off
   for all : FPGA use entity sbus_awfg_lib.FPGA;
   for all : cnt_modulus use entity sbus_awfg_lib.cnt_modulus;
   for all : comp_signal_synchr use entity sbus_awfg_lib.comp_signal_synchr;
   for all : comp_timer use entity sbus_awfg_lib.comp_timer;
   for all : dac_ctrl use entity sbus_awfg_lib.dac_ctrl;
   for all : registers use entity sbus_awfg_lib.registers;
   for all : uart_bridge_32 use entity sbus_awfg_lib.uart_bridge_32;
   for all : uart_regs use entity sbus_awfg_lib.uart_regs;
   -- pragma synthesis_on


begin
   -- Architecture concurrent statements
   -- HDL Embedded Text Block 1 constants
   -- eb1 1
   hi <= '1';
   lo <= '0';                                     

   -- HDL Embedded Text Block 2 debug_mux
   -- debug_mux 
   process(clk)
   begin
      if rising_edge(clk) then
         if sliders_s(3) = '0' then
              amplitude <= amplitude_cpu;
              frequency <= frequency_cpu;
         else
              amplitude <= amplitude_uart;
              frequency <= frequency_uart;
         end if;
      end if;
   end process;                                      

   -- HDL Embedded Text Block 6 pmod_port1
   -- Pmod - Debug Outputs ----------------
   process(clk)
   begin
      if rising_edge(clk) then
         if sliders_s(0) = '0' then
             pmod_jc <= cc_write & cc_addr(6 downto 0);
        else   
             pmod_jc <= pmod_o;   
         end if;
      end if;
   end process;      
                        

   -- HDL Embedded Text Block 7 dac_mux
   -- DAC - Debug Output ----------------
   process(clk)
   begin
      if rising_edge(clk) then
         if sliders_s(1) = '1' then
             dac1  <= cnt ;
             dac0 <= not cnt;
        else   
             dac1 <= cc_addr(7 downto 0) & X"00";  
             if sliders_s(2) = '0' then
                  dac0 <= wf(31 downto 16);
              else
                  dac0 <= wf(23 downto 8);
              end if; 
         end if;
      end if;
   end process;      
                        


   -- Instance port mappings.
   U_0 : FPGA
      port map (
         clk        => clk,
         reset      => reset,
         clk_enable => hi,
         Write      => cc_write,
         Addr       => cc_addr,
         C0         => C0,
         C1         => C1,
         C2         => C2,
         C3         => C3,
         M          => M,
         tper_cnt   => tper_cnt,
         Reset_HDL  => Reset_HDL,
         frequency  => frequency,
         amplitude  => amplitude,
         ce_out     => open,
         WF         => wf
      );
   U_4 : cnt_modulus
      generic map (
         n_dout_g => 16,
         module_g => 2**16
      )
      port map (
         clk    => clk,
         enable => hi,
         reset  => reset,
         dout   => cnt,
         tc     => open
      );
   U_3 : comp_signal_synchr
      generic map (
         simulation_g => simulation_g
      )
      port map (
         buttons      => buttons,
         sliders      => sliders,
         encoder0     => encoder0,
         encoder1     => encoder1,
         buttons_s    => buttons_s,
         sliders_s    => sliders_s,
         encoder0_s   => encoder0_s,
         encoder1_s   => encoder1_s,
         buttons_stb  => buttons_stb,
         sliders_stb  => sliders_stb,
         encoder0_stb => encoder0_stb,
         encoder1_stb => encoder1_stb,
         clk          => clk
      );
   U_7 : comp_timer
      generic map (
         core_clk_freq_g => C_CORE_CLK_FREQUENCY,
         timer_freq_g    => 1000000
      )
      port map (
         clk       => clk,
         reset     => reset,
         timer_wav => open,
         timer_stb => sample_daq
      );
   U_2 : dac_ctrl
      port map (
         clk           => clk,
         dac0          => dac0,
         dac1          => dac1,
         format_signed => hi,
         reset         => reset,
         sample_dac    => sample_daq,
         dac_sclk      => dac_sclk,
         dac_sdin0     => dac_sdin0,
         dac_sdin1     => dac_sdin1,
         dac_sync      => dac_sync
      );
   U_1 : registers
      generic map (
         addr_width_g => 16,            --width of address
         data_width_g => 32,            --width of data
         addr_base_g  => C_SLV_ADDR_BASE,
         addr_range_g => X"0010",
         --$nregs_g
         nregs_g      => 16
      )
      port map (
         sbus_addr   => sbus_addr,
         sbus_be     => sbus_be,
         sbus_rd     => sbus_rd,
         sbus_wdata  => sbus_wdata,
         sbus_we     => sbus_we,
         sbus_ack    => sbus_ack,
         sbus_rdata  => sbus_rdata,
         sbus_i_mst  => open,
         sbus_o_mst  => sbus_o_null,
         sbus_o_null => sbus_o_null,
         cc_addr     => cc_addr,
         cc_write    => cc_write,
         c0          => C0,
         c1          => C1,
         c2          => C2,
         c3          => C3,
         m           => M,
         tper_cnt    => tper_cnt,
         reset_hdl   => Reset_HDL,
         amplitude_o => amplitude_cpu,
         frequency_o => frequency_cpu,
         buttons     => buttons_s,
         sliders     => sliders_s,
         pmod_o      => pmod_o,
         amplitude   => amplitude,
         frequency   => frequency,
         leds        => leds,
         reset       => reset,
         clk         => clk
      );
   U_5 : uart_bridge_32
      generic map (
         core_clk_freq_g => C_CORE_CLK_FREQUENCY,
         baudrate_g      => 115200,
         simulate_g      => simulation_g,
         commandfile_g   => "uart_commands.txt"
      )
      port map (
         bus_ack  => bus_ack,
         bus_din  => bus_din,
         clk      => clk,
         reset    => reset,
         rxd      => rxd,
         bus_addr => bus_addr,
         bus_be   => bus_be,
         bus_dout => bus_dout,
         bus_rd   => bus_rd,
         bus_we   => bus_we,
         txd      => txd
      );
   U_6 : uart_regs
      generic map (
         addr_width_g => 16,         --width of address
         data_width_g => 32,         --width of data
         addr_base_g  => X"0000",
         addr_range_g => X"0004",
         --$nregs_g
         nregs_g      => 4
      )
      port map (
         sbus_addr   => bus_addr,
         sbus_be     => bus_be,
         sbus_rd     => bus_rd,
         sbus_wdata  => bus_dout,
         sbus_we     => bus_we,
         sbus_ack    => bus_ack,
         sbus_rdata  => bus_din,
         sbus_i_mst  => open,
         sbus_o_mst  => sbus_o_null1,
         sbus_o_null => sbus_o_null1,
         amplitude   => amplitude_uart,
         frequency   => frequency_uart,
         reset       => reset,
         clk         => clk
      );

end struct;
