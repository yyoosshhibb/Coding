/*
 * CAN_TX.c
 *
 *  Created on: Feb 10, 2023
 *      Author: Yoshi
 */

#include "can_conf.h"

CAN_data_t	*CANdata[DATANb];		//Struct for outgoing Can data
FDCAN_Tx_Frame_t	FDCAN_Tx_Bank[FDCAN_TX_MSG];

CAN_data_t	Powerlimit;
CAN_data_t	Drivemode;
CAN_data_t	FanSpeed;
CAN_data_t	PumpSpeed;

void FDCAN_TX_def()
{
	Powerlimit.CAN_id = 0x100;
	Powerlimit.CAN_length = RX_LENGTH8;
	Powerlimit.CAN_length_dec = 8;
	Powerlimit.CAN_startbit = 0;
	Powerlimit.Endianness = Motorola;
	Powerlimit.CAN_data = 80;

	Drivemode.CAN_id = 0x120;
	Drivemode.CAN_length = RX_LENGTH8;
	Drivemode.CAN_length_dec = 8;
	Drivemode.CAN_startbit = 8;
	Drivemode.Endianness = Motorola;
	Drivemode.CAN_data = 3;

	FanSpeed.CAN_id = 0x140;
	FanSpeed.CAN_length = RX_LENGTH8;
	FanSpeed.CAN_length_dec = 8;
	FanSpeed.CAN_startbit = 16;
	FanSpeed.Endianness = Motorola;
	FanSpeed.CAN_data = 128;

	PumpSpeed.CAN_id = 0x160;
	PumpSpeed.CAN_length = RX_LENGTH8;
	PumpSpeed.CAN_length_dec = 8;
	PumpSpeed.CAN_startbit = 24;
	PumpSpeed.Endianness = Motorola;
	PumpSpeed.CAN_data = 64;


	CANdata[0] = &Powerlimit;
	CANdata[1] = &Drivemode;
	CANdata[2] = &FanSpeed;
	CANdata[3] = &PumpSpeed;


	for(i=0;i<DATANb;i++)
	{
		if(CANdata[i]->CAN_id == HeaderTX.Identifier)
		{

			if(((CANdata[i]->Endianness) == Intel)&&(CANdata[i]->CAN_length_dec>8)){

			uint16_t temp = CANdata[i]->CAN_data;
			(CANdata[i]->CAN_data) = (((CANdata[i]->CAN_data)>>((CANdata[i]->CAN_length_dec)-8))&0x00FF);
			(CANdata[i]->CAN_data) |= ((temp<<8)&CANdata[i]->CAN_length);

			}
		Temp_val |= ((uint64_t)((CANdata[i]->CAN_data)&CANdata[i]->CAN_length)<<(63-CANdata[i]->CAN_startbit-(CANdata[i]->CAN_length_dec-1)));

		}
	}

	Data[7] = (uint8_t)(Temp_val);
	Data[6] = (uint8_t)(Temp_val>>8);
	Data[5] = (uint8_t)(Temp_val>>16);
	Data[4] = (uint8_t)(Temp_val>>24);
	Data[3] = (uint8_t)(Temp_val>>32);
	Data[2] = (uint8_t)(Temp_val>>40);
	Data[1] = (uint8_t)(Temp_val>>48);
	Data[0] = (uint8_t)(Temp_val>>56);
}

