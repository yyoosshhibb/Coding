/**
 * @file pmsm_foc.h
 * @date 2021-01-08
 * 
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 * @cond
 ***********************************************************************************************************************
 * PMSM_FOC v4.2.14 - Supports sensorless field oriented control (FOC) \n for permanent magnet synchronous motor(PMSM).
 *
 * Copyright (c) 2015-2020, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-05-29:
 *     - Initial version
 *
 * 2015-11-19:
 *     - FOC library code integrated
 *
 * 2018-02-14:
 * 		- Anti windup flag added in PMSM_FOC_PI_Coefs_t
 *
 * 2018-05-25:
 *     - Output path definition changed from number to define PMSM_FOC_OUTPUTPATH_SET_OUT_x
 *
 * 2021-01-08:
 *     - Modified check for minimum XMCLib version
 *
 * @endcond
 *
 */
/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#ifndef PMSM_FOC_H
#define PMSM_FOC_H

#include "pmsm_foc_conf.h"

#if (PMSM_FOC_IS_ADC_AVAILABLE == 1U)
  #include "ADC_QUEUE/adc_queue.h"
  #include "xmc_vadc.h"
#endif

#include "PWM_SVM/pwm_svm.h"

#if(UC_FAMILY == XMC4)
#include "CPU_CTRL_XMC4/cpu_ctrl_xmc4.h"
#else
#include "CPU_CTRL_XMC1/cpu_ctrl_xmc1.h"
#endif

 /**********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/
#define PMSM_FOC_XMC_LIB_MAJOR_VERSION 2
#define PMSM_FOC_XMC_LIB_MINOR_VERSION 0
#define PMSM_FOC_XMC_LIB_PATCH_VERSION 0

#if !((XMC_LIB_MAJOR_VERSION > PMSM_FOC_XMC_LIB_MAJOR_VERSION) ||\
      ((XMC_LIB_MAJOR_VERSION == PMSM_FOC_XMC_LIB_MAJOR_VERSION) && (XMC_LIB_MINOR_VERSION > PMSM_FOC_XMC_LIB_MINOR_VERSION)) ||\
      ((XMC_LIB_MAJOR_VERSION == PMSM_FOC_XMC_LIB_MAJOR_VERSION) && (XMC_LIB_MINOR_VERSION == PMSM_FOC_XMC_LIB_MINOR_VERSION) && (XMC_LIB_PATCH_VERSION >= PMSM_FOC_XMC_LIB_PATCH_VERSION)))
#error "PMSM_FOC requires XMC Peripheral Library v2.0.0 or higher"
#endif

#define PMSM_FOC_ADCCAL_COUNT              (16U)        /**< Use for amplifier bias calibration */
#define PMSM_FOC_AMPLITUDE_SCALE           (10U)        /**< Scale for potentiometer value for input speed calculation */
#define PMSM_FOC_MAX_OVER_CURRENT_COUNTER  (100U)       /**< Maximum count used for over current detection */
#define PMSM_FOC_POWER215                  (32767)      /**< 2^15 - 1 */
#define PMSM_FOC_POWER_16                  (65535)      /**< 2^16 - 1 */
#define PMSM_FOC_Q15                       (15U)        /**< Represents Q15*/
#define PMSM_FOC_POWER_8                   (256)        /**< 2^8 */
#define PMSM_FOC_ADAPTIVE_CAPTURE          (14U)        /**< count used for adaptive pattern capture*/
#define PMSM_FOC_MAXOPENLOOP_REVOLUTION    (20U)        /**< maximum open loop revolution*/
#define PMSM_FOC_MAX_ADCCHANNELS           (7U)         /**< Maximum number of adc channels*/
#if (UC_FAMILY == XMC4)
#define PMSM_FOC_MAX_ADCQUEUE              (4U)         /**< Maximum number of adc queue*/
#endif
#if (UC_SERIES == XMC13 || UC_SERIES == XMC14)
#define PMSM_FOC_MAX_ADCQUEUE              (2U)         /**< Maximum number of adc queue*/
#endif
#define PMSM_FOC_ADCSCALE                  (8)          /**< Pot measurement scale*/
#define PMSM_FOC_ERROR_MASK                (0x3FU)      /**< Operational error mask for error*/
#define PMSM_FOC_SIXTY_DEGREE              (10922)      /**< Count for 60 degree*/
#define PMSM_FOC_NINTYDEGREE               (16384U)     /**< Count for 90 degree*/
#define PMSM_FOC_360DEGREE                 (65535U)     /**< Count for 360 degree*/
#define PMSM_FOC_ANGLE_SPEED_SCALE         (7650U)      /**< scale to convert angle to speed*/
#define PMSM_FOC_MICROSEC                  (1000000U)   /**< Microsecond scale*/
#define PMSM_FOC_MILLISEC                  (1000U)      /**< Millisecond scale*/
#define PMSM_FOC_POWER28                   (255)        /* 2^8 value used for calculation */
#define PMSM_FOC_2POW14                    (16383)      /* (2^14 - 1) used to limit Iq */
#define PMSM_FOC_2POW10                    (1024)       /* (2^10) used for field weakening calculation */
#define PMSM_FOC_NANO_TO_MICRO_SEC         (1000)       /* Used for converting Nanoseconds to Microseconds */
#define PMSM_FOC_TIME_FOCSTABLE            (2U)

#define PMSM_FOC_CORDIC_SHIFT              (14)         /* 8 ~ 16. Shift for CORDIC input / output registers,
                                                           whose [7:0] are 0x00. */

#define PMSM_FOC_SCALE_SQRT3                (10U)               /* For √3 scaling, used in Clarke Transform.*/
#define PMSM_FOC_SQRT3                      (1.732050807569F)   /* √3 */
#define PMSM_FOC_DIV_SQRT3                  (591U)              /* ((int16_t)((1/PMSM_FOC_SQRT3) * (1<<PMSM_FOC_SCALE_SQRT3))) */

#define PMSM_FOC_SCALE_DIV_3                (14U)               /* For 1/3 scaling.*/
#define PMSM_FOC_DIV_3                      (5461U)             /* ((int16_t)((1/3) * (1<<PMSM_FOC_SCALE_DIV_3)))*/

/*Macro use for APIs */

#define PMSM_FOC_API_PARAM_MIN_VALUE        (0U)               /** Minimum value of the parameter */
#define PMSM_FOC_API_PARAM_MAX_VALUE        (32767U)           /** Maximum value of the parameter in Q15 format */
#define PMSM_FOC_API_PI_MAX_VALUE           (65535U)           /** Maximum value of the PI controller parameters */
#define PMSM_FOC_CURRENT_MIN_VALUE          (-32768)           /** Minimum value of the current in Q15 format */
#define PMSM_FOC_CURRENT_MAX_VALUE          (32767U)           /** Maximum value of the current in Q15 format */
#define PMSM_FOC_INPUT_MIN_VALUE            (0U)               /** Minimum value for the MET input parameters */
#define PMSM_FOC_INPUT_MAX_VALUE            (512U)             /** Maximum value for the MET input parameters */
#define PMSM_FOC_DELAY_COUNT                (0x7FFFF)          /** Delay for power board stabilization after power on reset */

/** Macro to limit the value within the limits */
#define PMSM_FOC_MIN_MAX_LIMIT(Buffer,Limit1,Limit2) ((Buffer) > (Limit1)) ? (Limit1) : (((Buffer) < (Limit2))? (Limit2): (Buffer))

/*Acronyms: Direct (D) Inverted (I) Not changed (?)*/
#if !defined(CCU8V3) /* Defined for all devices except XMC1400 */
       #define PMSM_FOC_OUTPUTPATH_SET_OUT_ALL_DIRECT         	0x1E0014             /*ASE->?, Out0->D_ST1, Out1->D_ST1, Out2->D_ST2, Out3->D_ST2, */
       #define PMSM_FOC_OUTPUTPATH_SET_OUT_STD                	0x1E0000             /*ASE->?, Out0->D_ST1, Out1->I_ST1, Out2->D_ST2, Out3->I_ST2, */
#else /*The ST1/ST2 is in the set/clear process not changed: ST = ?*/
	   #define PMSM_FOC_OUTPUTPATH_SET_OUT_ALL_DIRECT           0xDCDC0U             /*ASE->?, Out0->D, Out1->D, Out2->D, Out3->D, */
       #define PMSM_FOC_OUTPUTPATH_SET_OUT_STD                  0xCCCC0U             /*ASE->?, Out0->D, Out1->I, Out2->D, Out3->I, */
#endif


/**********************************************************************************************************************
 * ENUMS
 **********************************************************************************************************************/
/**
 * @ingroup PMSM_FOC_enumerations
 * @{
 */

/**
 * State of the APP
 */
typedef enum PMSM_FOC_STATE
{

  PMSM_FOC_STATE_UNINITIALISED,    /**< default state after power on reset */
  PMSM_FOC_STATE_INITIALISED       /**< APP state after INITIALIZED state*/

} PMSM_FOC_STATE_t;

/**
 * Status of the APP which can be occurred during initialization.
 */
typedef enum PMSM_FOC_STATUS
{

  PMSM_FOC_STATUS_SUCCESS,               /*!< APP status success*/
  PMSM_FOC_STATUS_FAILURE,               /*!< APP status failure*/
  PMSM_FOC_STATUS_INVALID_PARAM,         /*!< Return status for invalid parameters*/
  PMSM_FOC_STATUS_PERMISSION_DENIED      /*!< Return status for operation not allowed*/

} PMSM_FOC_STATUS_t;

/**
 * Queue request source availability
 */
typedef enum PMSM_FOC_QUEUE_ACTIVE
{

  PMSM_FOC_QUEUE_ACTIVE,                /*!< Queue request source is active*/
  PMSM_FOC_QUEUE_INACTIVE               /*!< Queue request source is not active*/

} PMSM_FOC_QUEUE_ACTIVE_t;

/**
 * Error codes of the APP which can occur during run-time.
 */
typedef enum PMSM_FOC_ERROR_ID
{

  PMSM_FOC_EID_INIT_FAILED,          /**< Initialization failed*/
  PMSM_FOC_EID_TRAP_ERROR,           /**< Trap condition is detected */
  PMSM_FOC_EID_UNDER_VOLT,           /**< Under voltage is detected */
  PMSM_FOC_EID_OVER_VOLT             /**< Over voltage is detected */

}PMSM_FOC_EID_t;


/**
 * Enumerates the states of the motor state machine
 */
typedef enum PMSM_FOC_MOTOR_CONTROL_STATE_MACHINE
{

  PMSM_FOC_MSM_STOP,                /**< Default state */
  PMSM_FOC_MSM_INIT_INVERTER,       /**< Inverter initialized */
  PMSM_FOC_MSM_START_UP,            /**< Start up routine */
  PMSM_FOC_MSM_LOW_SPEED,           /**< Motor operation in low speed */
  PMSM_FOC_MSM_TRANSITION,          /**< Switching to normal operation */
  PMSM_FOC_MSM_NORMAL_OPERATION,    /**< Motor running in normal condition */
  PMSM_FOC_MSM_RESERVE_1,           /**< Reserved */
  PMSM_FOC_MSM_RESERVE_2,           /**< Reserved */
  PMSM_FOC_MSM_RESERVE_3,           /**< Reserved */
  PMSM_FOC_MSM_BOOTSTRAP,           /**< Bootstrap */
  PMSM_FOC_MSM_PRE_POSITIONING,     /**< Startup alignment */
  PMSM_FOC_MSM_VF_RAMP_UP,          /**< Open loop V/F ramp up */
  PMSM_FOC_MSM_VF_OPEN_LOOP,        /**< Steady state V/F open loop */
  PMSM_FOC_MSM_IDLE,                /**< Motor in passive state when speed input is less than 10% of no load speed */
  PMSM_FOC_MSM_RESERVE_4,           /**< Reserved */
  PMSM_FOC_MSM_ERROR                /**< Error */

} PMSM_FOC_MSM_t;

/**
 * This enumerates bootstrap status
 */
typedef enum PMSM_FOC_BOOTSTRAP_STATUS
{

  PMSM_FOC_BOOTSTRAP_ACTIVE,     /**< Bootstrap is active */
  PMSM_FOC_BOOTSTRAP_COMPLETED   /**< Bootstrap is completed */

} PMSM_FOC_BOOTSTRAP_STATUS_t;

/**
 * This enumerates the motor direction
 */
typedef enum PMSM_FOC_MOTOR_DIRECTION
{

  PMSM_FOC_POSITIVE_DIR          = 1,     /**< forward direction */
  PMSM_FOC_NEGATIVE_DIR      = -1      /**< reverse direction */

}PMSM_FOC_MD_t;

/**
 * This enumerates the hall sensor control feedback
 */
typedef enum PMSM_FOC_FEEDBACK
{
  PMSM_FOC_3_HALL,              /**< 3 hall sensors*/
  PMSM_FOC_SENSORLESS           /**< No sensored feedback. Position and angle estimation from flux */

}PMSM_FOC_FEEDBACK_t;

/**
 * This enumerates the current measurement types
 */
typedef enum PMSM_FOC_CURTYPE
{
  PMSM_FOC_DCLINK,            /**< DC link current - single shunt current measurement*/
  PMSM_FOC_3PHASE,            /**< 3 phase current*/
  PMSM_FOC_2PHASE             /**< 2 phase current*/

}PMSM_FOC_CURTYPE_t;

/**
 * This enumerates the ADC queue entry from the measurement tab in GUI
 */
typedef enum PMSM_FOC_GUI_QUEUE_ENTRY
{
  PMSM_FOC_PHASE_U_CURRENT,   /**< Phase U current measurement*/
  PMSM_FOC_PHASE_V_CURRENT,   /**< Phase V current measurement*/
  PMSM_FOC_PHASE_W_CURRENT,   /**< Phase W current measurement*/
  PMSM_FOC_DCLINK_CURRENT,    /**< DC link current measurement*/
  PMSM_FOC_DCLINK_VOLTAGE,    /**< DC link voltage measurement*/
  PMSM_FOC_ANALOG_INPUT,      /**< Analog pot input measurement*/
  PMSM_FOC_USER_DEFINED       /**< User defined measurement*/

}PMSM_FOC_GUI_QUEUE_ENTRY_t;

/**
 * This enumerates the motor control state flag
 */
typedef enum PMSM_FOC_FLAG
{
  PMSM_FOC_FLAG_TRANSITION,    /**< Motor is in transition mode */
  PMSM_FOC_FLAG_STABLE         /**< Motor reached to steady state*/
}PMSM_FOC_FLAG_t;


/**
 * @}
 */
/**********************************************************************************************************************
* DATA STRUCTURES
**********************************************************************************************************************/
/**
 * @ingroup PMSM_FOC_datastructures
 * @{
 */

#if (PMSM_FOC_IS_ADC_AVAILABLE == 1U)
#if (UC_SERIES == XMC13 || UC_SERIES == XMC14)
/**
 * This structure hold all the parameters related to adc configuration.
 */
typedef struct PMSM_FOC_ADCConfig
{

  ADC_QUEUE_ENTRY_t            *const queue_entry_hdlarray[7][2];       /*!< The pointer to queue entry structure*/
  ADC_QUEUE_t                  *const qapp_handlearray[2];              /*!< The pointer to queue APP handler*/
  XMC_VADC_RESULT_CONFIG_t     *const vadc_reshandle_array[7];          /*!< The pointer to result configuration structure*/
  XMC_VADC_CHANNEL_CONFIG_t    *const vadc_chhandle_array[7];           /*!< The pointer to channel configuration structure*/
  XMC_VADC_GROUP_t             *const vadc_group_pointerarray[7];       /*!< The pointer to group pointer structure*/
  uint8_t                             queue_active[2];                  /*!< List of active queues*/
  uint8_t                             channel_num_array[7];             /*!< List of channel number*/
  uint8_t                             result_num_array[7];              /*!< List of result register numbers*/

} PMSM_FOC_ADCConfig_t;
#endif

#if (UC_FAMILY == XMC4)
/**
 * This structure hold all the parameters related to adc configuration.
 */
typedef struct PMSM_FOC_ADCConfig
{

  ADC_QUEUE_ENTRY_t            *const queue_entry_hdlarray[7][4];       /*!< The pointer to queue entry structure*/
  ADC_QUEUE_t                  *const qapp_handlearray[4];              /*!< The pointer to queue APP handler*/
  XMC_VADC_RESULT_CONFIG_t     *const vadc_reshandle_array[7];          /*!< The pointer to result configuration structure*/
  XMC_VADC_CHANNEL_CONFIG_t    *const vadc_chhandle_array[7];           /*!< The pointer to channel configuration structure*/
  XMC_VADC_GROUP_t             *const vadc_group_pointerarray[7];       /*!< The pointer to group pointer structure*/
  uint8_t                             queue_active[4];                  /*!< List of active queues*/
  uint8_t                             channel_num_array[7];             /*!< List of channel number*/
  uint8_t                             result_num_array[7];              /*!< List of result register numbers*/

} PMSM_FOC_ADCConfig_t;
#endif
#endif

/**
 * This structure holds the ISR configuration parameters.
 */
typedef struct PMSM_FOC_ISRHandle
{
#if(UC_SERIES == XMC14)
  const XMC_SCU_IRQCTRL_t irqctrl;  /**< selects the interrupt source for a NVIC interrupt node*/
#endif
  uint8_t           node_id;      /*!< interrupt node id*/
  uint8_t           priority;     /*!< interrupt priority*/
  uint8_t           sub_priority; /*!< interrupt sub priority*/
}PMSM_FOC_ISRHandle_t;

/**
 * Structure to hold V/F startup parameters for sensor-less mode
 */
typedef struct PMSM_FOC_VF
{
  uint32_t  vf_constant;                 /*!< Configured V/f constant*/
  uint32_t  vf_offset;                   /*!< Configured V/f offset*/
  int32_t   vf_threshold_speed;          /*!< V/F ramp end speed in target form */
  uint32_t  vf_time;                     /*!< Time to wait in the V/F ramp up for motor to stabilize */
}PMSM_FOC_VF_t;

/**
 * Structure to save the PI parameters
 */
typedef struct PMSM_FOC_PI_Coefs
{
    int32_t error;                  /*!< PI error signal (reference value � feedback value), error[k] */
    int32_t Uk;                     /*!< PI output U[k] */
    int32_t Ik;                     /*!< Integral result I[k] */
    uint16_t Kp;                    /*!< Proportional gain Kp */
    uint16_t Ki;                    /*!< Integral gain Ki */
    int16_t Scale_KpKi;             /*!< Scale-up Kp and Ki by 2^Scale_KpKi */
    int32_t Ik_limit_min;           /*!< Minimum value of the integral buffer */
    int32_t Ik_limit_max;           /*!< Maximum value of the integral buffer */
    int32_t Uk_limit_min;           /*!< Minimum value of the PI output */
    int32_t Uk_limit_max;           /*!< Maximum value of the PI output */
	uint16_t Uk_limit_status;		/*!< Anti-Windup Flag */
}PMSM_FOC_PI_Coefs_t;

/**
 * Inputs to the FOC library
 */
typedef struct PMSM_FOC_Input
{
  uint16_t Phase_L;                 /*!< Motor inductance per phase */
  uint16_t Phase_R;                 /*!< Motor resistance per phase  */
  uint16_t Phase_L_Scale;           /*!< Scaling for inductance. Real inductance in SW = Phase_L/(2Phase_L_Scale)*/
  uint16_t CCU8_Period;             /*!< Period register value of the CCU8 based on the PWM frequency */
  uint16_t Res_Inc;                 /*!< Resolution increase, SW uses (16+Res_Inc) bit to represent 360°. This depends on max speed of the motor
                                         and PWM frequency */
  uint16_t LPF_N_BEMF;              /*!< LPF factor for BEMF */
  uint16_t LPF_N_Speed;             /*!< LPF factor for motor speed */
  uint32_t Threshold;               /*!< Runtime variable to hold the BEMF threshold for transition to FOC. */
  uint16_t Threshold_LOW;           /*!< Low BEMF threshold, for transitions to FOC */
  uint16_t Threshold_HIGH;          /*!< High BEMF threshold, for transitions to FOC */
  uint8_t Flag_State;               /*!< 0: Motor to run in FOC. 1: Always in transition state */
  int32_t BEMF1;                    /*!< BEMF of sensorless estimator */
  uint32_t BEMF2;                   /*!< BEMF of sensorless estimator */
  uint32_t Vref32;                  /*!< SVM voltage magnitude of last PWM cycle.  */
  int32_t Vref_AngleQ31;            /*!< SVM voltage angle of last PWM cycle.  */
  int32_t I_U;                      /*!< Phase U current in 1Q15 format */
  int32_t I_V;                      /*!< Phase V current in 1Q15 format */
  int32_t I_W;                      /*!< Phase W current in 1Q15 format */
  int32_t Ref_Speed;                /*!< Motor reference speed for Speed PI controller.  */
  int32_t Vq_Flag;                  /*!< 0: FOC Vq from Iq PI controller. 1: Vq from external */
  int32_t Vq;                       /*!< Vq input from external interface*/
  int32_t Ref_Id;                   /*!< Id reference for Id PI controller */
  int32_t Ref_Iq;                   /*!< Iq reference for Iq PI controller. This will have effect only when torque control mode is enabled */
  uint8_t Iq_PI_Flag;              /*!< 0: Reference of Iq PI controller from speed PI output
                                         1: Reference of Iq PI controller = Ref_Iq */

  int32_t RotorAngleQ31;           /*!< Rotor angle in 1Q31 format */
  int32_t RotorSpeed_In;           /*!< Motor speed */
  int32_t ACIM_Flag;               /*!< Not used for PMSM*/
  uint16_t Slip_Ratio;               /*!< Not used for PMSM*/
  uint16_t Slip_Scale;               /*!< Not used for PMSM*/
  int32_t Slip_Speed_Max;                /*!< Not used for PMSM*/
  int32_t Ref_Id_Min;               /*!< Not used for PMSM*/
  int32_t Ref_Id_Max;               /*!< Not used for PMSM*/
  uint16_t Ref_Id_Shift;               /*!< Not used for PMSM*/
  uint16_t Previous_SVM_SectorNo;   /*!< SVM sector number of previous cycle */
  uint8_t Flag_3or2_ADC;            /*!< Flag to indicate 3 or 2 shunt ADC current measurement */
}PMSM_FOC_Input_t;


/**
 * Outputs from FOC
 */
typedef struct PMSM_FOC_Output
{
  int32_t I_Alpha_1Q31;          /*!< Current I_alpha - output of clarke transform*/
  int32_t I_Beta_1Q31;           /*!< Current I_beta - output of clarke transform*/
  int32_t I_d;                   /*!< Current I_d - output of park transform*/
  int32_t I_q;                   /*!< Current I_q - output of park transform*/
  int32_t Speed_by_Estimator;    /*!< Speed output of the sensorless estimator */
  int32_t Rotor_PositionQ31;     /*!< Angle output of the sensorless estimator */
}PMSM_FOC_Output_t;


/**
 * This structure holds the values of PT1 filter parameters.
 */
typedef struct PMSM_FOC_PT1Handle
{
  /**
   * Filter constant
   */
  int32_t  z1;
  /**
   * Filter constant
   */
  int32_t  z2;
  /**
   * Maximum limit of PT1 buffer
   */
  const int32_t  y_max;
  /**
   * Minimum limit of PT1 buffer
   */
  const int32_t  y_min;
  /**
   * This is the integral buffer of pt1 filter
   */
  int32_t  pt1_buf;
  /**
   * This is PT1 filter output.
   */
  int32_t  pt1_out_val;

} PMSM_FOC_PT1Handle_t;

/**
 * This structure holds the configurable parameters of this APP.
 * These parameters don't change at run time.
 */
typedef struct PMSM_FOC_Config
{
  uint32_t          voltage_adc_scale;            /*!< VADC scaling for DC link to scale the measured
                                                                ADC result value to target form*/
  uint32_t          pot_scale;                    /*!< Scale to convert pot value to target speed */
  uint32_t          speed_scale;                  /*!< Scale to convert speed in RPM to target value */
  uint32_t          inv_speed_scale;              /*!< Scale to convert target speed to speed in RPM */
  uint32_t          current_scale;               /*!< Scale to convert current in mA to target value */
  uint32_t          inv_current_scale;           /*!< Scale to convert target current to current in mA */
  uint32_t          resistance_scale;             /*!< Scale to convert phase resistance in mOhms to target value */
  uint32_t          inductance_scale;             /*!< Scale to convert phase inductance in uHenry to target value */
  uint32_t          config_vf_rampup_rate;       /*!< V/F Ramp up rate as configured in GUI */
  uint32_t          config_ramp_up_rate;          /*!< Ramp up rate as configured in GUI */
  uint32_t          config_ramp_down_rate;        /*!< Ramp down rate as configured in GUI */
  uint32_t          threshold_time_vp;            /*!< Voltage protection time */
  int32_t           speed_low_limit;              /*!< Low limit of the speed - 10% of the no load speed */
  int32_t           speed_openloop_max_limit;     /*!< Open loop max limit as configured in GUI*/
  int32_t           speed_openloop_min_limit;    /*!< Open loop limit  - 1% of the no load speed */
  uint16_t          current_amplifier_offset;     /*!< Configured current amplifier offset value */
  uint16_t          bootstrap_time;               /*!< Configured boot strap time*/
  uint16_t          max_dclink_voltage;           /*!< Maximum DC link voltage above which over-voltage is detected */
  uint16_t          min_dclink_voltage;           /*!< Minimum DC link voltage below which under-voltage is detected */
  uint8_t           phase_current_measurement;    /*!< Configured type of current measurement*/
  uint8_t           pole_pair;                    /*!< Configured number of pole pairs*/
  uint8_t           fcl_divider;                  /*!< FCL divider value*/
  /**
   * For all the variable (prefix with enable) is enabled if value is 1.
   * 0 - Disabled
   * 1 - Enabled
   */
  uint32_t          enable_speed_control        :1;     /*!< Enable/Disable speed control block */
  uint32_t          enable_biasvoltage          :1;     /*!< Enable/Disable amplifier bias voltage calibration */
  uint32_t          enable_voltage_compensation :1;     /*!< Enable/Disable voltage compensation */
  uint32_t          enable_pot_measurement      :1;     /*!< Enable/Disable speed measurement via analog input. */
  uint32_t          enable_vfstartup            :1;     /*!< Enable/Disable V/F startup for sensorless mode */
  uint32_t          enable_over_under_voltage   :1;     /*!< Enable/Disable over/under voltage protection */
  uint32_t          enable_vd_vq_decoupling     :1;     /*!< Enable/Disable vd-vq decoupling for IPMSM */
  uint32_t          enable_direct_foc_startup   :1;     /*!< Enable/Disable startup technique of direct FOC */
  uint32_t          enable_transition           :1;     /*!< Enable/Disable smooth transition from V/F to FOC */
  uint32_t          enable_vf_only              :1;     /*!< Enable/Disable startup technique of always in V/F open loop */
} PMSM_FOC_Config_t;


/**
 * This structure holds the run time parameters and address of
 * sub structures associated with this APP.
 */
typedef struct PMSM_FOC
{
  const PMSM_FOC_Config_t       *const  foc_config_ptr;          /*!< Constant pointer to constant PMSM_FOC config handle */
  PWM_SVM_t                     *const  pwm_svm_ptr;             /*!< Constant pointer to PWM_CCU8_SVM APP handle */
  PMSM_FOC_ISRHandle_t          *const  fcl_config_ptr;          /*!< Constant pointer to Fast control loop(FCL) ISR handler */
  PMSM_FOC_VF_t                 *const  vf_startup_ptr;          /*!< Constant pointer to v/f startup parameters */
  PMSM_FOC_PT1Handle_t          *const  voltcomp_filter_ptr;     /*!< Pointer to PT1 filter structure. Used for voltage compensation. */
  PMSM_FOC_ADCConfig_t          *const  adc_config_ptr;          /*!< Constant pointer to ADC configuration structure of PMSM_FOC APP*/

  PMSM_FOC_PI_Coefs_t           *const  PI_Speed;                /*!< Pointer to speed PI structure */
  PMSM_FOC_PI_Coefs_t           *const  PI_Torque;               /*!< Pointer to torque PI structure */
  PMSM_FOC_PI_Coefs_t           *const  PI_Flux;                 /*!< Pointer to flux PI structure */
  PMSM_FOC_PI_Coefs_t           *const  PI_PLL;                  /*!< Pointer to sensorless estimator PI structure */
  PMSM_FOC_Input_t              *const  FOCInput;                /*!< Pointer to input parameter structure of the FOC library */
  PMSM_FOC_Output_t             *const  FOCOutput;               /*!< Pointer to output parameter structure of the FOC library */

  PMSM_FOC_MSM_t                msm_state;                      /*!< Current state of the motor state machine */

  int32_t                      *speed_set_ptr;                  /*!< Holds the address of speed source variable.
                                                                      configured user speed reference */
  int32_t                       user_speed_set;                 /*!< Configured speed end value*/
  int32_t                       speed_set;                      /*!< Instantaneous speed value */
  uint32_t                      operational_error;              /*!< Each bit represents error status \ref PMSM_FOC_CTRL_EID_t*/
  uint32_t                      bootstrap_index;                /*!< Index to keep track of the bootstrap time */
  uint32_t                      bootstrap_count;                /*!< Bootstrap time in target form */
  uint32_t                      volt_protect_counter;           /*!< Voltage protection counter to count the threshold time */
  uint32_t                      pwm_frequency;                  /*!< PWM frequency in Hz */
  int32_t                       motor_speed;                    /*!< Actual speed of the motor - calculated from sensorless estimator */
  uint32_t                      angle;                          /*!< Motor angle to be given to SVM  in 24-bit format*/
  uint32_t                      amplitude;                      /*!< Amplitude given to SVM in 14-bit format*/
  uint32_t                      amplitude_max;                  /*!< Configured maximum voltage limit */

  uint32_t                      alignment_counter;              /*!< Counter to count the alignment time */
  uint32_t                      alignment_time;                 /*!< Configured alignment time */
  uint32_t                      alignment_volt;                 /*!< Configured alignment voltage to be applied during the alignment phase */
  uint32_t                      alignment_step;                 /*!< step size */
  uint32_t                      met_stable_time;                /*!< Time to stabilize the control in transition mode */

  uint32_t                      ramp_counter;                   /*!< Counter used in ramp-up and ramp-down phase */
  uint32_t                      vf_ramp_up_rate;                /*!< Run-time v/f ramp up rate */
  uint32_t                      ramp_up_rate;                   /*!< Run-time ramp-up rate */
  uint32_t                      ramp_down_rate;                 /*!< Run-time ramp-down rate */
  uint32_t                      ramp_s_ratio;                   /*!< Ratio by which ramp-up/ramp-down rate is adjusted in S-curve */

  uint32_t                      vref32_store;                   /*!< Amplitude of the last PWM cycle */
  uint32_t                      vref32;                         /*!< Amplitude of the current PWM cycle */
  int32_t                       vref_angle32_store;             /*!< Angle of the last PWM cycle */
  int32_t                       vref_angle32;                   /*!< Angle of the current PWM cycle */
  int32_t                       start_speed;                     /*!< start speed in target form */
  uint32_t                      counter;                        /*!< run-time counter */
  PMSM_FOC_ISRHandle_t  *const  trap_config_ptr;                /*!< Constant pointer to trap and phase V one match ISR handler */
  uint16_t                      dclink_voltage;                 /*!< Measured dc link voltage */
  uint16_t                      specified_volt;                 /*!< Specified DClink voltage in target form */
  uint16_t                      amplifier_offset;               /*!< Current amplifier offset value*/
  uint16_t                      fcl_time;                       /*!< fast control loop time in us */
  uint16_t                      threshold_adc_2shunt;           /*!< Threshold time to switch current sensing from 3 shunt to 2 shunt */
  int8_t                        motor_direction;                /*!< Configured motor direction. Can be changed in run time.*/
  uint8_t                       feedback_type;                  /*!< sensor feedback type  sensorless*/
  uint8_t                       mode_flag;                      /*!< Motor stability indicator flag */
  uint8_t                       fcl_div_value;                  /*!< FCL divider value count to be incremented run time */
  uint8_t                       state;                          /*!< This is the APP state*/
  uint8_t                       ph_v_group;                     /*!< ADC measurement index for phase V.
                                                                 In anti-clockwise direction, phase V and phase W are interchanged*/
  uint8_t                       ph_w_group;                    /*!< ADC measurement index for phase W.
                                                                 In anti-clockwise direction, phase V and phase W are interchanged*/

} PMSM_FOC_t;

/**
 * @}
 */

#ifdef __cplusplus
extern "C" {
#endif
/**
 * @ingroup PMSM_FOC_apidoc
 * @{
 */
/***********************************************************************************************************************
 * API Prototypes
 **********************************************************************************************************************/
/**
 * @brief Get PMSM_FOC APP version
 * @return DAVE_APP_VERSION_t APP version information (major, minor and patch number)
 *
 * \par<b>Description: </b><br>
 * The function can be used to check application software compatibility with a
 * specific version of the APP.
 *
 * Example Usage:
 *
 * @code
 * #include "DAVE.h"
 *
 * int main(void) 
 * {
 *   DAVE_STATUS_t init_status;
 *   DAVE_APP_VERSION_t version;
 *
 *   // PMSM_FOC_Init() is called from DAVE_Init().
 *   init_status = DAVE_Init();
 *
 *   version = PMSM_FOC_GetAppVersion();
 *
 *   // More code here
 *
 *   while(1) {
 *
 *   }
 *   return (0);
 * }
 * @endcode<BR>
 */
DAVE_APP_VERSION_t PMSM_FOC_GetAppVersion(void);

/**
* @brief Initialize PMSM_FOC APP and its dependent APPs.
* This is called by DAVE_Init.
* @param HandlePtr pointer to an object of PMSM_FOC module.\n
* @retval PMSM_FOC_STATUS_t status of operation \n
* PMSM_FOC_STATUS_SUCCESS if initialization is successful \n
* PMSM_FOC_STATUS_FAILURE if dependent APP initialization failed
* <BR>
*
 * \par<b>Description: </b><br>
 * Initializes dependent APPs - PWM_SVM and ADC_QUEUE
 * and enables consumed NVIC nodes.
 * This is the first API which application must invoke to use PMSM_FOC APP.
 *
 * Example Usage:
 *
 * @code
 * #include "DAVE.h"
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *
 *   // Initialize PMSM_FOC APP
 *   // PMSM_FOC_Init() is called within DAVE_Init().
 *   init_status = DAVE_Init();
 *
 *   // More code here
 *   while(1)
 *   {
 *
 *   }
 *   return (1);
 * }
 * @endcode<BR>
*/
PMSM_FOC_STATUS_t PMSM_FOC_Init(PMSM_FOC_t* const HandlePtr);

/**
 * @brief Starts the motor with configured parameters
 * @param HandlePtr pointer to an object of PMSM_FOC module.
 * @retval void
 * <BR>
 *
 * \par<b>Description: </b><br>
 * This API need to be invoked to start the motor.
 * This starts the PWM_SVM and starts the control loop execution.
 * Motor does not start if motor is in PMSM_FOC_MSM_ERROR state unless error is cleared using PMSM_FOC_ClearErrorState API.
 * It changes the state of motor state machine(MSM) to PMSM_FOC_MSM_INIT_INVERTER.
 *
 * Example Usage:
 *
 * @code
 * #include "DAVE.h"
 *
 * int main (void)
 * {
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *   PMSM_FOC_MotorStart(&PMSM_FOC_0);
 * 
 *   while(1);
 *   return 1;
 * }
 * @endcode
 */
void PMSM_FOC_MotorStart(PMSM_FOC_t * const HandlePtr);

/**
 * @brief Stops the motor by switching off the PWM signals.
 * @param HandlePtr pointer to an object of PMSM_FOC module.
 * @retval void
 * <BR>
 * \par<b>Description: </b><br>
 * This API need to be invoked to stop the motor.
 * It changes the state of motor state machine(MSM) to PMSM_FOC_MSM_STOP.
 *
 * Example Usage:
 *
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *  DAVE_STATUS_t init_status;
 *  init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *  PMSM_FOC_MotorStart(&PMSM_FOC_0);
 *  //delay
 *  PMSM_FOC_MotorStop(&PMSM_FOC_0);
 *  while(1);
 *  return 1;
 * }
 * @endcode
 */
void PMSM_FOC_MotorStop(PMSM_FOC_t * const HandlePtr);

/**
 * @brief This API clears all the operational errors.
 * @param HandlePtr pointer to an object of PMSM_FOC module.
 * @return void
 * <BR>
 *
 * \par<b>Description: </b><br>
 * This API clears the error status. This is required to call before starting the motor to clear if there is any existing error.<br>
 * e.g.: if over voltage error occurs, motor gets stopped. In order to start
 * the motor again, error state has to be cleared. This API will clear over voltage error.<br>
 * <br>
 *  Example Usage:
 *
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *   PMSM_FOC_ClearErrorState(&PMSM_FOC_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void PMSM_FOC_ClearErrorState(PMSM_FOC_t*const HandlePtr);

/**
 * @brief This function returns the actual motor speed.
 * @param HandlePtr pointer to an object of PMSM_FOC module.
 * @return int32_t Actual motor speed in rpm
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Invoke this API at any point of time to get the actual motor speed in rpm.\n
 * Speed value is always +ve.
 *
 * <BR>
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *   int32_t motor_speed;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *   motor_speed = PMSM_FOC_GetMotorSpeed(&PMSM_FOC_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
int32_t PMSM_FOC_GetMotorSpeed(PMSM_FOC_t *const HandlePtr);

/**
 * @brief Update motor end speed set(user_speed_set).
 * @param HandlePtr pointer to an object of PMSM_FOC module
 * @param speed int32_t input speed in rpm
 * @retval PMSM_FOC_STATUS_t status of operation \n
 * PMSM_FOC_STATUS_SUCCESS if execution successful \n
 * PMSM_FOC_STATUS_INVALID_PARAM if input not within range\n
 *
 * <BR>
 * \par<b>Description: </b><br>
 * This API can be use to change the motor speed at run time.
  * <BR>
 * \par<b>Note:</b><br>
 * Invoke this API if POT is disabled.<br>
 * <BR>
 *
 * \par<b>Related APIs:</b><BR>
 * PMSM_FOC_SetMotorDirection()
 *<BR>
 *
 * Example Usage:
 *
 * <BR>
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *   uint32_t delay_count;
 *   uint32_t speed = 2000;
 *
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *
 *   //set end speed
 *   PMSM_FOC_SetEndSpeed(&PMSM_FOC_0, speed);
 *
 *   //start the motor
 *   PMSM_FOC_MotorStart(&PMSM_FOC_0);
 *
 *   //delay
 *   for(delay_count = 0;delay_count <= 0x7FFFFFF;delay_count++);

 *   while(1U)
 *   {
 *
 *   }
 *   return 0;
 * }
 * @endcode
 */
PMSM_FOC_STATUS_t PMSM_FOC_SetEndSpeed(PMSM_FOC_t*const HandlePtr, uint32_t speed);

/**
 * @brief This function returns the motor speed set value.
 * @param HandlePtr pointer to an object of PMSM_FOC module
 * @return int32_t speed set value of motor in rpm
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Retrieves end user speed set value at which motor will run.
 *
 * <BR>
 * Example Usage:
 * <BR>
 *
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   int32_t speed;
 *
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *
 *   PMSM_FOC_MotorStart(&PMSM_FOC_0);
 *   //delay
 *   speed = PMSM_FOC_GetEndSpeed(&PMSM_FOC_0);
 *
 *   while(1U)
 *   {
 *
 *   }
 * }
 * @endcode<BR>
 */
int32_t PMSM_FOC_GetEndSpeed(PMSM_FOC_t*const HandlePtr);

/**
 * @brief This function set proportional gain for speed control.
 * @param HandlePtr pointer to an object of PMSM_FOC module
 * @param kp proportional gain for speed control,its range is limited to 0 to 65535.
 * @retval PMSM_FOC_STATUS_t status of operation \n
 * PMSM_FOC_STATUS_SUCCESS if execution successful \n
 * PMSM_FOC_STATUS_INVALID_PARAM if input not within range\n
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Invoke this API to update speed control proportional gain value at run time.<br>
 *
 * Example Usage:
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *   PMSM_FOC_STATUS_t status;
 *   DAVE_STATUS_t init_status;
 *   uint32_t kp = 100;
 *
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *   status = PMSM_FOC_SetSpeedProportionalGain(&PMSM_FOC_0, kp);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
PMSM_FOC_STATUS_t PMSM_FOC_SetSpeedProportionalGain(PMSM_FOC_t*const HandlePtr,uint32_t kp);

/**
 * @brief This function return the proportional gain value used for speed control.
 * @param HandlePtr pointer to an object of PMSM_FOC module
 * @return uint32_t proportional gain value used for speed control
 *
 * \par<b>Description: </b><br>
 * Invoke this API to get speed control proportional gain value at run time.<br>
 *<BR>
 * Example Usage:
 * <BR>
 *
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   uint32_t kp;
 *
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *
 *   kp = PMSM_FOC_GetSpeedProportionalGain(&PMSM_FOC_0);
 *
 *   while(1U)
 *   {
 *
 *   }
 * }
 * @endcode<BR>
 */
uint32_t PMSM_FOC_GetSpeedProportionalGain(PMSM_FOC_t*const HandlePtr);
/**
 * @brief This function set integral gain for speed control.
 * @param HandlePtr pointer to an object of PMSM_FOC module
 * @param ki uint16_t integral gain for speed control,its range is limited to 0 to 65535
 *
 * @retval PMSM_FOC_STATUS_t status of operation \n
 * PMSM_FOC_STATUS_SUCCESS if execution successful \n
 * PMSM_FOC_STATUS_INVALID_PARAM if input not within range\n
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Invoke this API to update speed control integral gain value at run time.<br>
 *
 * <BR>
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *   DAVE_STATUS_t init_status;
 *   PMSM_FOC_STATUS_t status;
 *   uint32_t ki = 10;
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *   status = PMSM_FOC_SetSpeedIntegralGain(&PMSM_FOC_0, ki);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
PMSM_FOC_STATUS_t PMSM_FOC_SetSpeedIntegralGain(PMSM_FOC_t*const HandlePtr,uint32_t ki);
/**
 * @brief This function return the integral gain value used for speed control.
 * @param HandlePtr pointer to an object of PMSM_FOC module
 * @return uint32_t integral gain value used for speed control
 *
 * \par<b>Description: </b><br>
 * Invoke this API to get speed control integral gain value at run time.<br>
 *
 * <BR>
 * Example Usage:
 * <BR>
 *
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   uint32_t ki;
 *
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *
 *   ki = PMSM_FOC_GetSpeedIntegralGain(&PMSM_FOC_0);
 *
 *   while(1U)
 *   {
 *
 *   }
 * }
 * @endcode<BR>
 */
uint32_t PMSM_FOC_GetSpeedIntegralGain(PMSM_FOC_t*const HandlePtr);

/**
 * @brief This function set proportional gain for flux control.
 * @param HandlePtr pointer to an object of PMSM_FOC module
 * @param kp proportional gain for flux control,its range is limited to 0 to 65535
 *
 * @retval PMSM_FOC_STATUS_t status of operation \n
 * PMSM_FOC_STATUS_SUCCESS if execution successful \n
 * PMSM_FOC_STATUS_INVALID_PARAM if input not within range\n
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Invoke this API to update flux control proportional gain value at run time.<br>
 *
 * Example Usage:
 *
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *   PMSM_FOC_STATUS_t status;
 *   DAVE_STATUS_t init_status;
 *   uint32_t kp = 100;
 *
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *
 *   status = PMSM_FOC_SetIdProportionalGain(&PMSM_FOC_0, kp);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
PMSM_FOC_STATUS_t PMSM_FOC_SetIdProportionalGain(PMSM_FOC_t*const HandlePtr,uint32_t kp);

/**
 * @brief This function return the proportional gain value used for flux control.
 * @param HandlePtr pointer to an object of PMSM_FOC module
 * @return uint32_t proportional gain value used for flux control,
 *
 * \par<b>Description: </b><br>
 * Invoke this API to get the flux control proportional gain value at run time.<br>
 *
 * <BR>
 * Example Usage:
 * <BR>
 *
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   uint32_t kp;
 *
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *
 *   kp = PMSM_FOC_GetIdProportionalGain(&PMSM_FOC_0);
 *
 *   while(1U)
 *   {
 *
 *   }
 * }
 * @endcode<BR>
 */
uint32_t PMSM_FOC_GetIdProportionalGain(PMSM_FOC_t*const HandlePtr);

/**
 * @brief This function set integral gain for flux control.
 * @param HandlePtr pointer to an object of PMSM_FOC module
 * @param ki integral gain for flux control,its range is limited to 0 to 65535
 *
 * @retval PMSM_FOC_STATUS_t status of operation \n
 * PMSM_FOC_STATUS_SUCCESS if execution successful \n
 * PMSM_FOC_STATUS_INVALID_PARAM if input not within range\n
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Invoke this API to update flux control integral gain value at run time.<br>
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *   DAVE_STATUS_t init_status;
 *   PMSM_FOC_STATUS_t status;
 *   uint32_t ki = 100;
 *
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *   status = PMSM_FOC_SetIdIntegralGain(&PMSM_FOC_0, ki);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
PMSM_FOC_STATUS_t PMSM_FOC_SetIdIntegralGain(PMSM_FOC_t*const HandlePtr,uint32_t ki);

/**
 * @brief This function return the integral gain used for flux control.
 * @param HandlePtr pointer to an object of PMSM_FOC module
 * @return uint32_t integral gain used for flux control
 *
 *
 * \par<b>Description: </b><br>
 * Invoke this API to get flux control integral gain value at run time.<br>
 *
 *<BR>
 * Example Usage:
 * <BR>
 *
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   uint32_t ki;
 *
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *
 *   ki = PMSM_FOC_GetIdIntegralGain(&PMSM_FOC_0);
 *
 *   while(1U)
 *   {
 *
 *   }
 * }
 * @endcode<BR>
 */
uint32_t PMSM_FOC_GetIdIntegralGain(PMSM_FOC_t*const HandlePtr);

/**
 * @brief This function set d-axis current reference for flux control to tune IPM type of BLDC motors /n
 * or to allow flux-weakening.
 * @param HandlePtr pointer to an object of PMSM_FOC module
 * @param current d-axis current reference in mA
 *
 * @retval PMSM_FOC_STATUS_t status of operation \n
 * PMSM_FOC_STATUS_SUCCESS if execution successful \n
 * PMSM_FOC_STATUS_INVALID_PARAM if input not within range\n
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Invoke this API to set flux reference at run time.<br>
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *   DAVE_STATUS_t init_status;
 *   PMSM_FOC_STATUS_t status;
 *   int32_t current = 10;
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *   status = PMSM_FOC_SetIdRef(&PMSM_FOC_0, current);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
PMSM_FOC_STATUS_t PMSM_FOC_SetIdRef(PMSM_FOC_t*const HandlePtr, int32_t current);

/**
 * @brief This function set Q-axis current reference for torque control mode.
 * @param HandlePtr pointer to an object of PMSM_FOC module
 * @param current Q-axis current reference in mA
 *
 * @retval PMSM_FOC_STATUS_t status of operation \n
 * PMSM_FOC_STATUS_SUCCESS if execution successful \n
 * PMSM_FOC_STATUS_INVALID_PARAM if input not within range\n
 * PMSM_FOC_STATUS_PERMISSION_DENIED if torque control is not enabled\n
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Invoke this API to set torque reference at run time in torque control mode<br>
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *   DAVE_STATUS_t init_status;
 *   PMSM_FOC_STATUS_t status;
 *   int32_t current = 10;
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *   status = PMSM_FOC_SetIqRef(&PMSM_FOC_0, current);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
PMSM_FOC_STATUS_t PMSM_FOC_SetIqRef(PMSM_FOC_t*const HandlePtr, int32_t current);

/**
 * @brief This function returns the Q-axis current reference.
 * @param HandlePtr pointer to an object of PMSM_FOC module.
 * @return int32_t q-axis current reference in mA
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Invoke this API at any point of time to get q-axis current in run time.\n
 * -ve current indicates negative torque value and +ve current indicates positive torque value.
 * <BR>
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *   int32_t Iq_ref;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *   Iq_ref = PMSM_FOC_GetIqRef(&PMSM_FOC_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
int32_t PMSM_FOC_GetIqRef(PMSM_FOC_t*const HandlePtr);

/**
 * @brief This function set proportional gain for torque control.
 * @param HandlePtr pointer to an object of PMSM_FOC module
 * @param kp proportional gain for torque control,its range is limited to 0 to 65535
 *
 * @retval PMSM_FOC_STATUS_t status of operation \n
 * PMSM_FOC_STATUS_SUCCESS if execution successful \n
 * PMSM_FOC_STATUS_INVALID_PARAM if input not within range\n
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Invoke this API to set torque control proportional gain at run time.<br>
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *   DAVE_STATUS_t init_status;
 *   PMSM_FOC_STATUS_t status;
 *   uint32_t kp = 100;
 *
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *   status = PMSM_FOC_SetIqProportionalGain(&PMSM_FOC_0, kp);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
PMSM_FOC_STATUS_t PMSM_FOC_SetIqProportionalGain(PMSM_FOC_t*const HandlePtr,uint32_t kp);
/**
 * @brief This function return the proportional gain used for torque control.
 * @param HandlePtr pointer to an object of PMSM_FOC module
 * @return uint32_t proportional gain used for torque control
 *
 * \par<b>Description: </b><br>
 * Invoke this API to get torque control proportional gain at run time.<br>
 *
 * <BR>
 * Example Usage:
 * <BR>
 *
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   uint32_t kp;
 *
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *
 *   kp = PMSM_FOC_GetIqProportionalGain(&PMSM_FOC_0);
 *
 *   while(1U)
 *   {
 *
 *   }
 * }
 * @endcode<BR>
 */
uint32_t PMSM_FOC_GetIqProportionalGain(PMSM_FOC_t*const HandlePtr);

/**
 * @brief This function set integral gain for torque control.
 * @param HandlePtr pointer to an object of PMSM_FOC module
 * @param ki integral gain for torque control,its range is limited to 0 to 65535
 *
 * @retval PMSM_FOC_STATUS_t status of operation \n
 * PMSM_FOC_STATUS_SUCCESS if execution successful \n
 * PMSM_FOC_STATUS_INVALID_PARAM if input not within range\n
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Invoke this API to update torque control integral gain at run time.<br>
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *   DAVE_STATUS_t init_status;
 *   PMSM_FOC_STATUS_t status;
 *   uint32_t ki = 100;
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *   status = PMSM_FOC_SetIqIntegralGain(&PMSM_FOC_0, ki);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
PMSM_FOC_STATUS_t PMSM_FOC_SetIqIntegralGain(PMSM_FOC_t*const HandlePtr,uint32_t ki);

/**
 * @brief This function return the integral gain used for torque control.
 * @param HandlePtr pointer to an object of PMSM_FOC module
 * @return uint32_t integral gain used for torque control
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Invoke this API to get torque control integral gain at run time.<br>
 *<BR>
 * Example Usage:
 * <BR>
 *
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   uint32_t ki;
 *
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *
 *   ki = PMSM_FOC_GetIqIntegralGain(&PMSM_FOC_0);
 *
 *   while(1U)
 *   {
 *
 *   }
 * }
 * @endcode<BR>
 */
uint32_t PMSM_FOC_GetIqIntegralGain(PMSM_FOC_t*const HandlePtr);

/**
 * @brief This function set proportional gain for PLL Estimator
 * @param HandlePtr pointer to an object of PMSM_FOC module
 * @param kp proportional gain for PLL Estimator,its range is limited to 0 to 65535
 * @retval PMSM_FOC_STATUS_t status of operation \n
 * PMSM_FOC_STATUS_SUCCESS if execution successful \n
 * PMSM_FOC_STATUS_INVALID_PARAM if input not within range\n
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Invoke this API to set PLL Estimator proportional gain at run time.<br>
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *   DAVE_STATUS_t init_status;
 *   PMSM_FOC_STATUS_t status;
 *   uint32_t kp = 100;
 *
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *   status = PMSM_FOC_SetEstimatorProportionalGain(&PMSM_FOC_0, kp);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
PMSM_FOC_STATUS_t PMSM_FOC_SetEstimatorProportionalGain(PMSM_FOC_t*const HandlePtr,uint32_t kp);

/**
 * @brief This function return the proportional gain of PLL Estimator.
 * @param HandlePtr pointer to an object of PMSM_FOC module
 * @return uint32_t proportional gain used for PLL Estimator
 *
 * \par<b>Description: </b><br>
 * Invoke this API to get PLL Estimator proportional gain at run time.<br>
 *
 * <BR>
 * Example Usage:
 * <BR>
 *
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   uint32_t kp;
 *
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *
 *   kp = PMSM_FOC_GetEstimatorProportionalGain(&PMSM_FOC_0);
 *
 *   while(1U)
 *   {
 *
 *   }
 * }
 * @endcode<BR>
 */
uint32_t PMSM_FOC_GetEstimatorProportionalGain(PMSM_FOC_t *const HandlePtr);

/**
 * @brief This function set Integral gain for PLL Estimator
 * @param HandlePtr pointer to an object of PMSM_FOC module
 * @param ki integral gain for PLL Estimator,its range is limited to 0 to 65535
 * @retval PMSM_FOC_STATUS_t status of operation \n
 * PMSM_FOC_STATUS_SUCCESS if execution successful \n
 * PMSM_FOC_STATUS_INVALID_PARAM if input not within range\n
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Invoke this API to set PLL Estimator integral gain at run time.<br>
 *
 * Example Usage:
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *   DAVE_STATUS_t init_status;
 *   PMSM_FOC_STATUS_t status;
 *   uint32_t ki = 100;
 *
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *   status = PMSM_FOC_SetEstimatorIntegralGain(&PMSM_FOC_0,ki);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
PMSM_FOC_STATUS_t PMSM_FOC_SetEstimatorIntegralGain(PMSM_FOC_t*const HandlePtr,uint32_t ki);

/**
 * @brief This function return the integral gain of PLL Estimator.
 * @param HandlePtr pointer to an object of PMSM_FOC module
 * @return uint32_t integral gain used for PLL Estimator
 *
 * \par<b>Description: </b><br>
 * Invoke this API to get PLL Estimator integral gain at run time.<br>
 *
 * <BR>
 * Example Usage:
 * <BR>
 *
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   uint32_t ki;
 *
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *
 *   ki = PMSM_FOC_GetEstimatorIntegralGain(&PMSM_FOC_0);
 *
 *   while(1U)
 *   {
 *
 *   }
 * }
 * @endcode<BR>
 */
uint32_t PMSM_FOC_GetEstimatorIntegralGain(PMSM_FOC_t*const HandlePtr);


/**
 * @brief Change the motor direction at run time.
 * @param HandlePtr pointer to an object of PMSM_FOC module
 * @param value direction of rotation
 * @retval PMSM_FOC_STATUS_t status of operation \n
 * PMSM_FOC_STATUS_SUCCESS if execution successful \n
 * PMSM_FOC_STATUS_INVALID_PARAM if input not within range\n
 * PMSM_FOC_STATUS_PERMISSION_DENIED if motor is not in PMSM_FOC_MSM_STOP state\n
 *
 * <BR>
 * \par<b>Description: </b><br>
 * This API can be use to change the motor direction at run time. But stop the motor before updating the
 * direction or else this API will have no effect.
 * <BR>
 *
 * Example Usage:
 *
 * <BR>
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *   PMSM_FOC_STATUS_t status;
 *   PMSM_FOC_MD_t direction = PMSM_FOC_POSITIVE_DIR;
 *
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *
 *   //set motor direction
 *   status = PMSM_FOC_SetMotorDirection(&PMSM_FOC_0, direction);
 *
 *   //start the motor
 *   if(status == PMSM_FOC_STATUS_SUCCESS)
 *   {
 *     PMSM_FOC_MotorStart(&PMSM_FOC_0);
 *   }
 *   while(1U)
 *   {
 *
 *   }
 *   return 0;
 * }
 * @endcode
 */
PMSM_FOC_STATUS_t PMSM_FOC_SetMotorDirection(PMSM_FOC_t*const HandlePtr, PMSM_FOC_MD_t value);

/**
 * @brief This function will return the direction of rotation.
 * @param HandlePtr pointer to an object of PMSM_FOC module
 * @return PMSM_FOC_MD_t motor direction
 *<BR>
 *
 * \par<b>Description: </b><br>
 * Invoke this API to get the direction of motor at run time.<br>
 *
 * Example Usage:
 * <BR>
 *
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   PMSM_FOC_MD_t dir;
 *
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *
 *   dir = (PMSM_FOC_MD_t)PMSM_FOC_GetMotorDirection(&PMSM_FOC_0);
 *
 *   while(1U)
 *   {
 *
 *   }
 * }
 * @endcode<BR>
 */
PMSM_FOC_MD_t PMSM_FOC_GetMotorDirection(PMSM_FOC_t*const HandlePtr);

/**
 * @brief This API sets the motor phase-phase resistance in milli-ohm.
 * @param HandlePtr pointer to an object of PMSM_FOC module
 * @param resistance int32_t stator phase-phase resistance in milli-ohm
 * @retval PMSM_FOC_STATUS_t status of operation \n
 * PMSM_FOC_STATUS_SUCCESS if execution successful \n
 * PMSM_FOC_STATUS_INVALID_PARAM if input is not within range\n
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Invoke this API to update stator phase-phase resistance at run time.
 * <br>
 *</BR>
 *
 * Example Usage:
 * <BR>
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   PMSM_FOC_STATUS_t status;
 *   DAVE_STATUS_t init_status;
 *   uint32_t resistance = 1000; //resistance in milli-ohm
 *
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *   status = PMSM_FOC_SetMotorResistance(&PMSM_FOC_0, resistance);
 *   while(1);
 *   return 0;
 * }
 * @endcode<BR>
 */
PMSM_FOC_STATUS_t PMSM_FOC_SetMotorResistance(PMSM_FOC_t*const HandlePtr, uint32_t resistance);

/**
 * @brief This API sets the motor phase-phase inductance in micro-Henry.
 * @param HandlePtr pointer to an object of PMSM_FOC module
 * @param inductance_d int32_t stator phase-phase d-axis inductance in micro-Henry
 * @param inductance_q int32_t stator phase-phase q-axis inductance in micro-Henry
 * @retval PMSM_FOC_STATUS_t status of operation \n
 * PMSM_FOC_STATUS_SUCCESS if execution successful \n
 * PMSM_FOC_STATUS_INVALID_PARAM if input is not within range\n
 * PMSM_FOC_STATUS_PERMISSION_DENIED if write access is not allowed\n
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Invoke this API to update d and q axis stator phase-phase resistance at run time.\n
 * Inductance L = (inductance_d + inductance_q) / 2 <br>
 *</BR>
 *
 * Example Usage:
 * <BR>
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   PMSM_FOC_STATUS_t status;
 *   DAVE_STATUS_t init_status;
 *   uint32_t inductance_d = 1500; //Ld in micro-Henry
 *   uint32_t inductance_q = 1800; //Lq in micro-Henry
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *   status = PMSM_FOC_SetMotorInductance(&PMSM_FOC_0, inductance_d,inductance_q);
 *   while(1);
 *   return 0;
 * }
 * @endcode<BR>
 */
PMSM_FOC_STATUS_t PMSM_FOC_SetMotorInductance(PMSM_FOC_t*const HandlePtr, uint32_t inductance_d, uint32_t inductance_q);

/**
 * @brief This function will return various states of motor operation encountered during starting, normal running, stopping \n
 * or in fault error condition.
 * @param HandlePtr pointer to an object of PMSM_FOC module
 * @return indicates present motor state
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Retrieves present motor state.If in error state, user need to clear error state before starting the motor again.
 * Information about error, can be extracted from operational_error variable.
 *
 * <BR>
 * Example Usage:
 * <BR>
 *
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   uint8_t state;
 *
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *
 *   state = PMSM_FOC_GetStatus(&PMSM_FOC_0);
 *
 *   while(1U)
 *   {
 *
 *   }
 * }
 * @endcode<BR>
 */
PMSM_FOC_MSM_t PMSM_FOC_GetStatus(PMSM_FOC_t*const HandlePtr);

/**
 * @brief This API sets the Motor Speed (rpm) threshold for transitioning from open-loop V/F acceleration mode to closed-loop mode \n
 * during starting phase.
 * @param HandlePtr pointer to an object of PMSM_FOC module
 * @param speed uint32_t threshold speed input in rpm
 * @retval PMSM_FOC_STATUS_t status of operation \n
 * PMSM_FOC_STATUS_SUCCESS if execution successful \n
 * PMSM_FOC_STATUS_INVALID_PARAM if input is not within range\n
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Invoke this API to update speed threshold value at run time.<br>
 *</BR>
 *
 * Example Usage:
 * <BR>
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   PMSM_FOC_STATUS_t status;
 *   DAVE_STATUS_t init_status;
 *   uint32_t speed = 200;
 *
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *   status = PMSM_FOC_SetVFEndSpeed(&PMSM_FOC_0, speed);
 *   while(1);
 *   return 0;
 * }
 * @endcode<BR>
 */
PMSM_FOC_STATUS_t PMSM_FOC_SetVFEndSpeed(PMSM_FOC_t*const HandlePtr, uint32_t speed);

/**
 * @brief This API sets the low pass filter factor for BEMF used for smooth transition from open loop to closed loop.
 * @param HandlePtr pointer to an object of PMSM_FOC module
 * @param value uint16_t LPF factor
 * @retval PMSM_FOC_STATUS_t status of operation \n
 * PMSM_FOC_STATUS_INVALID_PARAM if input is not within range\n
 * PMSM_FOC_STATUS_SUCCESS if execution successful \n
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Invoke this API to update LPF factor at run time.<br>
 *</BR>
 *
 * Example Usage:
 * <BR>
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   PMSM_FOC_STATUS_t status;
 *   DAVE_STATUS_t init_status;
 *   uint16_t lpf_factor = 2;
 *
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *   status = PMSM_FOC_SetTransitionLPFFactor(&PMSM_FOC_0, lpf_factor);
 *   while(1);
 *   return 0;
 * }
 * @endcode<BR>
 */
PMSM_FOC_STATUS_t PMSM_FOC_SetTransitionLPFFactor(PMSM_FOC_t*const HandlePtr, uint16_t lpf_factor);

/**
 * @brief This API sets the high threshold value of BEMF used for smooth transition from open loop to closed loop.
 * @param HandlePtr pointer to an object of PMSM_FOC module
 * @param value uint16_t High threshold factor
 * @retval PMSM_FOC_STATUS_t status of operation \n
 * PMSM_FOC_STATUS_INVALID_PARAM if input is not within range\n
 * PMSM_FOC_STATUS_SUCCESS if execution successful \n
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Invoke this API to update high threshold value at run time.<br>
 *</BR>
 *
 * Example Usage:
 * <BR>
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   PMSM_FOC_STATUS_t status;
 *   DAVE_STATUS_t init_status;
 *   uint16_t value = 2;
 *
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *   status = PMSM_FOC_SetTransitionHighThreshold(&PMSM_FOC_0, value);
 *   while(1);
 *   return 0;
 * }
 * @endcode<BR>
 */
PMSM_FOC_STATUS_t PMSM_FOC_SetTransitionHighThreshold(PMSM_FOC_t*const HandlePtr, uint16_t value);

/**
 * @brief This API sets the low threshold value of BEMF used for smooth transition from open loop to closed loop.
 * @param HandlePtr pointer to an object of PMSM_FOC module
 * @param value uint16_t low threshold factor
 * @retval PMSM_FOC_STATUS_t status of operation \n
 * PMSM_FOC_STATUS_SUCCESS if execution successful \n
 * PMSM_FOC_STATUS_INVALID_PARAM if input is not within range\n
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Invoke this API to update low threshold value at run time.<br>
 *</BR>
 *
 * Example Usage:
 * <BR>
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   PMSM_FOC_STATUS_t status;
 *   DAVE_STATUS_t init_status;
 *   uint16_t value = 2;
 *
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *   status = PMSM_FOC_SetTransitionLowThreshold(&PMSM_FOC_0, value);
 *   while(1);
 *   return 0;
 * }
 * @endcode<BR>
 */
PMSM_FOC_STATUS_t PMSM_FOC_SetTransitionLowThreshold(PMSM_FOC_t*const HandlePtr, uint16_t value);


/**
 * @}
 */

/*
 * @brief This API start PWM timers synchronously.
 * @param HandlePtr pointer to an object of PMSM_FOC module
 * @return void
 * <BR>
 *
 * Example Usage:
 *
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *   PMSM_FOC_StartPWMTimer(&PMSM_FOC_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void PMSM_FOC_StartPWMTimer(PMSM_FOC_t*const HandlePtr);

/*
 * @brief This API stop the PWM timers.
 * @param HandlePtr Constant pointer to PMSM_FOC APP Handle
 * @return void
 * <BR>
 *
 * Example Usage:
 *
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *   PMSM_FOC_StopPWMTimer(&PMSM_FOC_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
void PMSM_FOC_StopPWMTimer(PMSM_FOC_t*const HandlePtr);
/*
 * @brief This block executes the motor control state machine (MSM) of PMSM_FOC APP.
 * This state machine is part of drive state machine(operation 3).
 *
 * @param HandlePtr Constant pointer to PMSM_FOC APP Handle
 *
 * @return void
 * <BR>
 *
 * Example Usage:
 *
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *   PMSM_FOC_MotorStart(&PMSM_FOC_0);
 *   while(1);
 *   return 0;
 * }
 *
 * @endcode
 *
 */
__attribute__ ((section (".ram_code"))) void PMSM_FOC_MSM(PMSM_FOC_t* const HandlePtr);

/*
 * @brief This API returns boot strap status.Return PMSM_FOC_BOOTSTRAP_COMPLETED after completion of boot strap.
 * @param HandlePtr Constant pointer to PMSM_FOC APP Handle
 * @return PMSM_FOC_BOOTSTRAP_STATUS_t
 * <BR>
 *
 * Example Usage:
 *
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *   PMSM_FOC_BOOTSTRAP_STATUS_t status;
 *   DAVE_STATUS_t init_status;
 *   init_status = DAVE_Init();   //PMSM_FOC_Init is called within DAVE_Init
 *   status = PMSM_FOC_BootStrap(&PMSM_FOC_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
PMSM_FOC_BOOTSTRAP_STATUS_t PMSM_FOC_Bootstrap(PMSM_FOC_t*const HandlePtr);

/**
 * @brief This function calibrates the amplifier bias voltage.
 * @param[in] HandlePtr Handler pointer of PMSM_FOC APP
 * @return void
 * <BR>
 */
void PMSM_FOC_AmpBiasVoltCalibration(PMSM_FOC_t* const HandlePtr);

/**
 * @brief This function initializes the motor process parameters
 * @param[in] HandlePtr Handler of the PMSM_FOC APP
 * @return void
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 */
void PMSM_FOC_MotorParamInit(PMSM_FOC_t* const HandlePtr);


/**
 * @brief This function do bootstrap configuration.
 * @param[in] HandlePtr Handler of PMSM_FOC APP
 * @return void
 * <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 */
void PMSM_FOC_BootstrapConfiguration(PMSM_FOC_t* const HandlePtr);

/**
 * @brief This function handles the V/F control startup.
 * @param[in] HandlePtr Handler pointer of PMSM_FOC APP
 * @return void
 * <BR>
 */
void PMSM_FOC_Vf_RampUp (PMSM_FOC_t*const HandlePtr);

/**
 * @brief Used in 'Always in v/f open loop' configuration. Motor runs only in open loop.
 * @param[in] HandlePtr Handler pointer of PMSM_FOC APP
 * @return void
 * <BR>
 */
void PMSM_FOC_Vf_Open_Loop (PMSM_FOC_t *const HandlePtr);
/**
 * @brief This function handles the transition to FOC from v/f open loop with or without MET smooth transition.
 * @param[in] HandlePtr Handler pointer of PMSM_FOC APP
 * @return void
 * <BR>
 */
void PMSM_FOC_Transition_to_FOC (PMSM_FOC_t* const HandlePtr);

/**
 * @brief This function handles the MET transition algorithm.
 * @param[in] HandlePtr Handler pointer of PMSM_FOC APP
 * @return void
 * <BR>
 */
void PMSM_FOC_METTransition (PMSM_FOC_t* const HandlePtr);

/**
 * @brief This function handles pre-positioning of the motor in direct FOC configuration.
 * @param[in] HandlePtr Handler pointer of PMSM_FOC APP
 * @return void
 * <BR>
 */
void PMSM_FOC_Rotor_Pre_Positioning (PMSM_FOC_t* const HandlePtr);

/**
 * @brief This function initializes FOC library parameters before calling closed loop FOC algorithm.
 * Called only once for initialization.
 * @param[in] HandlePtr Handler pointer of PMSM_FOC APP
 * @return void
 * <BR>
 */
void PMSM_FOC_Controller_Init_OnceOnly (PMSM_FOC_t* const HandlePtr);
/**
 * @brief This function handles the transition to FOC from v/f open with MET smooth transition.
 * @param[in] HandlePtr Handler pointer of PMSM_FOC APP
 * @return void
 * <BR>
 */
uint8_t VF_Smooth_Transition_To_FOC (PMSM_FOC_t* const HandlePtr);

/********************************* Library Functions ***************************************/
/*
 * @brief This function handles the smooth transition to FOC from v/f open with MET.
 * @param[in] HandlePtr Handler pointer of PMSM_FOC APP
 * @return void
 * <BR>
 */
void Transition_to_FOC (PMSM_FOC_t* const HandlePtr);
/*
 * @brief This is the core FOC algorithm - clarke, park transform with speed and current PI controls. It also
 * includes sensorless estimator to get the position and speed feedback.
 * @param[in] HandlePtr Handler pointer of PMSM_FOC APP
 * @return void
 * <BR>
 */
void __attribute__((section(".ram_code"))) FOC_Controller_LIB (PMSM_FOC_t* const HandlePtr);
/*
 * @brief Initialization of smooth transition variables
 * @param[in] HandlePtr Handler pointer of PMSM_FOC APP
 * @param[in] Omega_Speed Instantaneous speed of the motor
 * @return void
 * <BR>
 */
void Init_Smooth_Transition_To_FOC (PMSM_FOC_t* const HandlePtr, uint32_t Omega_Speed);
/*
 * @brief Initialization of rotor angle
 * @param[in] HandlePtr Handler pointer of PMSM_FOC APP
 * @return void
 * <BR>
 */
void Init_FOC_RotorAngle (PMSM_FOC_t* const HandlePtr);
/*
 * @brief Initialization of PI parameters
 * @param[in] HandlePtr Handler pointer of PMSM_FOC APP
 * @return void
 * <BR>
 */
void Init_FOC_PI_Iks (PMSM_FOC_t* const HandlePtr);

#include "pmsm_foc_extern.h"

/* Support for C++ codebase */
#ifdef __cplusplus
}
#endif

#endif /* PMSM_FOC_H */
