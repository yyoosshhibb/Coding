package Model.APPS.AUTOMATION.v4_0_12.Templates;

import Model.APPS.AUTOMATION.v4_0_12.AUTOMATION

out.print("""
/**
 * @cond
 ***********************************************************************************************************************
 *
 * Copyright (c) 2015-2020, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-20:
 *     - Initial version
 *
 * @endcond
 *
 */
/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#include "automation.h"
/**********************************************************************************************************************
* DATA STRUCTURES
**********************************************************************************************************************/
""");
String appInst                   = null;
double execution_time = 0.0;
Integer count_r0 = 0;
Integer count_r1 = 0;
Integer diff_r0 = 0;
Integer diff_r1 = 0;
String function_r0 = ""
String function_r1 = "";
Integer ramp0_order = 0;
Integer ramp1_order = 0;
Integer executed_fb = 0;
Integer index= 0;
List execution_order = ["NULL","NULL","NULL","NULL","NULL"]; 
List temp_execution = ["NULL","NULL","NULL","NULL","NULL"]; 

List callrate_array = ["AUTOMATION_FB_RAMP_CALLRATE_SVP_TASK",
             "AUTOMATION_FB_RAMP_CALLRATE_FB_TASK",
             "AUTOMATION_FB_RAMP_CALLRATE_EXTERNAL"];
List ramptype_array = ["AUTOMATION_FB_RAMPTYPE_LINEAR",
              "AUTOMATION_FB_RAMPTYPE_SCURVE"]  ;
      
/*This function return 1 if argument is true else return 0*/
def boolvalreturn = {def arg -> (arg == false ? 0 : 1)}

for (Object appIns : appInstancesList ) {
  appInst = appIns.getInstanceLabel()
  

out.print("""

/* Table to save the relation between app_id and app handle pointer */
AUTOMATION_APP_TABLE_t AUTOMATION_App_Table[AUTOMATION_NUM_APPS];

/* Table to save the registered tasks */
AUTOMATION_TASK_TABLE_t AUTOMATION_Task_Table[AUTOMATION_NUM_TASKS];

/* Table to save the Drive State Nachine tasks */
AUTOMATION_SM_t* AUTOMATION_SM_Table[AUTOMATION_NUM_APPS];

#if(AUTOMATION_PH_ENABLE == 1U)
/* Table to save the app parameter table pointer */
AUTOMATION_PH_PARAM_ENTRY_t* AUTOMATION_PH_Param_Table[AUTOMATION_NUM_APPS];

AUTOMATION_PH_PARAMETER_t AUTOMATION_PH_Parameter_Buf[AUTOMATION_NUM_INTERFACES];
#endif

/* Table to save the function block connections */
AUTOMATION_FB_CONNECTION_TABLE_t AUTOMATION_FB_Connect_Table[AUTOMATION_FB_CONNECT_TABLE_SIZE];

/* List of the registered function blocks */
AUTOMATION_FB_HANDLE_t* AUTOMATION_FB_Table[AUTOMATION_FB_APP_FUNCTION_BLOCKS + 
                          AUTOMATION_FB_ENABLED_FUNCTION_BLOCKS];

#if(AUTOMATION_EH_ENABLE == 1U)
AUTOMATION_EH_LOGBOOK_ENTRY_t AUTOMATION_EH_LOGBOOK_DATA[AUTOMATION_EH_LOGBOOK_SIZE];
AUTOMATION_EH_LOGBOOK_ENTRY_t AUTOMATION_EH_APPBUFFER_DATA[AUTOMATION_EH_APPBUF_SIZE];

/* Logbook structure to save the error information */
AUTOMATION_EH_LOGBOOK_t AUTOMATION_EH_ErrorLogbook = 
{
  .cs_read_index          = 0U,
  .cs_write_index         = 0U,
  .cs_data_length         = 0U,
  .info_read_index        = AUTOMATION_EH_LOGBOOK_CS_SIZE,
  .info_write_index       = AUTOMATION_EH_LOGBOOK_CS_SIZE,
  .info_data_length       = 0U,
  .error_logbook_ptr      = AUTOMATION_EH_LOGBOOK_DATA,
};

/* Buffer to save the app error data */
AUTOMATION_EH_APPERROR_BUFFER_t AUTOMATION_EH_AppErrorBuf = 
{
  .read_index         = 0U,
  .write_index        = 0U,
  .data_length        = 0U,
  .error_logbook_ptr  = AUTOMATION_EH_APPBUFFER_DATA,
};

/* Bit interface error table */
AUTOMATION_EH_BIT_ERROR_TABLE_t AUTOMATION_EH_BitErrorTable[AUTOMATION_NUM_INTERFACES][AUTOMATION_EH_BITINTERFACE_MAX_ERRORS];
#endif

""");

/******************************************START -  FB_RAMP0****************************************************/
if ((appIns.gcheck_r0enable.value == true) && (appIns.gcombo_r0executiontime.options.indexOf(appIns.gcombo_r0executiontime.value) == 1))
{
  executed_fb++;

}

if (appIns.gcheck_r0enable.value == true)
{
  if(appIns.gcombo_r0executiontime.options.indexOf(appIns.gcombo_r0executiontime.value) == 0)
  {
    execution_time = appIns.gfloat_r0exetime.value
  }
  else
  {
    execution_time = appIns.gint_fbactualtime.value
  }
  count_r0 = (Integer)((1000000/ appIns.gfloat_r0acceleration.value) / execution_time)
  diff_r0 = (Integer)((appIns.gfloat_r0targetvalue.value -appIns.gfloat_r0initvalue.value) * appIns.gfloat_r0ratio.value / 100)
  if (appIns.gcombo_r0ramptype.options.indexOf(appIns.gcombo_r0ramptype.value) == 0)
  {
    function_r0 = "AUTOMATION_FB_LinearRamp"
  }
  else
  {
    function_r0 = "AUTOMATION_FB_ScurveRamp"
    count_r0 = (Integer)(1000000/ execution_time)
  }

out.print ("""
/* FB_RAMP0 configuration */
const AUTOMATION_FB_RAMP_CONFIG_t AUTOMATION_FB_Ramp0_Config = 
{
  .startset            = (int32_t)${(Integer)appIns.gfloat_r0initvalue.value},
  .endset              = (int32_t)${(Integer)appIns.gfloat_r0targetvalue.value},
  .linear_acceleration = (int32_t)${(Integer)appIns.gfloat_r0acceleration.value},
  .time_constant       = ${(Integer)(1000000/execution_time)}U,
  .linear_startvalue   = (int32_t)${(Integer)appIns.gfloat_r0initvalue.value + diff_r0},
  .linear_endvalue     = (int32_t)${(Integer)appIns.gfloat_r0targetvalue.value - diff_r0},
  .slewrate_counter    = ${(Integer)((1000000/appIns.gfloat_r0jerk.value)/execution_time)}U,
  .slewrate_endset     = (int32_t)${(Integer)appIns.gfloat_r0targetslewrate.value},
  .callrate            = ${callrate_array[appIns.gcombo_r0executiontime.options.indexOf(appIns.gcombo_r0executiontime.value)]},
  .ramp_type           = ${ramptype_array[appIns.gcombo_r0ramptype.options.indexOf(appIns.gcombo_r0ramptype.value)]},
  .ratio               =  ${(Integer)appIns.gfloat_r0ratio.value}U,
};


AUTOMATION_FB_RAMPGEN_t AUTOMATION_Ramp0_Handle =
{
  .endset_t            = (int32_t)${(Integer)appIns.gfloat_r0targetvalue.value},
  .endset_ptr          = &AUTOMATION_Ramp0_Handle.endset_t,
  .out_set_t           = (int32_t)${(Integer)appIns.gfloat_r0initvalue.value},
  .scale               = 32768U,
  .scale_ptr           = &AUTOMATION_Ramp0_Handle.scale,
  .counter             = ${count_r0}U,
  .index               = 0U,
  .prev_endset_t       = (int32_t)${(Integer)appIns.gfloat_r0targetvalue.value},
  .slewrate_end        = (int32_t)${(Integer)appIns.gfloat_r0targetslewrate.value},
  .slewrate_startset_t = (int32_t)0,
  .slewrate_endset_t   = (int32_t)${(Integer)appIns.gfloat_r0targetslewrate.value},
  .slewrate_set_t      = (int32_t)0,
  .slewrate_index      = 0U,
  .linear_startvalue_t = (int32_t)${(Integer)appIns.gfloat_r0initvalue.value + diff_r0},
  .linear_endvalue_t   = (int32_t)${(Integer)appIns.gfloat_r0targetvalue.value - diff_r0},
  .config_ptr          = &AUTOMATION_FB_Ramp0_Config
};

int32_t ** AUTOMATION_FB_RAMP0_INPUT[] = {&AUTOMATION_Ramp0_Handle.endset_ptr, (int32_t**)&AUTOMATION_Ramp0_Handle.scale_ptr};
int32_t * AUTOMATION_FB_RAMP0_OUTPUT[] = {&AUTOMATION_Ramp0_Handle.out_set_t};

AUTOMATION_FB_HANDLE_t AUTOMATION_${appIns.gstring_r0fbid.value} =
{
  .input_ptr  = AUTOMATION_FB_RAMP0_INPUT,
  .output_ptr = AUTOMATION_FB_RAMP0_OUTPUT,
  .config_ptr = &AUTOMATION_Ramp0_Handle,
  .name       = "${appIns.gstring_r0fbid.value}",
  .function   = (AUTOMATION_FB_FUNCT_PTR_t)${function_r0}
};

""");
}
/******************************************END -  FB_RAMP0****************************************************/
/******************************************START -  FB_RAMP1****************************************************/
if ((appIns.gcheck_r1enable.value == true) && (appIns.gcombo_r1executiontime.options.indexOf(appIns.gcombo_r1executiontime.value) == 1))
{
  executed_fb++;
}
if (appIns.gcheck_r1enable.value == true)
{
  if(appIns.gcombo_r1executiontime.options.indexOf(appIns.gcombo_r1executiontime.value) == 0)
  {
    execution_time = appIns.gfloat_r1exetime.value
  }
  else
  {
    execution_time = appIns.gint_fbactualtime.value
  }
  count_r1 = (Integer)((1000000/ appIns.gfloat_r1acceleration.value) / execution_time)
  diff_r1 = (Integer)((appIns.gfloat_r1targetvalue.value -appIns.gfloat_r1initvalue.value) * appIns.gfloat_r1ratio.value / 100)
  if (appIns.gcombo_r1ramptype.options.indexOf(appIns.gcombo_r1ramptype.value) == 0)
  {
    function_r1 = "AUTOMATION_FB_LinearRamp"
  }
  else
  {
    function_r1 = "AUTOMATION_FB_ScurveRamp"
    count_r1 = (Integer)(1000000/ execution_time)
  }

out.print ("""
/* FB_RAMP1 configuration */
const AUTOMATION_FB_RAMP_CONFIG_t AUTOMATION_FB_Ramp1_Config = 
{
  .startset            = (int32_t)${(Integer)appIns.gfloat_r1initvalue.value},
  .endset              = (int32_t)${(Integer)appIns.gfloat_r1targetvalue.value},
  .linear_acceleration = (int32_t)${(Integer)appIns.gfloat_r1acceleration.value},
  .time_constant       = ${(Integer)(1000000/execution_time)}U,
  .linear_startvalue   = (int32_t)${(Integer)appIns.gfloat_r1initvalue.value + diff_r1},
  .linear_endvalue     = (int32_t)${(Integer)appIns.gfloat_r1targetvalue.value - diff_r1},
  .slewrate_counter    = ${(Integer)((1000000/appIns.gfloat_r1jerk.value)/execution_time)}U,
  .slewrate_endset     = (int32_t)${(Integer)appIns.gfloat_r1targetslewrate.value},
  .callrate            = ${callrate_array[appIns.gcombo_r1executiontime.options.indexOf(appIns.gcombo_r1executiontime.value)]},
  .ramp_type           = ${ramptype_array[appIns.gcombo_r1ramptype.options.indexOf(appIns.gcombo_r1ramptype.value)]},
  .ratio               = ${(Integer)appIns.gfloat_r1ratio.value}U,

};

AUTOMATION_FB_RAMPGEN_t AUTOMATION_Ramp1_Handle =
{
  .endset_t            = (int32_t)${(Integer)appIns.gfloat_r1targetvalue.value},
  .endset_ptr          = &AUTOMATION_Ramp0_Handle.endset_t,
  .out_set_t           = (int32_t)${(Integer)appIns.gfloat_r1initvalue.value},
  .scale               = 32768U,
  .scale_ptr           = &AUTOMATION_Ramp0_Handle.scale,
  .counter             = ${count_r1}U,
  .index               = 0U,
  .prev_endset_t       = (int32_t)${(Integer)appIns.gfloat_r1targetvalue.value},
  .slewrate_end        = (int32_t)${(Integer)appIns.gfloat_r1targetslewrate.value},
  .slewrate_startset_t = (int32_t)0,
  .slewrate_endset_t   = (int32_t)${(Integer)appIns.gfloat_r1targetslewrate.value},
  .slewrate_set_t      = (int32_t)0,
  .slewrate_index      = 0U,
  .linear_startvalue_t = (int32_t)${(Integer)appIns.gfloat_r1initvalue.value + diff_r1},
  .linear_endvalue_t   = (int32_t)${(Integer)appIns.gfloat_r1targetvalue.value - diff_r1},
  .config_ptr          = &AUTOMATION_FB_Ramp1_Config
};

int32_t ** AUTOMATION_FB_RAMP1_INPUT[] = {&AUTOMATION_Ramp1_Handle.endset_ptr, (int32_t**)&AUTOMATION_Ramp1_Handle.scale_ptr};
int32_t * AUTOMATION_FB_RAMP1_OUTPUT[] = {&AUTOMATION_Ramp1_Handle.out_set_t};

AUTOMATION_FB_HANDLE_t AUTOMATION_${appIns.gstring_r1fbid.value} =
{
  .input_ptr  = AUTOMATION_FB_RAMP1_INPUT,
  .output_ptr = AUTOMATION_FB_RAMP1_OUTPUT,
  .config_ptr = &AUTOMATION_Ramp1_Handle,
  .name       = "${appIns.gstring_r1fbid.value}",
  .function   = (AUTOMATION_FB_FUNCT_PTR_t)${function_r1}
};

""");
}
/******************************************END -  FB_RAMP1****************************************************/

/****************************************FB Execution Order *************************************************/
temp_execution[0] = (appIns.gcombo_fbr0.value)
temp_execution[1] = (appIns.gcombo_fbr1.value)
if(executed_fb > 0)
{
  for(index = 0; index < (executed_fb); index++)
  {
    /* Find the execution order if this is to be executed from the function block handler */
    if(temp_execution[index] == "FB_RAMP_0")
      execution_order[index] = "AUTOMATION_${appIns.gstring_r0fbid.value}";
    else if(temp_execution[index] == "FB_RAMP_1")
      execution_order[index] = "AUTOMATION_${appIns.gstring_r1fbid.value}";
  }
  /***********************************End: FB Execution Order *************************************************/
out.print ("""
AUTOMATION_FB_HANDLE_t* AUTOMATION_FB_ExecutionOrderList[AUTOMATION_FB_EXECUTED_FUNCTION_BLOCKS] = 
{
""");
for(index = 0; index < (executed_fb-1); index++)
{
out.print ("""  &${execution_order[index]},
""");
}
out.print ("""  &${execution_order[executed_fb - 1]}
};
""");
}
else
{
out.print ("""  
AUTOMATION_FB_HANDLE_t* AUTOMATION_FB_ExecutionOrderList[AUTOMATION_FB_EXECUTED_FUNCTION_BLOCKS]; 

""");
}

out.print ("""
AUTOMATION_t ${appInst} = 
{
  .systimer_ptr                = &${appIns.appres_systimer_0.getInstanceLabel()},
  .fb_timer_id                 = 0U,
  .eh_timer_id                 = 0U,
  .state                       = AUTOMATION_STATE_UNINITIALIZED,
  .app_id                      = 0U,
  .interface_id                = 0U,
  .fb_id                       = 0U,
  .task_id                     = 0U,
  .fb_connect_table_write_index= 0U,
  .fb_connect_table_read_index = 0U,
  .fb_connect_table_data_length= AUTOMATION_FB_CONNECT_TABLE_SIZE
};

""");

}

