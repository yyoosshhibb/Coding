/**
 * @file automation.c
 * @date 2015-10-08
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * AUTOMATION v4.0.12 - Provides mechanism to connect two APPs using function block processor.
 * This supports online parameter update and error logging.  This consumes System Timer APP and
 * provides task registration feature. It also provides state machine.
 *
 * Copyright (c) 2015-2020, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-20:
 *     - Initial version
 *
 * 2015-06-20:
 *     - APIs added to set and get ramp parameters
 *     - Aligned with change in SYSTIMER APP
 *
 * @endcond
 *
 */

/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#include "automation.h"


/***********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/
#define AUTOMATION_EH_RESET_BIT (0U) /**< reset the bit*/
#define AUTOMATION_EH_SET_BIT   (1U) /**< set the bit */
#define AUTOMATION_PARAM_SCALE  (32767)
#define AUTOMATION_FB_RAMP_MIN   (-65536)
#define AUTOMATION_FB_RAMP_MAX   (65535)
#define AUTOMATION_FB_RAMP_SLEWRATE_MIN  (0U)
#define AUTOMATION_FB_RAMP_SLEWRATE_MAX  (1000000U)

/***********************************************************************************************************************
 * LOCAL DATA
 **********************************************************************************************************************/

/***********************************************************************************************************************
 * LOCAL ROUTINES
 **********************************************************************************************************************/
#if (AUTOMATION_PH_ENABLE == 1U)
static void AUTOMATION_PH_ParamSet(uint8_t interface_count);
#endif
#if (AUTOMATION_EH_ENABLE == 1U)
static void AUTOMATION_AppInterface_ReadReportedErrors(void);
static void AUTOMATION_EH_ProcessError(AUTOMATION_EH_BIT_ERROR_TABLE_t* const error_table_entry_ptr);
#endif
static void AUTOMATION_FB_AccelerationRamp(AUTOMATION_FB_RAMPGEN_t* const ramphandle_ptr);

/**********************************************************************************************************************
* API IMPLEMENTATION
**********************************************************************************************************************/
static inline uint32_t AUTOMATION_WriteBit(uint32_t word, uint8_t pos, uint8_t data)
{
  uint32_t return_val;
  if (data == 0U)
  {
    /* Reset the bit */
    return_val = (word & (~((uint32_t) 1U << (uint32_t) pos)));
  }
  else
  {
    /* Set the bit */
    return_val = (word | ((uint32_t) 1U << (uint32_t) pos));
  }
  return return_val;
}

#if (AUTOMATION_EH_ENABLE == 1U)
static AUTOMATION_EH_BIT_INTERFACE_t AUTOMATION_EH_BitInterface_Word[AUTOMATION_NUM_INTERFACES];
static AUTOMATION_EH_ERROR_REPORT_t AUTOMATION_EH_ReportingInterface;
#endif



/* Returns the version of the GLOBAL_POSIF App. */
DAVE_APP_VERSION_t AUTOMATION_GetAppVersion(void)
{
  DAVE_APP_VERSION_t version;

  version.major = AUTOMATION_MAJOR_VERSION;
  version.minor = AUTOMATION_MINOR_VERSION;
  version.patch = AUTOMATION_PATCH_VERSION;

  return version;
}

/**
 * This creates the error handler task and function block processor task
 * Initializes parameter handler
 */
AUTOMATION_STATUS_t AUTOMATION_Init(AUTOMATION_t* const handle_ptr)
{
  uint32_t status = 0U;
  if (AUTOMATION_STATE_UNINITIALIZED == handle_ptr->state)
  {
    status = (uint32_t) SYSTIMER_Init(handle_ptr->systimer_ptr);

#if (AUTOMATION_EH_ENABLE == 1U)
    handle_ptr->eh_timer_id = SYSTIMER_CreateTimer(AUTOMATION_EH_PERIOD,
      SYSTIMER_MODE_PERIODIC,
        (SYSTIMER_CALLBACK_t)AUTOMATION_EH_ErrorSequencer,
        NULL);
    status |= (uint32_t)SYSTIMER_StartTimer(handle_ptr->eh_timer_id);
#endif

#if (AUTOMATION_FB_TASK_ENABLE == 1U)
    handle_ptr->fb_timer_id = SYSTIMER_CreateTimer(AUTOMATION_FB_PERIOD,
        SYSTIMER_MODE_PERIODIC,
        (SYSTIMER_CALLBACK_t)AUTOMATION_FB_FunctionBlockSequencer,
        NULL);
    status |= (uint32_t)SYSTIMER_StartTimer(handle_ptr->fb_timer_id);
#endif

#if (AUTOMATION_FB_RAMP_GEN_0_ENABLED == 1U)
    status |= (uint32_t)AUTOMATION_FB_RegisterFunctionBlock(&AUTOMATION_FB_RAMP_0);
#endif
#if (AUTOMATION_FB_RAMP_GEN_1_ENABLED == 1U)
    status |= (uint32_t)AUTOMATION_FB_RegisterFunctionBlock(&AUTOMATION_FB_RAMP_1);
#endif

    handle_ptr->state = AUTOMATION_STATE_INITIALIZED;
  }
  return ((AUTOMATION_STATUS_t) status);
}

/**
 * This function assigns the app_id to the app instance.
 */
AUTOMATION_STATUS_t AUTOMATION_RegisterApp(void* const app_handle_ptr, const char* const name, uint8_t* app_id)
{
  AUTOMATION_STATUS_t status;

  if (AUTOMATION_NUM_APPS > AUTOMATION_Handle.app_id)
  {
    /* Register and Assign App ID */
    AUTOMATION_App_Table[AUTOMATION_Handle.app_id].apphandle_ptr = (void*) app_handle_ptr;
    AUTOMATION_App_Table[AUTOMATION_Handle.app_id].app_name_ptr = name;
    *app_id = AUTOMATION_Handle.app_id;
    AUTOMATION_Handle.app_id++;
    status = AUTOMATION_STATUS_SUCCESS;
  }
  else
  {
    /* App table entries are reached to its Max. */
    status = AUTOMATION_STATUS_NUM_APPS_EXCEEDED;
  }
  return status;
}

/**
 * This function assigns the interface ID to the interface channel.
 */
AUTOMATION_STATUS_t AUTOMATION_RegisterInterface(uint8_t* interface_id)
{
  AUTOMATION_STATUS_t status;
  if (AUTOMATION_NUM_INTERFACES > AUTOMATION_Handle.interface_id)
  {
    /* Register Interface ID */
    *interface_id = (uint8_t) AUTOMATION_Handle.interface_id;
    AUTOMATION_Handle.interface_id++;
    status = AUTOMATION_STATUS_SUCCESS;
  }
  else
  {
    /* Interface table entries are reached to its Max. */
    status = AUTOMATION_STATUS_NUM_INTERFACE_EXCEEDED;
  }

  return status;
}

/**
 * Registers the task function to be called from the system timer interrupt
 */
AUTOMATION_STATUS_t AUTOMATION_RegisterTask(AUTOMATION_TASK_FUNCT_PTR_t task_ptr, void* callback_arg_ptr,
                                            uint32_t delay_count)
{
  AUTOMATION_STATUS_t status;
  if (AUTOMATION_NUM_TASKS > AUTOMATION_Handle.task_id)
  {
    /* Update the task table information */
    AUTOMATION_Task_Table[AUTOMATION_Handle.task_id].task_ptr = task_ptr;
    AUTOMATION_Task_Table[AUTOMATION_Handle.task_id].period = delay_count;

    /* Create the system timer with the given period */
    AUTOMATION_Task_Table[AUTOMATION_Handle.task_id].task_timer_id = SYSTIMER_CreateTimer(delay_count,
        SYSTIMER_MODE_PERIODIC, (SYSTIMER_CALLBACK_t) task_ptr, callback_arg_ptr);
    /* check if system timer is created successfully */
    if (AUTOMATION_Task_Table[AUTOMATION_Handle.task_id].task_timer_id != (0U))
    {
      /* start the task timer */
      status = (AUTOMATION_STATUS_t) SYSTIMER_StartTimer(
          AUTOMATION_Task_Table[AUTOMATION_Handle.task_id].task_timer_id);
      AUTOMATION_Handle.task_id++;
    }
    else
    {
      status = AUTOMATION_STATUS_FAILURE;
    }
  }
  else
  {
    status = AUTOMATION_STATUS_FAILURE;
  }
  return status;
}

/**
 * De-registers task function.
 * Task table is adjusted for this deleted entry.
 */
AUTOMATION_STATUS_t AUTOMATION_DeregisterTask(AUTOMATION_TASK_FUNCT_PTR_t task_ptr)
{
  AUTOMATION_STATUS_t status;
  uint8_t count;
  uint8_t match_index = AUTOMATION_NUM_TASKS + 1U;

  /* Find the entry in the task table based on the task_ptr */
  for (count = 0U; count < AUTOMATION_NUM_TASKS; count++)
  {
    if (AUTOMATION_Task_Table[count].task_ptr == task_ptr)
    {
      match_index = count;
      break;
    }
  }

  /* Delete the task and remove from the task table */
  if ((AUTOMATION_NUM_TASKS + 1U) != match_index)
  {
    status = (AUTOMATION_STATUS_t) SYSTIMER_StopTimer(AUTOMATION_Task_Table[match_index].task_timer_id);
    if (AUTOMATION_STATUS_SUCCESS == status)
    {
      status = (AUTOMATION_STATUS_t) SYSTIMER_DeleteTimer(AUTOMATION_Task_Table[match_index].task_timer_id);
      AUTOMATION_Handle.task_id--;
      for (count = match_index; count <= AUTOMATION_Handle.task_id; count++)
      {
        AUTOMATION_Task_Table[count].task_ptr = AUTOMATION_Task_Table[count + 1U].task_ptr;
        AUTOMATION_Task_Table[count].period = AUTOMATION_Task_Table[count + 1U].period;
        AUTOMATION_Task_Table[count].task_timer_id = AUTOMATION_Task_Table[count + 1U].task_timer_id;
      }
    }
    else
    {
      status = AUTOMATION_STATUS_FAILURE;
    }
  }
  else
  {
    status = AUTOMATION_STATUS_FAILURE;
  }
  return (status);
}


#if (AUTOMATION_PH_ENABLE == 1U)

/**
 * This function will save the app parameter table pointer in the AUTOMATION_PH_PARAMHANDLE.
 * It maintains the relation between app_id and parameter table pointer.
 */
AUTOMATION_STATUS_t AUTOMATION_PH_RegisterParamTable(uint8_t app_id,
    AUTOMATION_PH_PARAM_ENTRY_t* app_param_table_ptr)
{
  AUTOMATION_STATUS_t status;

  if (AUTOMATION_NUM_APPS > app_id)
  {
    /* App param table pointer */
    AUTOMATION_PH_Param_Table[app_id] = app_param_table_ptr;
    status = AUTOMATION_STATUS_SUCCESS;
  }
  else
  {
    status = AUTOMATION_STATUS_NUM_PARAM_EXCEEDED;
  }
  return status;
}

/**
 * This will take action on the entry in the parameter buffer and update the status
 */
void AUTOMATION_PH_ParamSequencer(void)
{
  uint8_t interface_count; /* to scan interface IDs */
  uint8_t param_table_index; /* app ID */
  uint8_t param_id; /* parameter ID */
  uint32_t scale; /* scale of the parameter to convert target value in physical value*/

  /* Scan each registered interface buffer to execute the requests */
  for(interface_count = 0U; interface_count < AUTOMATION_NUM_INTERFACES; interface_count++)
  {
    /* Check if there is valid entry in the buffer */
    if (AUTOMATION_PH_Parameter_Buf[interface_count].status == AUTOMATION_PH_STATUS_ACTIVE)
    {
      /* execute the buffer entry */
      switch(AUTOMATION_PH_Parameter_Buf[interface_count].command)
      {
        case AUTOMATION_PH_COMMAND_SET :
          /* Write the parameter value */
          AUTOMATION_PH_ParamSet(interface_count);
          break;

        case AUTOMATION_PH_COMMAND_GET :
        /* Read the value of the parameter based upon app_id, param_id and scale */
        param_table_index = AUTOMATION_PH_Parameter_Buf[interface_count].app_id;
        param_id = AUTOMATION_PH_Parameter_Buf[interface_count].param_id;
        scale = AUTOMATION_PH_Param_Table[param_table_index][param_id].scale;

        AUTOMATION_PH_Parameter_Buf[interface_count].value =
        (int32_t)((*AUTOMATION_PH_Param_Table[param_table_index][param_id].param_addr * (int32_t)scale) / AUTOMATION_PARAM_SCALE);

        /* Change the status to READY so that interafce can read the result and send new request */
        AUTOMATION_PH_Parameter_Buf[interface_count].status = AUTOMATION_PH_STATUS_READY;

        break;

        default :
        break;
      }

    }
  }
}

/**
 * Automation Parameter set functionality
 */
static void AUTOMATION_PH_ParamSet(uint8_t interface_count)
{
  AUTOMATION_STATUS_t app_api_status = AUTOMATION_STATUS_SUCCESS;
  uint8_t param_table_index = AUTOMATION_PH_Parameter_Buf[interface_count].app_id;
  uint8_t param_id = AUTOMATION_PH_Parameter_Buf[interface_count].param_id;
  AUTOMATION_PH_SET_FUNCT_PTR_t param_set_func_ptr;
  void* apphandle_ptr; /* App handle pointer */
  uint8_t write_access; /* Write access */
  int32_t value, min, max;
  uint32_t inv_scale;

  /* This will set parameter value as per request */
  param_set_func_ptr = AUTOMATION_PH_Param_Table[param_table_index][param_id].setptr;
  value = AUTOMATION_PH_Parameter_Buf[interface_count].value;
  if (param_set_func_ptr != NULL)
  {
    /* App API is available to set parameter */
    apphandle_ptr = (void *)AUTOMATION_App_Table[param_table_index].apphandle_ptr;
    app_api_status = (AUTOMATION_STATUS_t)param_set_func_ptr(apphandle_ptr, value);
  }
  else
  {
    /* App API function not available to set,hence access parameter address and set value */
    min = AUTOMATION_PH_Param_Table[param_table_index][param_id].minval;
    max = AUTOMATION_PH_Param_Table[param_table_index][param_id].maxval;
    write_access = AUTOMATION_PH_Param_Table[param_table_index][param_id].write_access;
    inv_scale = AUTOMATION_PH_Param_Table[param_table_index][param_id].inv_scale;
    /* Limit checking for the value */
    if ((value < min) || (value > max))
    {
      app_api_status = AUTOMATION_STATUS_INVALID_PARAM;
    }
    else if (write_access != (uint8_t)AUTOMATION_PH_WRITE_ACCESS_ALLOWED)
    {
      app_api_status = AUTOMATION_STATUS_PERMISSION_DENIED;
    }
    else
    {
      /* Valid value to set */
      *AUTOMATION_PH_Param_Table[param_table_index][param_id].param_addr = (value * (int32_t)inv_scale) / AUTOMATION_PARAM_SCALE;
    }
  }
  /* Change the status to READY so that interafce can read the result and send new request */
  if (app_api_status == AUTOMATION_STATUS_SUCCESS)
  {
    AUTOMATION_PH_Parameter_Buf[interface_count].status = AUTOMATION_PH_STATUS_READY;
  }
  else
  {
    AUTOMATION_PH_Parameter_Buf[interface_count].status = AUTOMATION_PH_STATUS_FAILED;
  }
}

#endif


#if (AUTOMATION_EH_ENABLE == 1U)
/**
 * This function will register bit interface errors in Automation framework.
 */
AUTOMATION_STATUS_t AUTOMATION_EH_BitInterface_RegisterErrors (uint8_t interface_id, uint8_t position,
    AUTOMATION_EH_BIT_ERROR_TABLE_t * const error)
{
  AUTOMATION_STATUS_t status;
  AUTOMATION_EH_BIT_ERROR_TABLE_t *error_entry;
  /* Check if interface ID is valid */
  if (interface_id < AUTOMATION_NUM_INTERFACES)
  {
    /* Register callback function for bit interface error */
    error_entry = &AUTOMATION_EH_BitErrorTable[interface_id][position];
    error_entry->error_functptr = error->error_functptr;
    error_entry->error_callbackarg = error->error_callbackarg;
    error_entry->error_severity = error->error_severity;
    error_entry->error_id = error->error_id;
    status = AUTOMATION_STATUS_SUCCESS;
  }
  else
  {
    /* Registration fails due to no space in error table */
    status = AUTOMATION_STATUS_INVALID_INTERFACE_ID;
  }

  return status;
}

/**
 * This function will register the callback function which will be called when error status is changed
 */
AUTOMATION_STATUS_t AUTOMATION_EH_RegisterInterfaceCallback(uint8_t interface_id, AUTOMATION_EH_REPORTING_FUNCT_PTR_t callback_ptr)
{
  AUTOMATION_STATUS_t status = AUTOMATION_STATUS_SUCCESS;
  if (interface_id < AUTOMATION_NUM_INTERFACES)
  {
    AUTOMATION_EH_ReportingInterface.eh_error_report_interface_id = interface_id;
    AUTOMATION_EH_ReportingInterface.eh_report_callback_ptr = callback_ptr;
  }
  else
  {
    /* Registration fails due to no space in error table */
    status = AUTOMATION_STATUS_INVALID_INTERFACE_ID;
  }
  return (status);
}

/* Read errors reported by App from temporary buffer and log it in log book and send through communication interface */
static void AUTOMATION_AppInterface_ReadReportedErrors(void)
{
  uint8_t temp_buf_index;
  AUTOMATION_EH_LOGBOOK_ENTRY_t * temp_logbook_entry;
  for (temp_buf_index = 0U; temp_buf_index < AUTOMATION_EH_AppErrorBuf.data_length; temp_buf_index++)
  {
    /* Read request for error log book Info/Warning section */
    temp_logbook_entry = &AUTOMATION_EH_AppErrorBuf.error_logbook_ptr[AUTOMATION_EH_AppErrorBuf.read_index++];
    if (AUTOMATION_EH_AppErrorBuf.read_index == AUTOMATION_EH_APPBUF_SIZE)
    {
      /* Ring buffer */
      AUTOMATION_EH_AppErrorBuf.read_index = 0U;
    }
    AUTOMATION_EH_AppErrorBuf.data_length--;

    /* record to log book */
    AUTOMATION_EH_WriteLogbook(*temp_logbook_entry);

    if (AUTOMATION_EH_ReportingInterface.eh_report_callback_ptr != NULL)
    {
      /* Report on communication interface */
      AUTOMATION_EH_ReportingInterface.eh_report_callback_ptr
      (temp_logbook_entry->app_id,
          temp_logbook_entry->error_id,
          temp_logbook_entry->error_severity,
          temp_logbook_entry->error_status);
    }
  }
}

static void AUTOMATION_EH_ProcessError(AUTOMATION_EH_BIT_ERROR_TABLE_t* const error_table_entry_ptr)
{
  if (AUTOMATION_EH_ReportingInterface.eh_report_callback_ptr != NULL)
  {
    /* Report error on interface */
    AUTOMATION_EH_ReportingInterface.eh_report_callback_ptr
    ((uint8_t)AUTOMATION_EH_BIT_INTERFACE_ID,
        error_table_entry_ptr->error_id,
        error_table_entry_ptr->error_severity,
        (uint8_t)AUTOMATION_EH_ERROR_STATUS_SET);
  }

  if (error_table_entry_ptr->error_functptr != NULL)
  {
    /* Call registered call back function */
    (error_table_entry_ptr->error_functptr)(error_table_entry_ptr->error_callbackarg);
  }

}

/**
 * This function will scan errors from the BitInterface Word and take action.
 */
void AUTOMATION_EH_ErrorSequencer (void)
{
  uint8_t error_words_count,bit_count;
  AUTOMATION_EH_BIT_ERROR_TABLE_t *error_table_entry_ptr;
  AUTOMATION_EH_LOGBOOK_ENTRY_t logbook_entry;

  /* Loop to scan all registered bit interface error words */
  for(error_words_count=0U; error_words_count < AUTOMATION_NUM_INTERFACES; error_words_count++)
  {
    if ((AUTOMATION_EH_BitInterface_Word[error_words_count].error_word != 0U) ||
        (AUTOMATION_EH_BitInterface_Word[error_words_count].status_word != 0U))
    {
      /* Loop to scan all registered bits insider error word */
      for(bit_count = 0U; bit_count < 32U; bit_count++)
      {
        /* Check if any error bit is set */
        if ((AUTOMATION_EH_BitInterface_Word[error_words_count].error_word>>bit_count) & 1U)
        {
          /* Error bit is set */
          /* Check if any action is already taken */
          if ((AUTOMATION_EH_BitInterface_Word[error_words_count].status_word>>bit_count) & 1U)
          {
            /* Action is already taken */
            error_table_entry_ptr = NULL;
          }
          else
          {
            /* Action need to take */
            error_table_entry_ptr = &AUTOMATION_EH_BitErrorTable[error_words_count][bit_count];
            AUTOMATION_EH_ProcessError(error_table_entry_ptr);
            /* Set corresponding bit in status word to indicate action is taken */
            AUTOMATION_EH_BitInterface_Word[error_words_count].status_word =
            AUTOMATION_WriteBit(AUTOMATION_EH_BitInterface_Word[error_words_count].status_word, bit_count, AUTOMATION_EH_SET_BIT);

            /* Record in log book */
            logbook_entry.error_status = (uint8_t)AUTOMATION_EH_ERROR_STATUS_SET;
          }
        }
        else
        {
          /* Error bit reseted */
          /* Check if status bit still set then reset it */
          if ((AUTOMATION_EH_BitInterface_Word[error_words_count].status_word>>bit_count) & 1U)
          {
            /* Reset corresponding status bit in status word */
            AUTOMATION_EH_BitInterface_Word[error_words_count].status_word =
            AUTOMATION_WriteBit(AUTOMATION_EH_BitInterface_Word[error_words_count].status_word,bit_count,AUTOMATION_EH_RESET_BIT);

            /* Error table pointer */
            error_table_entry_ptr = &AUTOMATION_EH_BitErrorTable[error_words_count][bit_count];
            /* Report error is cleared */
            if (AUTOMATION_EH_ReportingInterface.eh_report_callback_ptr != NULL)
            {
              /* Report error on interface */
              AUTOMATION_EH_ReportingInterface.eh_report_callback_ptr
              ((uint8_t)AUTOMATION_EH_BIT_INTERFACE_ID,
                  error_table_entry_ptr->error_id,
                  error_table_entry_ptr->error_severity,
                  (uint8_t)AUTOMATION_EH_ERROR_STATUS_SET);
            }
            /* Record in log book */
            logbook_entry.error_status = (uint8_t)AUTOMATION_EH_ERROR_STATUS_CLEARED;
          }
          else
          {
            /* Both error bit and status is in reset - No need to take any action */
            error_table_entry_ptr = NULL;
          }
        }
        /* Record in log book */
        if (error_table_entry_ptr != NULL)
        {
          logbook_entry.app_id = (uint8_t)AUTOMATION_EH_BIT_INTERFACE_ID;
          logbook_entry.error_id = error_table_entry_ptr->error_id;
          logbook_entry.error_severity = error_table_entry_ptr->error_severity;
          /* Gives the current system time in microsecond since start of counter.*/
          logbook_entry.timestamp = SYSTIMER_GetTime();
          AUTOMATION_EH_WriteLogbook(logbook_entry);
        }
      } /* END Loop to scan all registered bits insider error word */
    } /* Error word or corresponding status word not set  */
  } /* END Loop to scan all registered bit interface error words */

  /* Read errors reported by App from temporary buffer and log it in log book and send through communication interface */
  AUTOMATION_AppInterface_ReadReportedErrors();
}

/**
 * Automation Parameter set response in corresponding response buffer
 */
void AUTOMATION_EH_AppInterface_ReportError(uint8_t app_id, uint8_t error_id, AUTOMATION_EH_ERROR_SEVERITY_t error_severity,AUTOMATION_EH_ERROR_STATUS_t status)
{
  AUTOMATION_EH_LOGBOOK_ENTRY_t error;
  AUTOMATION_EH_LOGBOOK_ENTRY_t *logbook;
  if ((error_severity == AUTOMATION_EH_ERROR_SEVERITY_CRITICAL) ||
      (error_severity == AUTOMATION_EH_ERROR_SEVERITY_SAFETY_CRITICAL))
  {
    /* Critical error occurred - Need to report immediately */
    if (AUTOMATION_EH_ReportingInterface.eh_report_callback_ptr != NULL)
    {
      AUTOMATION_EH_ReportingInterface.eh_report_callback_ptr(app_id,error_id,(uint8_t)error_severity,(uint8_t)status);
    }
    /* Record error in log book */
    error.app_id = app_id;
    error.error_id = error_id;
    error.error_severity = (uint8_t)error_severity;
    error.error_status = (uint8_t)status;
    error.timestamp = SYSTIMER_GetTime();
    AUTOMATION_EH_WriteLogbook(error);
  }
  else
  {
    /* Non critical error occurred - buffer it for processing */
    /* Overwriting can be possible */
    logbook = &AUTOMATION_EH_AppErrorBuf.error_logbook_ptr[AUTOMATION_EH_AppErrorBuf.write_index++];
    if (AUTOMATION_EH_AppErrorBuf.write_index == AUTOMATION_EH_APPBUF_SIZE)
    {
      /* Temporary buffer is ring buffer */
      AUTOMATION_EH_AppErrorBuf.write_index = 0U;
    }
    if (AUTOMATION_EH_AppErrorBuf.data_length < AUTOMATION_EH_APPBUF_SIZE)
    {
      AUTOMATION_EH_AppErrorBuf.data_length++;
    }
    logbook->app_id = app_id;
    logbook->error_id = (uint8_t)error_id;
    logbook->error_severity = (uint8_t)error_severity;
    logbook->error_status = (uint8_t)status;
    logbook->timestamp = SYSTIMER_GetTime();
  }
}

/**
 * This will update Bit interface Error word.
 */
AUTOMATION_STATUS_t AUTOMATION_EH_BitInterface_ReportError(uint8_t interface_id,uint32_t error_word_val)
{
  AUTOMATION_STATUS_t status;
  if (interface_id < AUTOMATION_NUM_INTERFACES)
  {
    /* Valid Bit Interface - Update Bit interface Error Word */
    AUTOMATION_EH_BitInterface_Word[interface_id].error_word = error_word_val;
    status = AUTOMATION_STATUS_SUCCESS;
  }
  else
  {
    /* Invalid Interface ID */
    status = AUTOMATION_STATUS_INVALID_INTERFACE_ID;
  }
  return status;
}

/**
 * This API will record error entry in Error Log book
 * Critical errors     - logged in Log book Critical section     - Overwrite not possible
 * Info/Warning errors - logged in Log book Info/Warning section - Overwrite possible
 */
void AUTOMATION_EH_WriteLogbook(AUTOMATION_EH_LOGBOOK_ENTRY_t error)
{
  AUTOMATION_EH_LOGBOOK_ENTRY_t * logbook;
  /* Check error severity & place accordingly in Log book */
  if ((error.error_severity == (uint8_t)AUTOMATION_EH_ERROR_SEVERITY_CRITICAL)||
      (error.error_severity == (uint8_t)AUTOMATION_EH_ERROR_SEVERITY_SAFETY_CRITICAL))
  {
    if (AUTOMATION_EH_ErrorLogbook.cs_data_length < AUTOMATION_EH_LOGBOOK_CS_SIZE)
    {
      /* Successfully logged the error */
      logbook = &AUTOMATION_EH_ErrorLogbook.error_logbook_ptr[AUTOMATION_EH_ErrorLogbook.cs_write_index++];
      AUTOMATION_EH_ErrorLogbook.cs_data_length++;
      if (AUTOMATION_EH_ErrorLogbook.cs_write_index == AUTOMATION_EH_LOGBOOK_CS_SIZE)
      {
        /* Log book Critical section ring buffer */
        AUTOMATION_EH_ErrorLogbook.cs_write_index = 0U;
      }
    }
    else
    {
      if (AUTOMATION_EH_ReportingInterface.eh_report_callback_ptr != NULL)
      {
        /* No Space to store new error entries - Report error on interface */
        AUTOMATION_EH_ReportingInterface.eh_report_callback_ptr((uint8_t)AUTOMATION_EH_BIT_INTERFACE_ID,
            (uint8_t)AUTOMATION_STATUS_LOGBOOK_CS_FULL,
            (uint8_t)AUTOMATION_EH_ERROR_SEVERITY_INFO,
            (uint8_t)AUTOMATION_EH_ERROR_STATUS_SET);
      }
      logbook = NULL;
    }
  }
  else
  {
    logbook = &AUTOMATION_EH_ErrorLogbook.error_logbook_ptr[AUTOMATION_EH_ErrorLogbook.info_write_index++];
    if (AUTOMATION_EH_ErrorLogbook.info_write_index == ((uint32_t)AUTOMATION_EH_LOGBOOK_INFO_SIZE << 1U))
    {
      /* Log book info section ring buffer */
      AUTOMATION_EH_ErrorLogbook.info_write_index = AUTOMATION_EH_LOGBOOK_CS_SIZE;
    }
    if (AUTOMATION_EH_ErrorLogbook.info_data_length < AUTOMATION_EH_LOGBOOK_INFO_SIZE)
    {
      AUTOMATION_EH_ErrorLogbook.info_data_length++;
    }
  }

  if (logbook != NULL)
  {
    logbook->app_id = error.app_id;
    logbook->error_id = error.error_id;
    logbook->error_severity = error.error_severity;
    logbook->error_status = error.error_status;
    logbook->timestamp = error.timestamp;
  }
}

/**
 * This API will read error entry from Error Log book
 * Critical errors     - Read from Log book Critical section     - Overwrite not possible
 * Info/Warning errors - Read from Log book Info/Warning section - Overwrite possible
 */
AUTOMATION_STATUS_t AUTOMATION_EH_ReadLogbook(AUTOMATION_EH_LOGBOOK_ENTRY_t* error_ptr,
    AUTOMATION_EH_LOGBOOK_SECTIONS_t section)
{
  AUTOMATION_STATUS_t status;
  AUTOMATION_EH_LOGBOOK_ENTRY_t * logbook;

  if (section == AUTOMATION_EH_LOGBOOK_SECTIONS_CS_LOGBOOK)
  {
    /* Read request for error log book critical section */
    if (AUTOMATION_EH_ErrorLogbook.cs_data_length > 0U)
    {
      /* Error entries are available */
      logbook = &AUTOMATION_EH_ErrorLogbook.error_logbook_ptr[AUTOMATION_EH_ErrorLogbook.cs_read_index++];
      if (AUTOMATION_EH_ErrorLogbook.cs_read_index == AUTOMATION_EH_LOGBOOK_CS_SIZE)
      {
        /* Log book Critical section ring buffer */
        AUTOMATION_EH_ErrorLogbook.cs_read_index = 0U;
      }
      AUTOMATION_EH_ErrorLogbook.cs_data_length--;
      status = AUTOMATION_STATUS_SUCCESS;
    }
    else
    {
      /* No more errors to read */
      status = AUTOMATION_STATUS_LOGBOOK_EMPTY;
      logbook = NULL;
    }
  }
  else
  {
    /* Read request for error log book Info/Warning section */
    if (AUTOMATION_EH_ErrorLogbook.info_data_length > 0U)
    {
      logbook = &AUTOMATION_EH_ErrorLogbook.error_logbook_ptr[AUTOMATION_EH_ErrorLogbook.info_read_index++];
      if (AUTOMATION_EH_ErrorLogbook.info_read_index == ((uint32_t)AUTOMATION_EH_LOGBOOK_INFO_SIZE << 1))
      {
        /* Log book info section ring buffer */
        AUTOMATION_EH_ErrorLogbook.info_read_index = AUTOMATION_EH_LOGBOOK_CS_SIZE;
      }
      AUTOMATION_EH_ErrorLogbook.info_data_length--;
      status = AUTOMATION_STATUS_SUCCESS;
    }
    else
    {
      /* No more errors to read */
      status = AUTOMATION_STATUS_LOGBOOK_EMPTY;
      logbook = NULL;
    }
  }

  if (logbook != NULL)
  {
    error_ptr->app_id = logbook->app_id;
    error_ptr->error_id = logbook->error_id;
    error_ptr->error_severity = logbook->error_severity;
    error_ptr->error_status = logbook->error_status;
    error_ptr->timestamp = logbook->timestamp;
  }

  return status;
}
#endif


/* register function block pointer */
AUTOMATION_STATUS_t AUTOMATION_FB_RegisterFunctionBlock(AUTOMATION_FB_HANDLE_t* const frame)
{
  AUTOMATION_STATUS_t status;
  if (AUTOMATION_Handle.fb_id >= (AUTOMATION_FB_APP_FUNCTION_BLOCKS + AUTOMATION_FB_ENABLED_FUNCTION_BLOCKS))
  {
    status = AUTOMATION_STATUS_NUM_FB_EXCEEDED;
  }
  else
  {
    AUTOMATION_FB_Table[AUTOMATION_Handle.fb_id++] = frame;
    status = AUTOMATION_STATUS_SUCCESS;
  }
  return status;
}

/*
 * Add the connection entries in the function block connect table
 */
AUTOMATION_STATUS_t AUTOMATION_FB_AddConnectionEntry(AUTOMATION_FB_HANDLE_t* const source_fb,
                                                     const uint8_t out_signal_num,
                                                     AUTOMATION_FB_HANDLE_t* const destination_fb,
                                                     const uint8_t in_signal_num)
{
  AUTOMATION_STATUS_t status = AUTOMATION_STATUS_SUCCESS;
  if (0U == AUTOMATION_Handle.fb_connect_table_data_length)
  {
    status = AUTOMATION_STATUS_CONNECT_TABLE_OVERFLOW;

  }
  else
  {
    if ((uint8_t) AUTOMATION_FB_CONNECT_TABLE_SIZE <= AUTOMATION_Handle.fb_connect_table_write_index)
    {
      AUTOMATION_Handle.fb_connect_table_write_index = 0U;
    }
    AUTOMATION_FB_Connect_Table[AUTOMATION_Handle.fb_connect_table_write_index].source_fb = source_fb;
    AUTOMATION_FB_Connect_Table[AUTOMATION_Handle.fb_connect_table_write_index].out_signal_num = out_signal_num;
    AUTOMATION_FB_Connect_Table[AUTOMATION_Handle.fb_connect_table_write_index].destination_fb = destination_fb;
    AUTOMATION_FB_Connect_Table[AUTOMATION_Handle.fb_connect_table_write_index].in_signal_num = in_signal_num;

    AUTOMATION_Handle.fb_connect_table_write_index++;
    AUTOMATION_Handle.fb_connect_table_data_length--;
  }
  return (status);
}

/*
 * Connect the the function block connection entries
 */
void AUTOMATION_FB_Connect()
{
  uint8_t read_index = AUTOMATION_Handle.fb_connect_table_read_index;

  while (AUTOMATION_Handle.fb_connect_table_data_length != AUTOMATION_FB_CONNECT_TABLE_SIZE)
  {
    *AUTOMATION_FB_Connect_Table[read_index].destination_fb->input_ptr[AUTOMATION_FB_Connect_Table[read_index].in_signal_num] =
        AUTOMATION_FB_Connect_Table[read_index].source_fb->output_ptr[AUTOMATION_FB_Connect_Table[read_index].out_signal_num];
    read_index++;
    AUTOMATION_Handle.fb_connect_table_data_length++;
    if ((uint8_t) AUTOMATION_FB_CONNECT_TABLE_SIZE <= read_index)
    {
      read_index = 0U;
    }
  }
  AUTOMATION_Handle.fb_connect_table_read_index = read_index;
}

/* initialize ramp generator target values*/
void AUTOMATION_FB_RampTargetValueCalc(AUTOMATION_FB_RAMPGEN_t* const ramphandle_ptr)
{
  int32_t scale = (AUTOMATION_PARAM_SCALE * AUTOMATION_PARAM_SCALE) / (int32_t)(*ramphandle_ptr->scale_ptr);

  /* Find the target values */
  ramphandle_ptr->startset_t = (ramphandle_ptr->config_ptr->startset * scale) / AUTOMATION_PARAM_SCALE;
  ramphandle_ptr->out_set_t = ramphandle_ptr->startset_t;

  ramphandle_ptr->endset_t = (ramphandle_ptr->config_ptr->endset * scale) / AUTOMATION_PARAM_SCALE;

  ramphandle_ptr->linear_startvalue_t =
      (ramphandle_ptr->config_ptr->linear_startvalue * scale) / AUTOMATION_PARAM_SCALE;

  ramphandle_ptr->linear_endvalue_t = (ramphandle_ptr->config_ptr->linear_endvalue * scale) / AUTOMATION_PARAM_SCALE;

  ramphandle_ptr->counter_t = (ramphandle_ptr->counter * ((*ramphandle_ptr->scale_ptr))) >> 15U;

  ramphandle_ptr->slewrate_counter_t = (ramphandle_ptr->config_ptr->slewrate_counter * (*ramphandle_ptr->scale_ptr))
      / (ramphandle_ptr->config_ptr->time_constant);

  ramphandle_ptr->slewrate_endset_t = (ramphandle_ptr->config_ptr->slewrate_endset
      * (int32_t) ramphandle_ptr->config_ptr->time_constant) / ((int32_t)(*ramphandle_ptr->scale_ptr));

  ramphandle_ptr->slewrate_end = ramphandle_ptr->slewrate_endset_t;
}

/* initialize ramp generator target values*/
void AUTOMATION_FB_RampInit(AUTOMATION_FB_HANDLE_t* const rampfb_ptr)
{
  AUTOMATION_FB_RAMPGEN_t* ramphandle_ptr = rampfb_ptr->config_ptr;
  ramphandle_ptr->out_set_t = ramphandle_ptr->startset_t;
}

/* Set ramp start value for ramp */
AUTOMATION_STATUS_t AUTOMATION_FB_SetRampStartValue(AUTOMATION_FB_RAMPGEN_t* const ramphandle_ptr, int32_t start_value)
{
  int32_t target_value;
  int32_t difference;
  AUTOMATION_STATUS_t status;

  if ((start_value > AUTOMATION_FB_RAMP_MIN) && (start_value < AUTOMATION_FB_RAMP_MAX))
  {
    target_value = (start_value * AUTOMATION_PARAM_SCALE) / (int32_t)(*ramphandle_ptr->scale_ptr);
    ramphandle_ptr->out_set_t = (target_value);
    ramphandle_ptr->startset_t = (target_value);
    if (AUTOMATION_FB_RAMPTYPE_SCURVE == ramphandle_ptr->config_ptr->ramp_type)
    {
      difference = (*(ramphandle_ptr->endset_ptr) - ramphandle_ptr->startset_t);
      ramphandle_ptr->linear_startvalue_t = (ramphandle_ptr->startset_t)
          + ((difference * (int32_t) ramphandle_ptr->config_ptr->ratio) / 100);
      ramphandle_ptr->linear_endvalue_t = *(ramphandle_ptr->endset_ptr)
          - ((difference * (int32_t) ramphandle_ptr->config_ptr->ratio) / 100);
    }
    status = AUTOMATION_STATUS_SUCCESS;
  }
  else
  {
    status = AUTOMATION_STATUS_INVALID_PARAM;
  }
  return status;
}

/* Set ramp end value for ramp */
AUTOMATION_STATUS_t AUTOMATION_FB_SetRampEndValue(AUTOMATION_FB_RAMPGEN_t* const ramphandle_ptr, int32_t end_value)
{
  int32_t difference;
  AUTOMATION_STATUS_t status;
  if ((end_value > AUTOMATION_FB_RAMP_MIN) && (end_value < AUTOMATION_FB_RAMP_MAX))
  {
    *(ramphandle_ptr->endset_ptr) = (end_value * AUTOMATION_PARAM_SCALE) / (int32_t)(*ramphandle_ptr->scale_ptr);
    if (AUTOMATION_FB_RAMPTYPE_SCURVE == ramphandle_ptr->config_ptr->ramp_type)
    {
      difference = (*(ramphandle_ptr->endset_ptr) - ramphandle_ptr->startset_t);
      ramphandle_ptr->linear_startvalue_t = (ramphandle_ptr->startset_t)
          + ((difference * (int32_t) ramphandle_ptr->config_ptr->ratio) / 100);
      ramphandle_ptr->linear_endvalue_t = *(ramphandle_ptr->endset_ptr)
          - ((difference * (int32_t) ramphandle_ptr->config_ptr->ratio) / 100);
    }
    status = AUTOMATION_STATUS_SUCCESS;
  }
  else
  {
    status = AUTOMATION_STATUS_INVALID_PARAM;
  }
  return status;
}

/* Set ramp slew rate for linear ramp */
AUTOMATION_STATUS_t AUTOMATION_FB_SetLinearRampSlewRate(AUTOMATION_FB_RAMPGEN_t* const ramphandle_ptr,
                                                        uint32_t slew_rate)
{
  AUTOMATION_STATUS_t status;
  if ((slew_rate > AUTOMATION_FB_RAMP_SLEWRATE_MIN) && (slew_rate < AUTOMATION_FB_RAMP_SLEWRATE_MAX))
  {
    ramphandle_ptr->counter = (ramphandle_ptr->config_ptr->time_constant) / (slew_rate);
    ramphandle_ptr->counter_t = (ramphandle_ptr->counter * ((*ramphandle_ptr->scale_ptr))) >> 15U;
    status = AUTOMATION_STATUS_SUCCESS;
  }
  else
  {
    status = AUTOMATION_STATUS_INVALID_PARAM;
  }
  return status;
}

/* Set ramp slew rate for S ramp */
AUTOMATION_STATUS_t AUTOMATION_FB_SetSRampSlewRate(AUTOMATION_FB_RAMPGEN_t* const ramphandle_ptr, uint32_t slew_rate)
{
  AUTOMATION_STATUS_t status;
  uint32_t counter;
  if ((slew_rate > AUTOMATION_FB_RAMP_SLEWRATE_MIN) && (slew_rate < AUTOMATION_FB_RAMP_SLEWRATE_MAX))
  {
    if (ramphandle_ptr->config_ptr->time_constant != 0U)
    {
      counter = (ramphandle_ptr->config_ptr->time_constant) / slew_rate;
      ramphandle_ptr->slewrate_counter_t = (counter * (*ramphandle_ptr->scale_ptr))
          / (ramphandle_ptr->config_ptr->time_constant);
    }
    else
    {
      status = AUTOMATION_STATUS_FAILURE;
    }
    status = AUTOMATION_STATUS_SUCCESS;
  }
  else
  {
    status = AUTOMATION_STATUS_INVALID_PARAM;
  }
  return status;
}

/* Get ramp start value for ramp */
int32_t AUTOMATION_FB_GetRampStartValue(AUTOMATION_FB_RAMPGEN_t* const ramphandle_ptr)
{
  int32_t target_value;

  target_value = (ramphandle_ptr->startset_t * (int32_t)(*ramphandle_ptr->scale_ptr)) / AUTOMATION_PARAM_SCALE;

  return target_value;
}

/* Get ramp end value for ramp */
int32_t AUTOMATION_FB_GetRampEndValue(AUTOMATION_FB_RAMPGEN_t* const ramphandle_ptr)
{
  int32_t target_value;

  target_value = (*(ramphandle_ptr->endset_ptr) * (int32_t)(*ramphandle_ptr->scale_ptr)) / AUTOMATION_PARAM_SCALE;

  return target_value;
}

/* Get ramp slew rate for linear ramp */
uint32_t AUTOMATION_FB_GetLinearRampSlewRate(AUTOMATION_FB_RAMPGEN_t* const ramphandle_ptr)
{
  uint32_t target_value;
  if (ramphandle_ptr->counter_t != 0U)
  {
    target_value =
      ((ramphandle_ptr->config_ptr->time_constant * (*ramphandle_ptr->scale_ptr)) / ramphandle_ptr->counter_t) >> 15U;
  }
  else
  {
    target_value = 0U;
  }
  return target_value;

}

/* Get ramp slew rate for S ramp */
uint32_t AUTOMATION_FB_GetSRampSlewRate(AUTOMATION_FB_RAMPGEN_t* const ramphandle_ptr)
{
  uint32_t target_value;

  if ((ramphandle_ptr->counter_t != 0U) && (ramphandle_ptr->config_ptr->time_constant != 0U))
  {
    target_value = (uint32_t)(
      (ramphandle_ptr->config_ptr->time_constant * (*ramphandle_ptr->scale_ptr))
          / (ramphandle_ptr->slewrate_counter_t * ramphandle_ptr->config_ptr->time_constant));
  }
  else
  {
    target_value = 0U;
  }

  return target_value;
}

/*
 * generates the linear ramp
 */
void AUTOMATION_FB_LinearRamp(AUTOMATION_FB_RAMPGEN_t* const ramphandle_ptr)
{
  ramphandle_ptr->counter_t = (ramphandle_ptr->counter * (*(ramphandle_ptr->scale_ptr))) >> AUTOMATION_Q15;
  /*Update the velocity reference value.*/
  if (ramphandle_ptr->index > ramphandle_ptr->counter_t)
  {
    if (*(ramphandle_ptr->endset_ptr) > ramphandle_ptr->out_set_t)
    {
      ramphandle_ptr->out_set_t++;
    }
    else if (*(ramphandle_ptr->endset_ptr) < ramphandle_ptr->out_set_t)
    {
      ramphandle_ptr->out_set_t--;
    }
    else
    {

    }
    ramphandle_ptr->index = 0U;
  }
  ramphandle_ptr->index++;
}

/*
 * It generates the S-curve ramp
 */
void AUTOMATION_FB_ScurveRamp(AUTOMATION_FB_RAMPGEN_t* const ramphandle_ptr)
{
  uint32_t difference;
  int32_t dir = -1;

  ramphandle_ptr->counter_t = (ramphandle_ptr->counter * (*(ramphandle_ptr->scale_ptr))) >> AUTOMATION_Q15;
  ramphandle_ptr->slewrate_counter_t = ((ramphandle_ptr->config_ptr->slewrate_counter) * (*(ramphandle_ptr->scale_ptr)))
      / (ramphandle_ptr->config_ptr->time_constant);

  /* Find the change in the end reference */
  difference = ((uint32_t) * ramphandle_ptr->endset_ptr - (uint32_t) ramphandle_ptr->prev_endset_t);
  if (difference != 0U)
  {
    ramphandle_ptr->prev_endset_t = *(ramphandle_ptr->endset_ptr);
    ramphandle_ptr->diff = *(ramphandle_ptr->endset_ptr) - ramphandle_ptr->out_set_t;

    /* for ramp down, calculate start and end values */
    if (ramphandle_ptr->diff < 0)
    {
      dir = dir * ramphandle_ptr->diff;
      difference = ((uint32_t) dir);
      ramphandle_ptr->linear_startvalue_t = *(ramphandle_ptr->endset_ptr)
          + (((int32_t) difference * (int32_t) ramphandle_ptr->config_ptr->ratio) / 100);
      ramphandle_ptr->linear_endvalue_t = (ramphandle_ptr->out_set_t)
          - (((int32_t) difference * (int32_t) ramphandle_ptr->config_ptr->ratio) / 100);
    }
    /* for ramp up, calculate start and end values */
    else
    {
      difference = (uint32_t) ramphandle_ptr->diff;
      ramphandle_ptr->linear_startvalue_t = (ramphandle_ptr->out_set_t)
          + (((int32_t) difference * (int32_t) ramphandle_ptr->config_ptr->ratio) / 100);
      ramphandle_ptr->linear_endvalue_t = *(ramphandle_ptr->endset_ptr)
          - (((int32_t) difference * (int32_t) ramphandle_ptr->config_ptr->ratio) / 100);
    }
  }

  /*Update the target value.*/
  AUTOMATION_FB_LinearRamp(ramphandle_ptr);

  /*Update the acceleration value.*/
  if ((ramphandle_ptr->out_set_t < ramphandle_ptr->linear_startvalue_t)
      || (ramphandle_ptr->out_set_t > ramphandle_ptr->linear_endvalue_t))
  {
    AUTOMATION_FB_AccelerationRamp(ramphandle_ptr);
  }
}

static void AUTOMATION_FB_AccelerationRamp(AUTOMATION_FB_RAMPGEN_t* const ramphandle_ptr)
{
  int32_t dir = -1;
  if (ramphandle_ptr->slewrate_index > ramphandle_ptr->slewrate_counter_t)
  {
    if ((ramphandle_ptr->slewrate_end) > ramphandle_ptr->slewrate_set_t)
    {
      ramphandle_ptr->slewrate_set_t++;
    }
    else if ((ramphandle_ptr->slewrate_end) < ramphandle_ptr->slewrate_set_t)
    {
      ramphandle_ptr->slewrate_set_t--;
    }
    else
    {
      /*Do nothing*/
    }
    ramphandle_ptr->slewrate_index = 0U;

    dir = dir * ramphandle_ptr->slewrate_set_t;
    /* Update the velocity counter value based upon acceleration value */
    if (ramphandle_ptr->slewrate_set_t < 0)
    {
      ramphandle_ptr->counter = ramphandle_ptr->config_ptr->time_constant / ((uint32_t) dir);
    }
    else if (ramphandle_ptr->slewrate_set_t != 0)
    {
      ramphandle_ptr->counter = ramphandle_ptr->config_ptr->time_constant / ((uint32_t) ramphandle_ptr->slewrate_set_t);
    }
    else
    {
      /*Do nothing*/
    }
  }
  ramphandle_ptr->slewrate_index++;

  /* update the slewrate end value */
  if (ramphandle_ptr->diff < 0)
  {
    if ((ramphandle_ptr->out_set_t < ramphandle_ptr->linear_startvalue_t))
    {
      ramphandle_ptr->slewrate_end = ramphandle_ptr->slewrate_startset_t;
    }
    else if (ramphandle_ptr->out_set_t > ramphandle_ptr->linear_endvalue_t)
    {
      ramphandle_ptr->slewrate_end = -ramphandle_ptr->slewrate_endset_t;
    }
    else
    {
      /*Do nothing*/
    }
  }
  else
  {
    if ((ramphandle_ptr->out_set_t < ramphandle_ptr->linear_startvalue_t))
    {
      ramphandle_ptr->slewrate_end = ramphandle_ptr->slewrate_endset_t;
    }
    else if (ramphandle_ptr->out_set_t > ramphandle_ptr->linear_endvalue_t)
    {
      ramphandle_ptr->slewrate_end = ramphandle_ptr->slewrate_startset_t;
    }
    else
    {
      /*Do nothing*/
    }
  }
}

/**
 * Function block handler executed when function block system timer is expired
 */
void AUTOMATION_FB_FunctionBlockSequencer(void)
{
  uint8_t count;
  for (count = 0U; count < AUTOMATION_FB_EXECUTED_FUNCTION_BLOCKS; count++)
  {
    if (AUTOMATION_FB_ExecutionOrderList[count] != NULL)
    {
      /* Call the function associated with function block */
      AUTOMATION_FB_ExecutionOrderList[count]->function(AUTOMATION_FB_ExecutionOrderList[count]->config_ptr);
    }
  }
}



/**
 * This function register Drive state machine handler.
 */
AUTOMATION_STATUS_t AUTOMATION_SM_RegisterStateMachine(AUTOMATION_SM_t* statemachine, uint8_t app_id)
{
  AUTOMATION_STATUS_t status;
  if (app_id > AUTOMATION_NUM_APPS)
  {
    status = AUTOMATION_STATUS_FAILURE;
  }
  else
  {
    /* Register Drive Statemachine interface */
    AUTOMATION_SM_Table[app_id] = statemachine;
    status = AUTOMATION_STATUS_SUCCESS;
  }

  return status;
}
/**
 * This function return Drive State machine status.
 */
uint8_t AUTOMATION_SM_GetState(uint8_t app_id)
{
  uint8_t state = 255U;

  if (NULL != AUTOMATION_SM_Table[app_id])
  {
    state = AUTOMATION_SM_Table[app_id]->current_state;
  }
  return state;
}

/* request to change the state */
void AUTOMATION_SM_RequestState(AUTOMATION_SM_t* statemachine, uint8_t new_state)
{
  statemachine->requested_state = new_state;
  statemachine->transition_request = 1U;
}

/* Drive State machine scheduler */
void AUTOMATION_SM_Handler(AUTOMATION_SM_t * statemachine)
{
  if (NULL != statemachine)
  {
    if (statemachine->transition_request)
    {
      /* New state was requested - execute the exit function of old state */
      if (NULL != statemachine->states[statemachine->current_state].state_exit_call)
      {
        statemachine->states[statemachine->current_state].state_exit_call((void*) statemachine->app_handler);
      }

      if (statemachine->current_state != statemachine->requested_state)
      {
        /* change state */
        statemachine->current_state = statemachine->requested_state;
        /* execute the entry function of new state */
        if (NULL != statemachine->states[statemachine->current_state].state_entry_call)
        {
          statemachine->states[statemachine->current_state].state_entry_call((void*) statemachine->app_handler);
        }

        if (NULL != statemachine->states[statemachine->current_state].state_action_call)
        {
          if (statemachine->execute_action)
          {
            /* immediate execution of action function was requested
             execute the action function of new state */
            statemachine->states[statemachine->current_state].state_action_call((void*) statemachine->app_handler);
          }
        }
      }
      statemachine->transition_request = 0U;
    }
    else
    {
      if (NULL != statemachine->states[statemachine->current_state].state_action_call)
      {
        statemachine->states[statemachine->current_state].state_action_call((void*) statemachine->app_handler);
      }
    }

  }
}


