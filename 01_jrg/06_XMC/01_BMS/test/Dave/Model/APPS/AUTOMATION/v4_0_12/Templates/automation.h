/**
 * @file automation.h
 * @date 2021-01-08
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * AUTOMATION v4.0.12 - Provides mechanism to connect two APPs using function block processor.
 * This supports online parameter update and error logging.  This consumes System Timer APP and
 * provides task registration feature. It also provides state machine.
 *
 * Copyright (c) 2015-2020, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-20:
 *     - Initial version
 *
 * 2015-06-20:
 *     - APIs added to set and get ramp parameters
 *
 * 2021-01-08:
 *     - Modified check for minimum XMCLib version
 *
 * @endcond
 *
 */
#ifndef AFW_H_
#define AFW_H_



/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#include "xmc_common.h"
#include "automation_conf.h"
#include "SYSTIMER/systimer.h"

 /**********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/
#define AUTOMATION_XMC_LIB_MAJOR_VERSION 2
#define AUTOMATION_XMC_LIB_MINOR_VERSION 0
#define AUTOMATION_XMC_LIB_PATCH_VERSION 0

#if !((XMC_LIB_MAJOR_VERSION > AUTOMATION_XMC_LIB_MAJOR_VERSION) ||\
      ((XMC_LIB_MAJOR_VERSION == AUTOMATION_XMC_LIB_MAJOR_VERSION) && (XMC_LIB_MINOR_VERSION > AUTOMATION_XMC_LIB_MINOR_VERSION)) ||\
      ((XMC_LIB_MAJOR_VERSION == AUTOMATION_XMC_LIB_MAJOR_VERSION) && (XMC_LIB_MINOR_VERSION == AUTOMATION_XMC_LIB_MINOR_VERSION) && (XMC_LIB_PATCH_VERSION >= AUTOMATION_XMC_LIB_PATCH_VERSION)))
#error "AUTOMATION requires XMC Peripheral Library v2.0.0 or higher"

/** Error logbook critical section size = logbook size/2 */
#define AUTOMATION_EH_LOGBOOK_CS_SIZE    (AUTOMATION_EH_LOGBOOK_SIZE/2U)
/** Error Logbook Information/Warning section size = logbook size/2 */
#define AUTOMATION_EH_LOGBOOK_INFO_SIZE  (AUTOMATION_EH_LOGBOOK_SIZE/2U)
/** Bit interface error register with this ID in log book */
#define AUTOMATION_EH_BIT_INTERFACE_ID      (0xFF)
/** Error Handler temporary buffer */
#define AUTOMATION_EH_APPBUF_SIZE       (5U)
/** All error reporting will happen on this interface */
#define AUTOMATION_EH_COM_INTERFACE_ID   (0U)
/** Scaling factor */
#define AUTOMATION_Q15                    (15U)

 /**********************************************************************************************************************
 * ENUMS
 **********************************************************************************************************************/
   /**
    * @ingroup AUTOMATION_enumerations
   * @{
   */
  /**
   * State of the App
   */
typedef enum AUTOMATION_STATE
{
  AUTOMATION_STATE_UNINITIALIZED,            /**< Default state after power on reset */
  AUTOMATION_STATE_INITIALIZED               /**< INITIALIZED state after init function execution */
} AUTOMATION_STATE_t;

/**
 * Enumerates the automation framework error id's
 */
typedef enum AUTOMATION_STATUS
{
  AUTOMATION_STATUS_SUCCESS,                     /**< No errors */
  AUTOMATION_STATUS_FAILURE,                     /**< API execution failed */
  AUTOMATION_STATUS_INVALID_PARAM,               /**< Input argument is not within the range */
  AUTOMATION_STATUS_PERMISSION_DENIED,           /**< Parameter access is denied */
  AUTOMATION_STATUS_NUM_APPS_EXCEEDED,           /**< Number of Apps exceeded automation framework limit */
  AUTOMATION_STATUS_NUM_INTERFACE_EXCEEDED,      /**< Number of interfaces exceeded automation framework limit */
  AUTOMATION_STATUS_NUM_PARAM_EXCEEDED,          /**< Max. number of parameters in parameter table per App exceeded */
  AUTOMATION_STATUS_NUM_FB_EXCEEDED,             /**< Number of function blocks exceeded */
  AUTOMATION_STATUS_CONNECT_TABLE_OVERFLOW,      /**< Function block connect table overflow */
  AUTOMATION_STATUS_LOGBOOK_CS_FULL,             /**< Error handler log book critical section full */
  AUTOMATION_STATUS_LOGBOOK_INFO_FULL,           /**< Error handler log book Info/Warning section full */
  AUTOMATION_STATUS_LOGBOOK_EMPTY,               /**< No More data to read */
  AUTOMATION_STATUS_INVALID_INTERFACE_ID         /**< Invalid interface ID */
}AUTOMATION_STATUS_t;

/**
 * Parameter command -  to Read or Write the parameter.
 */
typedef enum AUTOMATION_PH_COMMAND
{
  AUTOMATION_PH_COMMAND_SET,     /**< To write the parameter value */
  AUTOMATION_PH_COMMAND_GET      /**< To read the parameter value */
} AUTOMATION_PH_COMMAND_t;

/**
 * Status of the parameter buffer
 */
typedef enum AUTOMATION_PH_STATUS
{
  AUTOMATION_PH_STATUS_READY,     /**< Parameter buffer entry is executed and result is ready to read by the interface */
  AUTOMATION_PH_STATUS_ACTIVE,   /**< Valid entry is present in the parameter buffer */
  AUTOMATION_PH_STATUS_FAILED    /**< Request execution failed - value can not be assigned to the parameter*/
}AUTOMATION_PH_STATUS_t;

/**
 * Enumerates the permission to update the parameter.
 */
typedef enum AUTOMATION_PH_WRITE_ACCESS
{
  AUTOMATION_PH_WRITE_ACCESS_NOT_ALLOWED,          /**< Write operation not allowed */
  AUTOMATION_PH_WRITE_ACCESS_ALLOWED               /**< Write operation is allowed under all the conditions */
} AUTOMATION_PH_WRITE_ACCESS_t;

/**
 * Enumerates the error severity level for Error Handler
 */
typedef enum AUTOMATION_EH_ERROR_SEVERITY
{
  AUTOMATION_EH_ERROR_SEVERITY_INFO,             /**< Informative message */
  AUTOMATION_EH_ERROR_SEVERITY_WARNING,          /**< Warning message */
  AUTOMATION_EH_ERROR_SEVERITY_ERROR,            /**< Error in execution */
  AUTOMATION_EH_ERROR_SEVERITY_CRITICAL,         /**< Critical error */
  AUTOMATION_EH_ERROR_SEVERITY_SAFETY_CRITICAL   /**< Safety critical error */
}AUTOMATION_EH_ERROR_SEVERITY_t;

/**
 * Enumerates the status of the error id for Error Handler
 */
typedef enum AUTOMATION_EH_ERROR_STATUS
{
  AUTOMATION_EH_ERROR_STATUS_CLEARED,     /**< Error id is cleared */
  AUTOMATION_EH_ERROR_STATUS_SET          /**< Error id is set */
}AUTOMATION_EH_ERROR_STATUS_t;

/**
 * Enumerates the section of Error Log book.
 */
typedef enum AUTOMATION_EH_LOGBOOK_SECTIONS
{
  AUTOMATION_EH_LOGBOOK_SECTIONS_CS_LOGBOOK,     /**< Error log book critical section*/
  AUTOMATION_EH_LOGBOOK_SECTIONS_INFO_LOGBOOK    /**< Error log book info/warning section*/
}AUTOMATION_EH_LOGBOOK_SECTIONS_t;

/**
 * Enumerates the ramp generation type
 */
typedef enum AUTOMATION_FB_RAMPTYPE
{
  AUTOMATION_FB_RAMPTYPE_LINEAR,    /**< Linear ramp - velocity increased linearly with time */
  AUTOMATION_FB_RAMPTYPE_SCURVE    /**< S-curve ramp - linear acceleration - constant acceleration - linear deceleration curve */
} AUTOMATION_FB_RAMPTYPE_t;

/**
 * enumerates the call rate of the ramp function block
 */
typedef enum AUTOMATION_FB_RAMP_CALLRATE
{
  AUTOMATION_FB_RAMP_CALLRATE_SVP_TASK,  /**< Ramp is executed in every set value processor task */
  AUTOMATION_FB_RAMP_CALLRATE_FB_TASK,   /**< Ramp is executed in every function block handler */
  AUTOMATION_FB_RAMP_CALLRATE_EXTERNAL   /**< Ramp is executed externally by the user */
}AUTOMATION_FB_RAMP_CALLRATE_t;

/**
 * enumerates the input parameters for the Ramp Function Block
 */
typedef enum AUTOMATION_FB_IN_SIGNAL
{
  AUTOMATION_FB_IN_SIGNAL_ENDREF,  /**< end point of the ramp */
  AUTOMATION_FB_IN_SIGNAL_SCALE    /**< scaling value */
}AUTOMATION_FB_IN_SIGNAL_t;

/**
 * enumerates the output parameters for the Ramp Function Block
 */
typedef enum AUTOMATION_FB_OUT_SIGNAL
{
  AUTOMATION_FB_OUT_SIGNAL_REF  /**< instantaneous output of the ramp */
}AUTOMATION_FB_OUT_SIGNAL_t;

  /**
   * @}
   */
/**********************************************************************************************************************
* DATA STRUCTURES
**********************************************************************************************************************/
  /**
   * @ingroup AUTOMATION_datastructures
   * @{
   */

/**
 * APP Table maintains the relation between the app_id and APP instance number.
 */
typedef struct AUTOMATION_APP_TABLE
{
  void*       apphandle_ptr;        /**< App handle pointer */
  const char* app_name_ptr;         /**< Unique name of the App */
} AUTOMATION_APP_TABLE_t;

/**
 * Task Function pointer type definition - function to be called when task timer expires
 * param funct_ptr structure pointer as argument
 * return void
 */
typedef void (*AUTOMATION_TASK_FUNCT_PTR_t)(void* funct_ptr);

/**
 * List of the tasks and task execution timings.
 */
typedef struct AUTOMATION_TASK_TABLE
{
  AUTOMATION_TASK_FUNCT_PTR_t task_ptr;      /**< Function pointer to be called when timer expires */
  uint32_t                    period;        /**< Task execution time */
  uint32_t                    task_timer_id; /**< System timer ID of the task - assigned when system timer is created */
}AUTOMATION_TASK_TABLE_t;

/**
 * Automation APP handle - Saves the global IDs and index of the automation framework
 */
typedef struct AUTOMATION
{
  SYSTIMER_t *      const systimer_ptr;                 /**< System timer APP handle pointer */
  uint32_t                fb_timer_id;                  /**< system timer id for function block processor */
  uint32_t                eh_timer_id;                  /**< system timer id for error handler */
  AUTOMATION_STATE_t      state;                        /**< State of the system timer initialization */
  uint8_t                 app_id;                       /**< Index to register apps */
  uint8_t                 interface_id;                 /**< Index to register interface apps */
  uint8_t                 fb_id;                        /**< Index to register function blocks */
  uint8_t                 task_id;                      /**< Index to register tasks */
  uint8_t                 fb_connect_table_write_index; /**< Index to add function block connection entry */
  uint8_t                 fb_connect_table_read_index;  /**< Index to read from the function block connect table */
  uint8_t                 fb_connect_table_data_length; /**< Empty space in the function block connect table */

}AUTOMATION_t;

/****************************** Automation Parameter Handler Structures *******************************************************/
/**
 * Parameter Set Function pointer type definition - function to be called to set the parameter
 */
typedef uint8_t (*AUTOMATION_PH_SET_FUNCT_PTR_t)(void* funct_ptr, int32_t value);

/**
 * Parameter Table strcuture - contains the information about a parameter : range, permission, scale.
 * Each App maintains the array of this structure type for all the parameters.
 */
typedef struct AUTOMATION_PH_PARAM_ENTRY
{
  int32_t*                      param_addr;  /**< parameter value */
  int32_t                       minval;      /**< Minimum limit of the parameter */
  int32_t                       maxval;      /**< Maximum limit of the parameter */
  uint32_t                      scale;       /**< Scale factor - to convert from physical value to target value  */
  uint32_t                      inv_scale;   /**< Inverse scale factor - to convert from target value to physical value */
  AUTOMATION_PH_SET_FUNCT_PTR_t setptr;      /**< Function pointer for set parameter value */
  uint8_t                       write_access; /**< Permission to change the parameter value runtime AUTOMATION_PH_WRITE_ACCESS_t enum can be used*/
  uint8_t                       size;         /**< size of the parameter */
} AUTOMATION_PH_PARAM_ENTRY_t;

/**
 * Parameter buffer structure - interface has to fill this structure to send the command.
 * Request will be updated in the same structure
 * Array of this data type is used to store parameter commands from multiple interfaces
 * AUTOMATION_PH_PARAMETER_t AUTOMATION_PH_Parameter_Buf[AUTOMATION_NUM_INTERFACES].
 */
typedef struct AUTOMATION_PH_PARAMETER
{
  int32_t                   value;       /**< Value of the parameter to be read or written */
  int32_t*                  var_address; /**< variable address for data copy */
  AUTOMATION_PH_COMMAND_t   command;     /**< SET or GET function */
  AUTOMATION_PH_STATUS_t    status;     /**< Status of the set or get operation */
  uint8_t                   app_id;     /**< App ID */
  uint8_t                   param_id;   /**< Parameter ID */
  uint8_t                   size;       /**< Number of bytes to copy */
} AUTOMATION_PH_PARAMETER_t;

/****************************** Automation Error Handler Structures *******************************************************/
/**
 * Function pointer type definition for the error handler callback function
 * param handle_ptr function to be called to take action on error
 * return void
 */
typedef void(*AUTOMATION_EH_FUNCT_PTR_t)(void* handle_ptr);

/**
 * Function pointer type definition for reporting error to the communication interface
 * param app_id index of the app
 * param error_id error code
 * param error_severity severity of the error
 * param status error is set or cleared
 * return none
 */
typedef void (*AUTOMATION_EH_REPORTING_FUNCT_PTR_t)(uint8_t app_id, uint8_t error_id,
    uint8_t error_severity, uint8_t status);

/**
 * Error Report structure - interface to which error is to be reported by calling registered callback function
 */
typedef struct AUTOMATION_EH_ERROR_REPORT
{
  uint8_t                             eh_error_report_interface_id; /**< interface ID to which all errors will be reported */
  AUTOMATION_EH_REPORTING_FUNCT_PTR_t eh_report_callback_ptr;       /**< Callback function of the error reporting interface ID */
}AUTOMATION_EH_ERROR_REPORT_t;

/**
 * Error table -  information about the error
 */
typedef struct AUTOMATION_EH_TABLE_ENTRY
{
  AUTOMATION_EH_FUNCT_PTR_t       error_functptr;    /**< Callback function to be called when error status is updated */
  void*                           error_callbackarg; /**< Argument for the callback function */
  uint8_t                         error_id;          /**< Error code */
  uint8_t                         error_status;      /**< Status of the error set or cleared. AUTOMATION_EH_ERROR_STATUS_t type can be used*/
  uint8_t                         error_severity;    /**< Severity of the error. AUTOMATION_EH_ERROR_SEVERITY_t type can be used*/
}AUTOMATION_EH_TABLE_ENTRY_t;

/**
 * App Error Table - maintain the pointer to the app error table
 */
typedef struct AUTOMATION_EH_APP_TABLE
{
  AUTOMATION_EH_TABLE_ENTRY_t *app_error_table_ptr;    /**< Pointer to the error table of the app */
  uint8_t                      app_id;                 /**< App ID assigned by the Automation */
  uint8_t                      app_error_table_length; /**< size of the error table of the app */
}AUTOMATION_EH_APP_TABLE_t;

/**
 * Maintains central information of errors.
 */
typedef struct AUTOMATION_EH_ERROR_TABLE
{
  uint32_t                  eh_error_table_index;                /* automation error table index */
  AUTOMATION_EH_APP_TABLE_t eh_error_table[AUTOMATION_NUM_APPS]; /* App error table in automation */

}AUTOMATION_EH_ERROR_TABLE_t;

/**
 * Contains information about Bit interface Error table.
 */
typedef struct AUTOMATION_EH_BIT_ERROR_TABLE
{
  AUTOMATION_EH_FUNCT_PTR_t       error_functptr;    /**< Callback functions to be called when error status is updated */
  void*                           error_callbackarg; /**< Argument for the callback function */
  uint8_t                         error_id;          /**< Error code */
  uint8_t                         error_status;      /**< Status of the error set or cleared. AUTOMATION_EH_ERROR_STATUS_t type can be used*/
  uint8_t                         error_severity;    /**< Severity of the error. AUTOMATION_EH_ERROR_SEVERITY_t type can be used*/
}AUTOMATION_EH_BIT_ERROR_TABLE_t;

/**
 *This structure consists of the error log book entry. Array of this data type will be used.
 * AUTOMATION_EH_LOGBOOK_ENTRY_t log book[AUTOMATION_EH_LOGBOOK_SIZE].
 */
typedef struct AUTOMATION_EH_LOGBOOK_ENTRY
{
  uint32_t                       timestamp;       /**< Time stamp of the error */
  uint8_t                        app_id;          /**< App index */
  uint8_t                        error_id;       /**< Error code */
  uint8_t                        error_severity;  /**<Severity of the error. AUTOMATION_EH_ERROR_SEVERITY_t type can be used*/
  uint8_t                        error_status;    /**< Status of the error set or cleared. AUTOMATION_EH_ERROR_STATUS_t type can be used*/
}AUTOMATION_EH_LOGBOOK_ENTRY_t;

/**
 * Maintains error log book entries depends upon severity.
 */
typedef struct AUTOMATION_EH_LOGBOOK
{
  uint8_t                       cs_read_index;        /**< Read index for critical section in Error Log book */
  uint8_t                       cs_write_index;       /**< Write index for critical section in Error Log book */
  uint8_t                       cs_data_length;       /**< Critical section data length */
  uint8_t                       info_read_index;      /**< Read index for Information/Warning section in Error Log book */
  uint8_t                       info_write_index;     /**< Write index for Information/Warning section in Error Log book */
  uint8_t                       info_data_length;     /**< Info section data length */
  AUTOMATION_EH_LOGBOOK_ENTRY_t* error_logbook_ptr;   /**< Log book entry structure */
}AUTOMATION_EH_LOGBOOK_t;

/**
 * Temporary buffer structure for non critical errors reported by Apps.
 */
typedef struct AUTOMATION_EH_APPERROR_BUFFER
{
  uint8_t                       read_index;           /**< Read index for Information/Warning section in Error Log book */
  uint8_t                       write_index;          /**< Write index for Information/Warning section in Error Log book */
  uint8_t                       data_length;          /**< Info section data length */
  AUTOMATION_EH_LOGBOOK_ENTRY_t* error_logbook_ptr;   /**< Log book entry structure */
}AUTOMATION_EH_APPERROR_BUFFER_t;

/**
 * Error bit interface - to save the error word and status word
 */
typedef struct AUTOMATION_EH_BIT_INTERFACE
{
  uint32_t    error_word;     /**< value of the error word reported by the interface */
  uint32_t    status_word;    /**< status of the error word whether action is taken on the reported error */
}AUTOMATION_EH_BIT_INTERFACE_t;

/*******************************  FUNCTION BLOCK PROCESSOR  ********************************************************/
/**
 * Function pointer type definition for the functions of the function block
 * param fb_ptr function block pointer
 * return void
 */
typedef void (*AUTOMATION_FB_FUNCT_PTR_t)(void* fb_ptr);

/**
 * Function block handle. Each function block has to provide this structure of input, output variables.
 * Array of this data type will be used for
 * AUTOMATION_FB_HANDLE_t* AUTOMATION_FB_List[]
 * AUTOMATION_FB_HANDLE_t* AUTOMATION_FB_ExecutionOrderList[]
 */
typedef struct AUTOMATION_FB_HANDLE
{
  int32_t **const*                input_ptr;  /**< Pointer to the array of pointers of the input variables */
  int32_t *const*                 output_ptr; /**< Pointer to the array of output variables */
  void * const                    config_ptr; /**< pointer to structure containing configuration parameters */
  AUTOMATION_FB_FUNCT_PTR_t const function;   /**< Function pointer of the function associated with the function block */
  const char* const               name;       /**< Unique name of the function block */
} AUTOMATION_FB_HANDLE_t;

/**
 * Maintains the connections between function blocks.
 */
typedef struct AUTOMATION_FB_CONNECTION_TABLE
{
  AUTOMATION_FB_HANDLE_t*   source_fb;      /**< Function block pointer providing output data in the connection */
  AUTOMATION_FB_HANDLE_t*   destination_fb; /**< Function block pointer which accepts the input data in the connection */
  uint8_t                   out_signal_num;  /**< index of the output parameter array*/
  uint8_t                   in_signal_num;   /**< index of the input parameter array */
}AUTOMATION_FB_CONNECTION_TABLE_t;

/**
 * Ramp configurations from UI
 */
typedef struct AUTOMATION_FB_RAMP_CONFIG
{
  int32_t                       startset;                      /**< start physical value */
  int32_t                       endset;                        /**< end physical value */
  int32_t                       linear_acceleration;           /**< slew rate of linear ramp */
  uint32_t                      time_constant;                 /**< pre-calculated value for the target calculation */
  int32_t                       linear_startvalue;             /**< Velocity start value of the linear region */
  int32_t                       linear_endvalue;               /**< Velocity end value of the linear region */
  uint32_t                      slewrate_counter;              /**< counter value to update the slewrate */
  int32_t                       slewrate_endset;                /**< max end slew rate for S-region*/
  AUTOMATION_FB_RAMP_CALLRATE_t callrate;                     /**< execution time of the ramp */
  AUTOMATION_FB_RAMPTYPE_t      ramp_type;                    /**< type of the ramp generator */
  uint8_t                       ratio;                          /**< ratio of the S-region to Linear region */
}AUTOMATION_FB_RAMP_CONFIG_t;

/**
 * Configuration handle for the ramp generator function block
 */
typedef struct AUTOMATION_FB_RAMPGEN
{
  int32_t     endset_t;                      /**< end target value */
  int32_t*    endset_ptr;                   /**< input variable - can be mapped to Motor App or the value from UI */
  int32_t     startset_t;                   /**< target initial value of the ramp */
  int32_t     out_set_t;                     /**< output of the ramp generator - reference value */
  uint32_t    scale;                         /**< scale */
  uint32_t*   scale_ptr;                    /**< input variable- scale */
  uint32_t    counter;                       /**< ramp counter which decides the slope. */
  uint32_t    counter_t;                     /**< ramp counter converted to target value */
  uint32_t    index;                         /**< index to check the ramp counter */
  int32_t     prev_endset_t;                 /**< Saves the previous end reference value for S-curve implementation */
  int32_t     slewrate_end;                   /**< end slewrate for S-region */
  int32_t     slewrate_startset_t;            /**< start slew rate of S-region in target form */
  int32_t     slewrate_endset_t;              /**< end slew rate of S-region in target form */
  int32_t     slewrate_set_t;                 /**< instantaneous slew rate of S-region in target form */
  uint32_t    slewrate_counter_t;            /**< slew rate counter value in target form*/
  uint32_t    slewrate_index;                /**< slew rate index to calculate counter */
  int32_t     linear_startvalue_t;           /**< velocity start value of linear region */
  int32_t     linear_endvalue_t;             /**< velocity end value of linear region */
  int32_t     diff;                          /**< velocity difference*/
  const AUTOMATION_FB_RAMP_CONFIG_t* const config_ptr;  /** pointer to the config structure */
} AUTOMATION_FB_RAMPGEN_t;


/*******************************  DRIVE STATE MACHINE  ********************************************************/

/**
 * Configuration handle for Drive State Machine States and corresponding function pointers
 */
typedef struct AUTOMATION_SM_STATES
{
  const char*                   string;                /**< State Description */
  AUTOMATION_TASK_FUNCT_PTR_t  state_entry_call;       /**< pointer of function to be called while entry the state */
  AUTOMATION_TASK_FUNCT_PTR_t  state_action_call;      /**< pointer of function to be called while in the state */
  AUTOMATION_TASK_FUNCT_PTR_t  state_exit_call;        /**< pointer of function to be called while exit the state */
} AUTOMATION_SM_STATES_t;

/**
 * Configuration handle for Drive State Machine
 */
typedef struct AUTOMATION_SM
{
  const AUTOMATION_SM_STATES_t *states;               /**< Drive State Machine States and corresponding function pointers */
  const void*                   app_handler;          /**< App Handler */
  uint8_t                       current_state;        /**< Current state of drive machine */
  uint8_t                       requested_state;      /**< requested state of drive machine */
  volatile uint32_t             transition_request:1; /**< Execute state change request*/
  volatile uint32_t             execute_action:1;     /**< Set to one, if execute request state immediately after state change*/
}AUTOMATION_SM_t;

/**
 * @}
 */

#ifdef __cplusplus
extern "C"
{
#endif
/**
 * @ingroup AUTOMATION_apidoc
 * @{
 */

/***********************************************************************************************************************
 * API Prototypes
 **********************************************************************************************************************/
/**
 * @brief Get AUTOMATION APP version
 * @return DAVE_APP_VERSION_t APP version information (major, minor and patch number)
 * \par<b>Description: </b><br>
 * The function can be used to check application software compatibility with a
 * specific version of the APP.
 *
 * Example Usage:
 *
 * @code
 * #include "DAVE.h"
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   DAVE_APP_VERSION_t version;
 *
 *   // Initialize AUTOMATION APP
 *   // AUTOMATION_Init() is called from within DAVE_Init().
 *   init_status = DAVE_Init();
 *
 *   version = AUTOMATION_GetAppVersion();
 *   if (version.major != 1U)
 *   {
 *     // Probably, not the right version.
 *   }
 *
 *   // More code here
 *   while(1)
 *   {
 *
 *   }
 *   return (1);
 * }
 * @endcode<BR>

 */
DAVE_APP_VERSION_t AUTOMATION_GetAppVersion(void);

/**
 * @brief Initialize the automation APP.
 * @param handle_ptr pointer to the automation App handler
 * @return AUTOMATION_STATUS_t status of the operation
 *
 * \par<b>Description: </b><br>
 * Starts error handler and function block processor tasks.
 * This is the first API which application must invoke to use AUTOMATION APP.
 *
 * @code
 * #include "DAVE.h"
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   DAVE_APP_VERSION_t version;
 *
 *   // Initialize AUTOMATION APP
 *   // AUTOMATION_Init() is called from within DAVE_Init().
 *   init_status = DAVE_Init();
 *
 *   // More code here
 *   while(1)
 *   {
 *
 *   }
 *   return (1);
 * }
 * @endcode<BR>
 */
AUTOMATION_STATUS_t AUTOMATION_Init(AUTOMATION_t* const handle_ptr);

/**
 * @brief Assign the app_id to the APP instance.
 * @param app_handle_ptr Pointer to APP handle data structure
 * @param name Unique name of the APP
 * @param app_id ID assigned by the automation APP
 * @return AUTOMATION_STATUS_t status of the operation \n
 * AUTOMATION_STATUS_SUCCESS if APP registration is successful \n
 * AUTOMATION_STATUS_NUM_APPS_EXCEEDED if it exceeds \ref AUTOMATION_NUM_APPS
 * <BR>
 *
* \par<b>Description: </b><br>
 * It saves app_id and apphandle_ptr in the AUTOMATION_App_Table.
 * Any APP who wants to use services of AUTOMATION APP need to first register using this API.
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   AUTOMATION_STATUS_t status;
 *   uint8_t app_id;
 *   uint32_t test_handle; // This should be handle data structure of the APP e.g. of type ACIM_FREQ_CTRL_t
 *   init_status = DAVE_Init();     //Initialization of DAVE Apps
 *   status = AUTOMATION_RegisterApp(&test_handle,"TestApp", &app_id);
 *   while (1)
 *   {
 *   }
 *   return 1;
 * }
 * @endcode <BR>
 */
AUTOMATION_STATUS_t AUTOMATION_RegisterApp(void* const app_handle_ptr, const char* const name, uint8_t* app_id);

/**
 * @brief Assign the interface_id to the interface channel.
 * @param interface_id ID assigned by the automation app
 * @return AUTOMATION_STATUS_t status of the operation \n
 * AUTOMATION_STATUS_SUCCESS if interface registration is successful \n
 * AUTOMATION_STATUS_NUM_INTERFACE_EXCEEDED if it exceeds \ref AUTOMATION_NUM_INTERFACES
 * <BR>
* \par<b>Description: </b><br>
 * Any interface who wants to use communicate with AUTOMATION APP need to first register using this API.
 * Use assigned interface_id in the subsequent calls.
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   AUTOMATION_STATUS_t status;
 *   uint8_t interface_id;
 *   init_status = DAVE_Init();     //Initialization of DAVE Apps
 *   status = AUTOMATION_RegisterInterface(&interface_id);
 *   while (1U);
 *   return 1U;
 * }
 * @endcode<BR>
 */
AUTOMATION_STATUS_t AUTOMATION_RegisterInterface(uint8_t* interface_id );

/**
 * @brief Registers the task to be executed from the automation framework task scheduler.
 * @param callback_arg_ptr callback function parameter (void*)
 * @param task_ptr callback function of the task (function pointer of type AUTOMATION_TASK_FUNCT_PTR_t)
 * @param delay_count period of the task execution in us
 * @return AUTOMATION_STATUS_t status of the operation
 * AUTOMATION_STATUS_SUCCESS if task registration is successful \n
 * AUTOMATION_STATUS_FAILURE if task table \ref AUTOMATION_Task_Table is full or if SYSTIMER can not be started with given delay_count
 * <BR>
 * \par<b>Description: </b><br>
 * Registered task executes periodically at the given \a delay_count. Task scheduler uses systick to schedule the tasks.
 * User can any point of time invoke this API to add task in the
 * task table and can delete the task at any time using AUTOMATION_DeregisterTask API.
 * \par<b>Note</b><br>
 * \a delay_count should be greater than or equal to the systick value programmed in the SYSTIMER APP.
 * 
 * @code
 * #include "DAVE.h"
 * 
 * void task_function(void)
 * {
 *   // Do something
 * }
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   AUTOMATION_STATUS_t status;
 *   init_status = DAVE_Init();     //Initialization of DAVE Apps
 *   status = AUTOMATION_RegisterTask((AUTOMATION_TASK_FUNCT_PTR_t)task_function, NULL, 1000);
 *   while (1U);
 *   return 1U;
 * }
 * @endcode
 */
AUTOMATION_STATUS_t AUTOMATION_RegisterTask(AUTOMATION_TASK_FUNCT_PTR_t task_ptr, void* callback_arg_ptr, uint32_t delay_count);

/**
 * @brief De-registers the task from the task table.
 * Corresponding system timer will be deleted.
 * @param task_ptr callback function of task to be deleted (function pointer of type AUTOMATION_TASK_FUNCT_PTR_t)
 * @return AUTOMATION_STATUS_t status of the operation
 * AUTOMATION_STATUS_SUCCESS if task de-registration is successful \n
 * AUTOMATION_STATUS_FAILURE if task is not found in the task table
 * <BR>
 * \par<b>Description: </b><br>
 * Deletes the task from the task table and removes the systimer entry.
 * User can any point of time invoke this API to delete the task.
 * 
 * @code
 * #include "DAVE.h"
 * 
 * void task_function(void)
 * {
 *   // Do something
 * }
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   AUTOMATION_STATUS_t status;
 *   init_status = DAVE_Init();     //Initialization of DAVE Apps
 *   status = AUTOMATION_RegisterTask((AUTOMATION_TASK_FUNCT_PTR_t)task_function, NULL, 1000);
 *   // Do something
 *   AUTOMATION_DeregisterTask((AUTOMATION_TASK_FUNCT_PTR_t)task_function);
 *   while (1U);
 *   return 1U;
 * }
 * @endcode
 */
AUTOMATION_STATUS_t AUTOMATION_DeregisterTask(AUTOMATION_TASK_FUNCT_PTR_t task_ptr);

/**
 * @brief Registers parameter table of the APP
 * @param app_id ID of the APP
 * @param app_param_table_ptr pointer to the APP parameter table
 * @return AUTOMATION_STATUS_t status of the operation \n
 * AUTOMATION_STATUS_SUCCESS if parameter table registration is successful \n
 * AUTOMATION_STATUS_NUM_PARAM_EXCEEDED if app_id is not valid
 * <BR>
 * \par<b>Description: </b><br>
 * Saves the APP parameter table pointer in the AUTOMATION_PH_PARAMHANDLE.
 * It maintains the relation between app_id and \a app_param_table_ptr.\n
 * This API needs to be invoked by the APP to use the parameter handler feature.
 * Once the parameter table is successfully registered, interface channel can access the parameter
 * of the APP at any point of time by updating request in the \ref AUTOMATION_PH_PARAMETER_t AUTOMATION_PH_Parameter_Buf.
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int32_t frequency;
 * //parameter table entry for frequency
 * AUTOMATION_PH_PARAM_ENTRY_t param_table =
 * {
 *   .param_addr           = &frequency,
 *   .minval               = 0,
 *   .maxval               = 50000,
 *   .scale                = 32767U,
 *   .inv_scale            = 32767U,
 *   .setptr               = NULL,
 *   .write_access         = AUTOMATION_PH_WRITE_ACCESS_ALLOWED,
 *   .size                 = (uint8_t)4
 * };
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   AUTOMATION_STATUS_t status;
 *   uint8_t app_id = 0U;
 * 
 *   uint32_t test_handle;  // This should be handle data structure of the APP e.g. of type ACIM_FREQ_CTRL_t
 * 
 *   init_status = DAVE_Init();     //Initialization of DAVE Apps
 *   status = AUTOMATION_RegisterApp(&test_handle,"TestApp", &app_id);
 *   if (AUTOMATION_STATUS_SUCCESS == status)
 *   {
 *     status = AUTOMATION_PH_RegisterParamTable(app_id, &param_table);
 *     if (AUTOMATION_STATUS_SUCCESS == status)
 *     {
 *      //access the parameters of the app using AUTOMATION_PH_ParamSequencer
 *     }
 *   }
 *   while(1U);
 *   return 1U;
 * }
 * @endcode
 */
AUTOMATION_STATUS_t  AUTOMATION_PH_RegisterParamTable(uint8_t app_id,
    AUTOMATION_PH_PARAM_ENTRY_t* app_param_table_ptr);

/**
 * @brief  Executes requests (set/get parameter) saved in the parameter buffer for all interface ids.\n
 *
 * @return void
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Executes requests in the \ref AUTOMATION_PH_PARAMETER_t AUTOMATION_PH_Parameter_Buf for all registered interface ids
 * and updates the same structure with the result of set or get parameter value.
 * User should call this function at certain intervals in main loop or in any interrupt routine or by registering in task scheduler,
 * as per the use case requirement.
 *
 * @code
 * #include "DAVE.h"
 * 
 * int32_t frequency;
 * //parameter table entry for frequency
 * AUTOMATION_PH_PARAM_ENTRY_t param_table =
 * {
 *   .param_addr           = &frequency,
 *   .minval               = 0,
 *   .maxval               = 50000,
 *   .scale                = 32767U,
 *   .inv_scale            = 32767U,
 *   .setptr               = NULL,
 *   .write_access         = AUTOMATION_PH_WRITE_ACCESS_ALLOWED,
 *   .size                 = (uint8_t)4
 * };
 * 
 * int32_t interface_frequency;
 * 
 * //Interface updates command in this structure.
 * //After execution of the command, parameter handler changes the status to AUTOMATION_PH_STATUS_READY or AUTOMATION_PH_STATUS_FAILED
 * //which can be polled by the interface to read the result.
 * AUTOMATION_PH_PARAMETER_t Parameter_Buf =
 * {
 *   .value = 20000,
 *   .var_address = &interface_frequency,
 *   .command = AUTOMATION_PH_COMMAND_SET,
 *   .status = AUTOMATION_PH_STATUS_ACTIVE,
 *   .app_id = 0U,
 *   .param_id = 0U,
 *   .size = 4U
 * };
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   AUTOMATION_STATUS_t status;
 *   uint8_t app_id = 0U;
 *   uint32_t count;
 *   uint32_t test_handle;  // This should be handle data structure of the APP e.g. of type ACIM_FREQ_CTRL_t
 *   init_status = DAVE_Init();    //Initialization of DAVE Apps
 *   status = AUTOMATION_RegisterApp(&test_handle,"TestApp", &app_id);
 *   if (AUTOMATION_STATUS_SUCCESS == status)
 *   {
 *     status = AUTOMATION_PH_RegisterParamTable(app_id, &param_table);
 *     if (AUTOMATION_STATUS_SUCCESS == status)
 *     {
 *      //access the parameters of the app using AUTOMATION_PH_ParamSequencer
 *     }
 *   }
 * 
 *   while(1U)
 *   {
 *     for (count = 0U; count < 0xFFFF; count++);
 *     AUTOMATION_PH_ParamSequencer();
 * 
 *   }
 *   return 1U;
 * }
 * 
 * @endcode
 */
void AUTOMATION_PH_ParamSequencer(void);

/**
 * @brief Registers function of the interface channel to report the error on the \a interface_id
 * @param interface_id interface index
 * @param callback_ptr callback function of the interface to be called to report the error
 * @return AUTOMATION_STATUS_t status of the operation \n
 * AUTOMATION_STATUS_SUCCESS if registration is successful \n
 * AUTOMATION_STATUS_INVALID_INTERFACE_ID if interface_id is invalid
 * <BR>
 * \par<b>Description: </b><br>
 * ErrorSequencer calls registered function when error is detected. All the errors are reported to single interface channel.
 * This function can be invoked at any point to change the reporting interface channel and callback function.
 * 
 * @code
 * #include "DAVE.h"
 * 
 * void ReportToExternalWorld(uint8_t app_id, uint8_t error_id,
 *                            uint8_t error_severity, uint8_t status)
 * {
 *   //report this information
 * }
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   AUTOMATION_STATUS_t status;
 *   uint8_t interface_id = 0U;
 *   init_status = DAVE_Init();    //Initialization of DAVE Apps
 * 
 *   status = AUTOMATION_EH_RegisterInterfaceCallback(interface_id, (AUTOMATION_EH_REPORTING_FUNCT_PTR_t)ReportToExternalWorld);
 *   while(1U);
 *   return 1U;
 * }
 * @endcode
 */
AUTOMATION_STATUS_t AUTOMATION_EH_RegisterInterfaceCallback(uint8_t interface_id, AUTOMATION_EH_REPORTING_FUNCT_PTR_t callback_ptr);
/**
 * @brief Registers global errors in error table
 * @param interface_id interface index
 * @param position error position in a table. Range 0 to 31
 * @param error pointer to the error table entry
 * @return AUTOMATION_STATUS_t status of the operation \n
 * AUTOMATION_STATUS_SUCCESS if registration is successful \n
 * AUTOMATION_STATUS_INVALID_INTERFACE_ID if interface_id is invalid
 * <BR>
 * \par<b>Description: </b><br>
 * Registers global error at the \a position in a bit interface word. Position is associated with priority of the error, 0 is the highest priority
 * and 31 lowest. ErrorSequencer scans the status of the registered global errors from bit 0 to bit 31 sequentially.
 * 
 * @code
 * #include "DAVE.h"
 * 
 * AUTOMATION_EH_BIT_ERROR_TABLE_t error =
 * {
 *   .error_functptr = NULL,
 *   .error_callbackarg = NULL,
 *   .error_id = 0U,
 *   .error_status = AUTOMATION_EH_ERROR_STATUS_SET,
 *   .error_severity= AUTOMATION_EH_ERROR_SEVERITY_ERROR
 * };
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   AUTOMATION_STATUS_t automation_status;
 *   init_status = DAVE_Init();    //Initialization of DAVE Apps
 *   automation_status = AUTOMATION_EH_BitInterface_RegisterErrors(0, 3, &error);
 *   while(1U);
 *   return 1U;
 * }
 * @endcode
 */
AUTOMATION_STATUS_t AUTOMATION_EH_BitInterface_RegisterErrors (uint8_t interface_id,uint8_t position,
                                                           AUTOMATION_EH_BIT_ERROR_TABLE_t* const error);
/**
 * @brief Scans the interface error table and takes action on the reported error. It also logs the errors in the logbook.
 * @return void
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Error sequencer is called periodically by systimer interrupt. Period of execution is configured in GUI.
 * This scans the interface error table AUTOMATION_EH_BitErrorTable from bit position 0 to bit position 31 and takes action if error is set.
 * It reports the error status to interface channel and logs the error in the logbook.
 * 
 * @code
 * #include "DAVE.h"
 * 
 * AUTOMATION_EH_BIT_ERROR_TABLE_t error =
 * {
 *   .error_functptr = NULL,
 *   .error_callbackarg = NULL,
 *   .error_id = 0U,
 *   .error_status = AUTOMATION_EH_ERROR_STATUS_SET,
 *   .error_severity= AUTOMATION_EH_ERROR_SEVERITY_ERROR
 * };
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   AUTOMATION_STATUS_t automation_status;
 *   init_status = DAVE_Init();    //Initialization of DAVE Apps
 *   //AUTOMATION_Init starts the system timer for error handler and AUTOMATION_EH_ErrorSequencer() gets called
 *   //from system timer interrupt when set time is elapsed.
 *   automation_status = AUTOMATION_EH_BitInterface_RegisterErrors(0, 3, &error);
 * 
 *   while(1U);
 *   return 1U;
 * }
 * @endcode
 */
void AUTOMATION_EH_ErrorSequencer (void);

/**
 * @brief Updates the status of the global error in the bit interface error table
 * @param interface_id interface index
 * @param error_word_val bit interface word with the status of the errors
 * @return AUTOMATION_STATUS_t status of the operation \n
 * AUTOMATION_STATUS_SUCCESS if registration is successful \n
 * AUTOMATION_STATUS_INVALID_INTERFACE_ID if interface_id is invalid
 * <BR>
 *
 * \par<b>Description: </b><br>
 * This function can be called by any APP or interface channel to update the status of the global error.
 *
 * @code
 * #include "DAVE.h"
 * 
 * AUTOMATION_EH_BIT_ERROR_TABLE_t error =
 * {
 *   .error_functptr = NULL,
 *   .error_callbackarg = NULL,
 *   .error_id = 0U,
 *   .error_status = AUTOMATION_EH_ERROR_STATUS_SET,
 *   .error_severity= AUTOMATION_EH_ERROR_SEVERITY_ERROR
 * };
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   AUTOMATION_STATUS_t automation_status;
 *   init_status = DAVE_Init();    //Initialization of DAVE Apps
 *   automation_status = AUTOMATION_EH_BitInterface_RegisterErrors(0, 3, &error);
 * 
 *   if (AUTOMATION_STATUS_SUCCESS == automation_status)
 *   {
 *     // Do something
 *   }
 * 
 *   //bit error 3 is set by below call.
 *   automation_status = AUTOMATION_EH_BitInterface_ReportError(0, 0x8);
 * 
 *   while(1U);
 *   return 1U;
 * }
 * @endcode
 */
AUTOMATION_STATUS_t AUTOMATION_EH_BitInterface_ReportError(uint8_t interface_id, uint32_t error_word_val);

/**
 * @brief Update the status of the APP errors to error handler
 * @param app_id APP index in which error is set or cleared
 * @param error_id error code of the error to be reported
 * @param error_severity \ref AUTOMATION_EH_ERROR_SEVERITY_t severity of the error
 * @param status \ref AUTOMATION_EH_ERROR_STATUS_t status of the error
 * @return void
 * <BR>
 *
* \par<b>Description: </b><br>
 * This function can be called by any registered APP to update the status of the APP error to error handler.
 * This status of APP error is forwarded to interface channel and also written in the logbook by ErrorSequencer.
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   AUTOMATION_STATUS_t automation_status;
 *   uint8_t app_id;
 *   uint8_t error_id = 0U;
 *   uint32_t test_handle;
 *   AUTOMATION_EH_ERROR_SEVERITY_t  error_severity = AUTOMATION_EH_ERROR_SEVERITY_ERROR;
 *   AUTOMATION_EH_ERROR_STATUS_t status = AUTOMATION_EH_ERROR_STATUS_SET;
 * 
 *   init_status = DAVE_Init();    //Initialization of DAVE Apps
 *   status = AUTOMATION_RegisterApp(&test_handle,"TestApp", &app_id);
 *   AUTOMATION_EH_AppInterface_ReportError(app_id,error_id,error_severity,status);
 *   while(1U);
 *   return 1U;
 * }
 * @endcode
 */
void AUTOMATION_EH_AppInterface_ReportError(uint8_t app_id, uint8_t error_id, AUTOMATION_EH_ERROR_SEVERITY_t error_severity, AUTOMATION_EH_ERROR_STATUS_t status);

/**
 * @brief Updates the logbook with the status of the error
 * @param error structure of type \ref AUTOMATION_EH_LOGBOOK_ENTRY_t containing the information about the error to be written in logbook
 * @return void
 * <BR>
 *
* \par<b>Description: </b><br>
 * Write the error information in the logbook in a section based on severity. Critical errors
 * are not overwritten. Warning messages are updated even if old messages are not read.
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   AUTOMATION_STATUS_t automation_status;
 *   uint8_t app_id;
 *   uint8_t error_id = 0U;
 *   uint32_t test_handle;
 *   AUTOMATION_EH_ERROR_SEVERITY_t  error_severity = AUTOMATION_EH_ERROR_SEVERITY_ERROR;
 *   AUTOMATION_EH_ERROR_STATUS_t status = AUTOMATION_EH_ERROR_STATUS_SET;
 *   AUTOMATION_EH_LOGBOOK_ENTRY_t error_info;
 * 
 *   init_status = DAVE_Init();    //Initialization of DAVE Apps
 *   status = AUTOMATION_RegisterApp(&test_handle,"TestApp", &app_id);
 *   AUTOMATION_EH_AppInterface_ReportError(app_id,error_id,error_severity,status);
 *   AUTOMATION_EH_WriteLogbook(error_info);
 *   while(1U);
 *   return 1U;
 * }
 * @endcode
 */
void AUTOMATION_EH_WriteLogbook(AUTOMATION_EH_LOGBOOK_ENTRY_t error);

/**
 * @brief Reads error details from log book
 * @param error_ptr pointer of type AUTOMATION_EH_LOGBOOK_ENTRY_t
 * @param section logbook part from which error information to be read \ref AUTOMATION_EH_LOGBOOK_SECTIONS_t
 * @return AUTOMATION_STATUS_t status of operation \n
 * AUTOMATION_STATUS_SUCCESS if reading is successful
 * AUTOMATION_STATUS_LOGBOOK_EMPTY if there is no entry in logbook to read
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Reads top entry from logbook \a section
 *
 * \par<b>Note: </b><br>
 * Reading rate should be decided by the size of the logbook and the probability of the occurence of error.
 *
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   AUTOMATION_STATUS_t automation_status;
 *   uint8_t app_id;
 *   uint8_t error_id = 0U;
 *   uint32_t test_handle;
 *   AUTOMATION_EH_ERROR_SEVERITY_t  error_severity = AUTOMATION_EH_ERROR_SEVERITY_ERROR;
 *   AUTOMATION_EH_ERROR_STATUS_t status = AUTOMATION_EH_ERROR_STATUS_SET;
 *   AUTOMATION_EH_LOGBOOK_ENTRY_t error_info;
 * 
 *   init_status = DAVE_Init();    //Initialization of DAVE Apps
 *   status = AUTOMATION_RegisterApp(&test_handle,"TestApp", &app_id);
 *   AUTOMATION_EH_AppInterface_ReportError(app_id,error_id,error_severity,status);
 *   AUTOMATION_EH_WriteLogbook(error_info);
 *   AUTOMATION_EH_ReadLogbook(&error_info, AUTOMATION_EH_LOGBOOK_SECTIONS_CS_LOGBOOK);
 *   while(1U);
 *   return 1U;
 * }
 * @endcode
 */
AUTOMATION_STATUS_t AUTOMATION_EH_ReadLogbook(AUTOMATION_EH_LOGBOOK_ENTRY_t* error_ptr,
                                            AUTOMATION_EH_LOGBOOK_SECTIONS_t section);

/**
 * @brief Registers function block pointer in the function block array.
 * @param frame function block pointer to be registered
 * @return AUTOMATION_STATUS_t status of operation \n
 * AUTOMATION_STATUS_SUCCESS if registration is successful
 * AUTOMATION_STATUS_NUM_FB_EXCEEDED if AUTOMATION_FB_Table is full
 * <BR>
 *
* \par<b>Description: </b><br>
 * Registers function block pointer in AUTOMATION_FB_Table. This table can be used by interface channel to get the information
 * about registered function blocks.
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   AUTOMATION_STATUS_t status;
 *   AUTOMATION_FB_HANDLE_t frame;
 *   init_status = DAVE_Init();    //Initialization of DAVE Apps
 *   status = AUTOMATION_FB_RegisterFunctionBlock(&frame);
 *   while(1U);
 *   return 1U;
 * }
 * @endcode
 */
AUTOMATION_STATUS_t AUTOMATION_FB_RegisterFunctionBlock(AUTOMATION_FB_HANDLE_t* const frame);

/**
 * @brief Initializes ramp function block

 * @param rampfb_ptr pointer to the ramp function block structure
 * @return void
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Initializes ramp parameters with target values based upon scale.
 * User need to call this function when motor is restarted to reset the ramp parameters.
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   AUTOMATION_FB_HANDLE_t handle;
 *   init_status = DAVE_Init();    //Initialization of DAVE Apps
 *   AUTOMATION_FB_RampInit(&handle);
 *   while(1U);
 *   return 1U;
 * }
 * @endcode
 */
void AUTOMATION_FB_RampInit(AUTOMATION_FB_HANDLE_t* const rampfb_ptr);

/**
 * @brief Converts ramp parameters in target value as per scale

 * @param ramphandle_ptr pointer to the ramp handle
 * @return void
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Converts ramp parameters in target value as per scale
 * User need to call this function if scale parameter is different
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   AUTOMATION_FB_RAMPGEN_t handle;
 *   init_status = DAVE_Init();    //Initialization of DAVE Apps
 *   AUTOMATION_FB_RampTargetValueCalc(&handle);
 *   while(1U);
 *   return 1U;
 * }
 * @endcode
 */
void AUTOMATION_FB_RampTargetValueCalc(AUTOMATION_FB_RAMPGEN_t* const ramphandle_ptr);

/**
 * @brief Sets the start point of ramp

 * @param ramphandle_ptr pointer to the ramp handle
 * @param start_value start point of ramp
 * @return AUTOMATION_STATUS_t
 * AUTOMATION_STATUS_SUCCESS: if function is successful
 * AUTOMATION_STATUS_INVALID_PARAM if parameter is out of range
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Updates the start point of the ramp.
 * It will be saved in target form using scale factor.
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   AUTOMATION_FB_HANDLE_t handle;
 *   init_status = DAVE_Init();    //Initialization of DAVE Apps
 *   AUTOMATION_FB_RampInit(&handle);
 *   AUTOMATION_FB_SetRampStartValue(handle.config_ptr, 100);
 *   while(1U);
 *   return 1U;
 *   }
 * @endcode
 */
AUTOMATION_STATUS_t AUTOMATION_FB_SetRampStartValue(AUTOMATION_FB_RAMPGEN_t* const ramphandle_ptr, int32_t start_value);

/**
 * @brief Sets the end point of ramp

 * @param ramphandle_ptr pointer to the ramp handle
 * @param end_value end point of ramp
 * @return AUTOMATION_STATUS_t
 * AUTOMATION_STATUS_SUCCESS: if function is successful
 * AUTOMATION_STATUS_INVALID_PARAM if parameter is out of range
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Updates the end point of the ramp.
 * It will be saved in target form using scale factor.
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   AUTOMATION_FB_HANDLE_t handle;
 *   init_status = DAVE_Init();    //Initialization of DAVE Apps
 *   AUTOMATION_FB_RampInit(&handle);
 *   AUTOMATION_FB_SetRampEndValue(handle.config_ptr, 1000);
 *   while(1U);
 *   return 1U;
 * }
 * @endcode
 */
AUTOMATION_STATUS_t AUTOMATION_FB_SetRampEndValue(AUTOMATION_FB_RAMPGEN_t* const ramphandle_ptr, int32_t end_value);

/**
 * @brief Sets the slew rate for linear ramp

 * @param ramphandle_ptr pointer to the ramp handle
 * @param slew_rate slope of the linear ramp
 * @return AUTOMATION_STATUS_t
 * AUTOMATION_STATUS_SUCCESS: if function is successful
 * AUTOMATION_STATUS_INVALID_PARAM if parameter is out of range
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Updates the slew rate for linear ramp.
 * It will be saved in target form using scale factor.
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   AUTOMATION_FB_HANDLE_t handle;
 *   init_status = DAVE_Init();    //Initialization of DAVE Apps
 *   AUTOMATION_FB_RampInit(&handle);
 *   AUTOMATION_FB_SetLinearRampSlewRate(handle.config_ptr, 100);
 *   while(1U);
 *   return 1U;
 * }
 * @endcode
 */
AUTOMATION_STATUS_t AUTOMATION_FB_SetLinearRampSlewRate(AUTOMATION_FB_RAMPGEN_t* const ramphandle_ptr, uint32_t slew_rate);

/**
 * @brief Sets the slew rate for S ramp

 * @param ramphandle_ptr pointer to the ramp handle
 * @param slew_rate slope of the S ramp
 * @return AUTOMATION_STATUS_t
 * AUTOMATION_STATUS_SUCCESS: if function is successful
 * AUTOMATION_STATUS_INVALID_PARAM if parameter is out of range
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Updates the slew rate for S ramp.
 * It will be saved in target form using scale factor.
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   AUTOMATION_FB_HANDLE_t handle;
 *   init_status = DAVE_Init();    //Initialization of DAVE Apps
 *   AUTOMATION_FB_RampInit(&handle);
 *   AUTOMATION_FB_SetSRampSlewRate(handle.config_ptr, 100);
 *   while(1U);
 *   return 1U;
 * }
 * @endcode
 */
AUTOMATION_STATUS_t AUTOMATION_FB_SetSRampSlewRate(AUTOMATION_FB_RAMPGEN_t* const ramphandle_ptr, uint32_t slew_rate);

/**
 * @brief Retrieves the start value of ramp

 * @param ramphandle_ptr pointer to the ramp handle
 * @return int32_t start value of ramp
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Retrieves the start value of ramp
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   AUTOMATION_FB_HANDLE_t handle;
 *   int32_t start_value;
 *   init_status = DAVE_Init();    //Initialization of DAVE Apps
 *   AUTOMATION_FB_RampInit(&handle);
 *   start_value = AUTOMATION_FB_GetRampStartValue(handle.config_ptr);
 *   while(1U);
 *   return 1U;
 * }
 * @endcode
 */
int32_t AUTOMATION_FB_GetRampStartValue(AUTOMATION_FB_RAMPGEN_t* const ramphandle_ptr);
/**
 * @brief Retrieves the end value of ramp

 * @param ramphandle_ptr pointer to the ramp handle
 * @return int32_t end value of ramp
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Retrieves the end value of ramp
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   AUTOMATION_FB_HANDLE_t handle;
 *   int32_t end_value;
 *   init_status = DAVE_Init();    //Initialization of DAVE Apps
 *   AUTOMATION_FB_RampInit(&handle);
 *   end_value = AUTOMATION_FB_GetRampEndValue(handle.config_ptr);
 *   while(1U);
 *   return 1U;
 *   }
 * @endcode
 */
int32_t AUTOMATION_FB_GetRampEndValue(AUTOMATION_FB_RAMPGEN_t* const ramphandle_ptr);

/**
 * @brief Retrieves the slew rate for linear ramp

 * @param ramphandle_ptr pointer to the ramp handle
 * @return uint32_t slew rate of linear ramp
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Retrieves the slew rate for linear ramp.
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   AUTOMATION_FB_HANDLE_t handle;
 *   uint32_t slew_rate;
 *   init_status = DAVE_Init();    //Initialization of DAVE Apps
 *   AUTOMATION_FB_RampInit(&handle);
 *   slew_rate = AUTOMATION_FB_GetLinearRampSlewRate(handle.config_ptr);
 *   while(1U);
 *   return 1U;
 * }
 * @endcode
 */
uint32_t AUTOMATION_FB_GetLinearRampSlewRate(AUTOMATION_FB_RAMPGEN_t* const ramphandle);
/**
 * @brief Retrieves the slew rate for S ramp

 * @param ramphandle_ptr pointer to the ramp handle
 * @return uint32_t slew rate of S ramp
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Retrieves the slew rate for S ramp.
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   AUTOMATION_FB_HANDLE_t handle;
 *   uint32_t slew_rate;
 *   init_status = DAVE_Init();    //Initialization of DAVE Apps
 *   AUTOMATION_FB_RampInit(&handle);
 *   slew_rate = AUTOMATION_FB_GetSRampSlewRate(handle.config_ptr);
 *   while(1U);
 *   return 1U;
 * }
 * @endcode
 */
uint32_t AUTOMATION_FB_GetSRampSlewRate(AUTOMATION_FB_RAMPGEN_t* const ramphandle_ptr);

/**
 * @brief Generates the linear ramp
 * @param ramphandle_ptr pointer to the ramp configuration structure
 * @return void
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Ramps the parameter from initial value to end value linearly at the configured slew rate. If ramp is connected to
 * motor function block, target value and the scale is decided by the motor function block.
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   AUTOMATION_FB_HANDLE_t handle;
 *   init_status = DAVE_Init();    //Initialization of DAVE Apps
 *   AUTOMATION_FB_RampInit(&handle);
 *   AUTOMATION_FB_LinearRamp(handle.config_ptr);
 *   while(1U);
 *   return 1U;
 * }
 * @endcode
 */
void AUTOMATION_FB_LinearRamp(AUTOMATION_FB_RAMPGEN_t* const ramphandle_ptr);

/**
 * @brief Generates the S-curve ramp.
 * @param ramphandle_ptr pointer to the ramp configuration structure
 * @return void
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Ramps the parameter from initial value to end value in s-curve.\n
 * This profile reduces jerk in motion as parameter is ramped smoothly in s-curve.
 * If ramp is connected to motor function block, target value and the scale is decided by the motor function block.
 *
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   AUTOMATION_FB_HANDLE_t handle;
 *   init_status = DAVE_Init();    //Initialization of DAVE Apps
 *   AUTOMATION_FB_RampInit(&handle);
 *   AUTOMATION_FB_ScurveRamp(handle.config_ptr);
 *   while(1U);
 *   return 1U;
 * }
 * @endcode
 */
void AUTOMATION_FB_ScurveRamp(AUTOMATION_FB_RAMPGEN_t* const ramphandle_ptr);
/**
 * @brief Executes function blocks in a sequence from execution order list.
 * This function will be called periodically by task scheduler. This will execute the function blocks
 * registered in the execution order list.
 * @return void
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Calls the functions registered in the function block in a order configured in the UI.
 * This function is called periodically by system timer interrupt.
 *
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   AUTOMATION_STATUS_t status;
 *   AUTOMATION_FB_HANDLE_t frame;
 *   init_status = DAVE_Init();    //Initialization of DAVE Apps
 *   status = AUTOMATION_FB_RegisterFunctionBlock(&frame);
 *   AUTOMATION_FB_FunctionBlockSequencer();
 *   while(1U);
 *   return 1U;
 * }
 * @endcode
 */
void AUTOMATION_FB_FunctionBlockSequencer(void);

/**
 * @brief Fills entries in the function block connection table.
 * @param source_fb function block pointer providing output data in the connection
 * @param out_signal_num index of the output parameter array of source_fb
 * @param destination_fb function block pointer which accepts the input data in connection
 * @param in_signal_num index of the input parameter array of destination_fb
 *
 * @return AUTOMATION_STATUS_t status of the API execution \n
 * AUTOMATION_STATUS_SUCCESS if connection entry is added successfully \n
 * AUTOMATION_STATUS_CONNECT_TABLE_OVERFLOW if there is no space in connection table
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Defines the connections between two function blocks in AUTOMATION_FB_Connect_Table.
 * Interface channel can read this table to get the information about the connections.
 *
 * \par<b>Note: </b><br>
 * Please note that function block should be registered before calling this function.
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   AUTOMATION_STATUS_t status;
 *   AUTOMATION_FB_HANDLE_t source_fb, destination_fb;
 *   init_status = DAVE_Init();    //Initialization of DAVE Apps
 *   status = AUTOMATION_FB_RegisterFunctionBlock(&source_fb);
 *   status = AUTOMATION_FB_RegisterFunctionBlock(&destination_fb);
 *   status = AUTOMATION_FB_AddConnectionEntry(&source_fb, 0, &destination_fb, 0);
 *   while(1U);
 *   return 1U;
 * }
 * @endcode
 */
AUTOMATION_STATUS_t AUTOMATION_FB_AddConnectionEntry(AUTOMATION_FB_HANDLE_t* const source_fb, const uint8_t out_signal_num,
                                      AUTOMATION_FB_HANDLE_t* const destination_fb, const uint8_t in_signal_num);

/**
 * @brief Connects two function blocks as per the entries in the connection table.
 * @return None
 * <BR>
 *
 * \par<b>Description: </b><br>
 * It maps the address of the source_fb[out_signal_num] to the destination_fb[in_signal_num]. This connects all the entries
 * in the connection table in one go.
 *
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   AUTOMATION_STATUS_t status;
 *   AUTOMATION_FB_HANDLE_t source_fb, destination_fb;
 *   init_status = DAVE_Init();    //Initialization of DAVE Apps
 *   status = AUTOMATION_FB_RegisterFunctionBlock(&source_fb);
 *   status = AUTOMATION_FB_RegisterFunctionBlock(&destination_fb);
 *   status = AUTOMATION_FB_AddConnectionEntry(&source_fb, 0, &destination_fb, 0);
 *   AUTOMATION_FB_Connect();
 *   while(1U);
 *   return 1U;
 * }
 * @endcode
 */
void AUTOMATION_FB_Connect(void);

/**
 * @brief Registers the state machine APP handler
 * @param HandlePtr state machine pointer related to APP
 * @param app_id APP index assigned by automation app
 * @return AUTOMATION_STATUS_t status of operation \n
 * AUTOMATION_STATUS_SUCCESS if registration is succssful \n
 * AUTOMATION_STATUS_FAILURE if app_id is invalid
 *
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Registers the state machine handler of type \ref AUTOMATION_SM_t.
 * State machine handler contains information of all the states and entry, action, exit functions to be called
 *
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   AUTOMATION_STATUS_t status;
 *   AUTOMATION_SM_t statemachine;
 *   uint8_t app_id;
 *   uint32_t test_handle;
 *   init_status = DAVE_Init();    //Initialization of DAVE Apps
 *   status = AUTOMATION_RegisterApp(&test_handle,"TestApp", &app_id);
 *   AUTOMATION_SM_RegisterStateMachine(&statemachine, app_id);
 *   while(1U);
 *   return 1U;
 * }
 * @endcode
 */
AUTOMATION_STATUS_t AUTOMATION_SM_RegisterStateMachine(AUTOMATION_SM_t* statemachine, uint8_t app_id );

/**
 * @brief Adds request for the change of state
 * @param statemachine state machine pointer related to APP
 * @param new_state state to which state machine should change
 * @return None
 * <BR>
 *
 * \par<b>Description: </b><br>
 * Requests for the state change. This only sets the flag and actual change of state happens when AUTOMATION_SM_Handler is executed.
 *
 * @code
 * #include "DAVE.h"
 * 
 * uint8_t state = 2;
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   AUTOMATION_SM_t statemachine;
 *   init_status = DAVE_Init();    //Initialization of DAVE Apps
 *   AUTOMATION_SM_RequestState(&statemachine, state);
 *   while(1U);
 *   return 1U;
 * }
 * @endcode
 */
void AUTOMATION_SM_RequestState( AUTOMATION_SM_t* statemachine, uint8_t new_state);

/**
 * @brief Executes state machine - calls registered function of the state and changes the state if requested.
 * @param statemachine state machine pointer related to APP
 * @return void
 * <BR>
 *
 * \par<b>Description: </b><br>
 * This is the main state machine handler. User need to call this periodically or register in task scheduler.
 * This handles the execution of the entry, action and exit function of a state and changes the state if \ref transition_request is set by
 * AUTOMATION_SM_RequestState() API.
 *
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   AUTOMATION_SM_t statemachine;
 *   init_status = DAVE_Init();    //Initialization of DAVE Apps
 *   AUTOMATION_SM_Handler(&statemachine);
 *   while(1U);
 *   return 1U;
 * }
 * @endcode
 */
void AUTOMATION_SM_Handler( AUTOMATION_SM_t* statemachine );

/**
 * @brief Return the state machine's current state
 * @param app_id APP index assigned by automation APP
 * @return uint8_t state of the state machine
 * <BR>
 * \par<b>Description: </b><br>
 * Gives information about the current state of state machine.
 *
 * @code
 * #include "DAVE.h"
 * 
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   AUTOMATION_STATUS_t status;
 *   AUTOMATION_SM_t statemachine;
 *   uint8_t app_id;
 *   uint8_t state;
 *   uint32_t test_handle;
 *   init_status = DAVE_Init();    //Initialization of DAVE Apps
 *   status = AUTOMATION_RegisterApp(&test_handle,"TestApp", &app_id);
 *   AUTOMATION_SM_RegisterStateMachine(&statemachine, app_id);
 * 
 *   state = AUTOMATION_SM_GetState(app_id);
 *   while(1U);
 *   return 1U;
 * }
 * @endcode
 */
uint8_t AUTOMATION_SM_GetState(uint8_t app_id);

/**
 * @}
 */

#include "automation_extern.h"


#ifdef __cplusplus
}
#endif

#endif /* AFW_H_ */
