/**
 * @file encoder_posif.c
 * @date 2021-01-08
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * ENCODER_POSIF v4.0.6 - To get the motor position and\nspeed using  incremental encoder.
 *
 * Copyright (c) 2015-2020, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-07-06:
 *     - Initial version
 *
 * 2019-11-26:
 *     - Added irqctrl field to ENCODER_POSIF_ISR_t for XMC14
 *
 * 2021-01-08:
 *     - Modified check for minimum XMCLib version
 *
 * @endcond
 *
 */
#ifndef ENCODER_POSIF_H_
#define ENCODER_POSIF_H_
/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#ifdef __cplusplus
extern "C" {
#endif

#include "xmc_gpio.h"
#include "xmc_scu.h"
#include "GLOBAL_POSIF/global_posif.h"
#include "GLOBAL_CCU4/global_ccu4.h"

#include "encoder_posif_conf.h"
#include "MOTOR_LIB/motor_lib.h"
#if (ENCODER_POSIF_ERU_AVAILABLE == 1U)
#include "xmc_eru.h"
#endif

/**********************************************************************************************************************
* MACROS
**********************************************************************************************************************/
#define ENCODER_POSIF_XMC_LIB_MAJOR_VERSION 2
#define ENCODER_POSIF_XMC_LIB_MINOR_VERSION 0
#define ENCODER_POSIF_XMC_LIB_PATCH_VERSION 0

#if !((XMC_LIB_MAJOR_VERSION > ENCODER_POSIF_XMC_LIB_MAJOR_VERSION) ||\
      ((XMC_LIB_MAJOR_VERSION == ENCODER_POSIF_XMC_LIB_MAJOR_VERSION) && (XMC_LIB_MINOR_VERSION > ENCODER_POSIF_XMC_LIB_MINOR_VERSION)) ||\
      ((XMC_LIB_MAJOR_VERSION == ENCODER_POSIF_XMC_LIB_MAJOR_VERSION) && (XMC_LIB_MINOR_VERSION == ENCODER_POSIF_XMC_LIB_MINOR_VERSION) && (XMC_LIB_PATCH_VERSION >= ENCODER_POSIF_XMC_LIB_PATCH_VERSION)))
#error "ENCODER_POSIF requires XMC Peripheral Library v2.0.0 or higher"
#endif

#define ENCODER_POSIF_MICROSECCONV            (1000000U)      /*!< This defines the value if only 2nd bit is enable in a variable*/
#define ENCODER_POSIF_TBT_PERIODVAL_PLUS_1    (65536U)
#define ENCODER_POSIF_2POWER10                (1023)
#define ENCODER_POSIF_2POWER16                (65535)
#define ENCODER_POSIF_15BITSHIFT              (15U)
#define ENCODER_POSIF_16BITSHIFT              (16U)
/**********************************************************************************************************************
* ENUMS
**********************************************************************************************************************/
/**
 * @ingroup ENCODER_POSIF_enumerations
 * @{
 */
/**
 * This enumerates Status of the app. Used during initialization.
 */
typedef enum ENCODER_POSIF_STATUS
{
  ENCODER_POSIF_STATUS_SUCCESS,              /*!< APP status success*/
  ENCODER_POSIF_STATUS_FAILURE,              /*!< APP status failure*/
  ENCODER_POSIF_STATUS_INVALID_PARAM         /*!< invalid parameters*/

} ENCODER_POSIF_STATUS_t;
/**
 * This enumerates state of the APP
 */
typedef enum ENCODER_POSIF_STATE
{
  ENCODER_POSIF_UNINITIALISED,  /*!< default state after power on reset*/
  ENCODER_POSIF_INITIALISED,    /*!< APP is in INITIALIZED state after execution of the Init function*/
  ENCODER_POSIF_RUNNING         /*!< This state is entered after starting of posif module*/

} ENCODER_POSIF_STATE_t;

/**
 * This enumerates the encoder type.
 */
typedef enum ENCODER_POSIF_ENCODER_TYPE
{
  ENCODER_POSIF_ENCODER_WITHOUT_INDEX_SIGNAL,
  ENCODER_POSIF_ENCODER_WITH_INDEX_SIGNAL
} ENCODER_POSIF_ENCODER_TYPE_t;
/**
 * This enumerates the angle extrapolation type.
 */
typedef enum ENCODER_POSIF_EXTRAPOLATION_TYPE
{
  ENCODER_POSIF_1ST_ORDER_EXTRAPOLATION,
  ENCODER_POSIF_2ND_ORDER_EXTRAPOLATION
} ENCODER_POSIF_EXTRAPOLATION_TYPE_t;
/**
 * This enumerates the encoder enable pin level.
 */
typedef enum ENCODER_POSIF_ENABLE_PINLEVEL
{
  ENCODER_POSIF_EPIN_DISABLED,
  ENCODER_POSIF_EPIN_LOW,
  ENCODER_POSIF_EPIN_HIGH
}ENCODER_POSIF_ENABLE_PINLEVEL_t;

/**
 * This enumerates the motor direction.
 */
typedef enum ENCODER_POSIF_Direction
{
  ENCODER_POSIF_ANTICLOCKWISE_DIRECTION,
  ENCODER_POSIF_CLOCKWISE_DIRECTION
}ENCODER_POSIF_Direction_t;
/**
 * @}
 */
/**********************************************************************************************************************
* DATA STRUCTURES
**********************************************************************************************************************/
/**
 * @ingroup ENCODER_POSIF_datastructures
 * @{
 */
/**
 * This structure holds the ISR configuration parameters.
 */
typedef struct ENCODER_POSIF_ISRHandle
{
  uint32_t                                  node_id;                   /*!< interrupt node id*/
  uint32_t                                  priority;                  /*!< interrupt priority*/
  uint32_t                                  sub_priority;              /*!< interrupt sub priority*/
#if (UC_SERIES == XMC14)
  XMC_SCU_IRQCTRL_t                         irqctrl;                   /*!< NVIC mux control */
#endif
}ENCODER_POSIF_ISR_t;
/**
 * This structure hold all the parameters related to GPIO resource.
 */
typedef struct ENCODER_POSIF_GPIO
{
  XMC_GPIO_PORT_t *const                    port;                      /*!< GPIO port */
  const uint8_t                             pin;                       /*!< GPIO pin */
} ENCODER_POSIF_GPIO_t;

/**
 *  @brief CCU4-CC4 slice identifier data
 */
typedef struct ENCODER_POSIF_CCU4_SLICE
{
  XMC_CCU4_SLICE_t*                         slice_ptr;                 /*!<CCU4 CC4 pointer */
  XMC_CCU4_MODULE_t*                        module_ptr;                /*!< Corresponding CCU4 Module Pointer */
  uint32_t                                  shadow_transfer_msk;       /*!< CCU4 slice shadow transfer mask value*/
  uint8_t                                   slice_number;              /*!< CCU4 slice number */
}ENCODER_POSIF_CCU4_SLICE_t;

#if (ENCODER_POSIF_ERU_AVAILABLE == 1U)
typedef struct  ENCODER_POSIF_ERU
{
  XMC_ERU_t* const                          eru;                       /*!< ERU module assigned(ERU0/ERU1) */
  const uint8_t                             ogu_channel;               /*!< ERU channel assigned(0-3) */
  const uint8_t                             etl_channel;               /*!< ERU channel assigned(0-3) */

}ENCODER_POSIF_ERU_t;
#endif
/**
 * This structure holds the parameters which change at run
 * time.
 */
typedef struct ENCODER_POSIF_Config
{
  ENCODER_POSIF_ENABLE_PINLEVEL_t           encoder_pin;                /*!< Encoder enable pin level settings*/
  ENCODER_POSIF_EXTRAPOLATION_TYPE_t        extrapolation_type;         /*!< This variable holds extrapolation type*/
  XMC_CCU4_SLICE_SR_ID_t                    timestamp_slice_pm_sr;      /*!< Trigger slice service request number*/
  XMC_CCU4_SLICE_SR_ID_t                    rev_counter_pm_sr;          /*!< Revolution counter slice service request number*/
  ENCODER_POSIF_ENCODER_TYPE_t              encoder_type;               /*!< Encoder type selection(i.e)with index/without index*/
  int32_t                                   angle_scale;                /*!< Angle scale - max angle resolution*/
  int32_t                                   speed_const;                /*!< Speed constant to measure speed in 0x3FFF format*/
  uint32_t                                  max_toffset;                /*!< max time offset for extrapolation*/
  uint32_t                                  module_frequency;           /*!< module frequency*/
  uint32_t                                  time_offset_scale;          /*!< time offset scale to convert nanosecond into count*/
  uint16_t                                  ticks_per_revolution;       /*!< number of ticks per revolution-period value of positon counter*/
  uint16_t                                  rev_counter_overflow;       /*!< Revolution counter overflow value*/
  uint16_t                                  timestamp_period;           /*!< Period value of trigger generator*/
  uint8_t                                   posif_qd_sr[5];             /*!< Service request for posif interrupts*/
  uint8_t                                   enable_eru[3];              /*!< Enable eru as input*/
  uint32_t                                  enable_revcnt_event:1;      /*!< Revolution count event enable*/
  uint32_t                                  enable_anglecalc_isr:1;     /*!< Angle calulation ISR enable*/
  uint32_t                                  enable_rev_counter:1;       /*!< revolution counter enable*/
  uint32_t                                  enable_index_evt:1;         /*!< index event enable*/
  uint32_t                                  enable_phaseerr_evt:1;      /*!< phase error event enable*/
  uint32_t                                  enable_dirchange_evt:1;     /*!< direction change event enable*/
  uint32_t                                  enable_qclk_evt:1;          /*!< quadrature clock event enable*/
  uint32_t                                  enable_pclk_evt:1;          /*!< period clock event enable*/
} ENCODER_POSIF_Config_t;

/**
 * This structure holds the configurable parameters of this app and address of 
 * sub structures associated with this app.
 */
typedef struct ENCODER_POSIF_Handle
{
  ENCODER_POSIF_GPIO_t*                     encoder_input_ptr[3];        /*!< Array of pointer to the GPIO pin structure*/
  ENCODER_POSIF_GPIO_t*                     encoder_enable_input_ptr;    /*!< Pointer to the encoder enable GPIO pin structure*/
  #if (ENCODER_POSIF_ERU_AVAILABLE == 1U)
  XMC_ERU_ETL_CONFIG_t*           const     etl_conf_ptr[3];             /*!< Array of pointer to the ETL configuration module*/
  ENCODER_POSIF_ERU_t*            const     etl_resource_ptr[3];         /*!< Array of pointer to the ETL resource configuration module*/
  XMC_ERU_OGU_CONFIG_t*           const     ogu_conf_ptr[3];             /*!< Array of pointer to the OGU resource configuration module*/
  #endif
  XMC_CCU4_SLICE_CAPTURE_CONFIG_t*const     position_counter_init_ptr;   /*!< Pointer to position counter init structure*/
  XMC_CCU4_SLICE_CAPTURE_CONFIG_t*const     revolution_counter_init_ptr; /*!< Pointer to revolution counter init structure*/
  XMC_CCU4_SLICE_CAPTURE_CONFIG_t*const     time_bw_ticks_init_ptr;      /*!< Pointer to time between ticks init structure*/
  XMC_CCU4_SLICE_COMPARE_CONFIG_t*const     trigger_slice_init_ptr;      /*!< Pointer to trigger generator init structure*/
  POSIF_GLOBAL_TypeDef*           const     global_ptr;                  /*!< This is the CMSIS register structure pointer for the POSIF module.*/
  ENCODER_POSIF_Config_t*         const     config_ptr;                  /*!< Structure pointer which holds the configuration data*/
  XMC_POSIF_QD_CONFIG_t*          const     posif_qd_ptr;                /*!< Pointer to the POSIF quadrature encoder module*/
  XMC_POSIF_CONFIG_t*             const     posifconfig_ptr;             /*!< Pointer to the POSIF config module*/
  ENCODER_POSIF_CCU4_SLICE_t*     const     position_counter_ptr;        /*!< Pointer to position counter slice structure*/
  ENCODER_POSIF_CCU4_SLICE_t*     const     revolution_counter_ptr;      /*!< Pointer to revolution counter slice structure*/
  ENCODER_POSIF_CCU4_SLICE_t*     const     time_bw_ticks_ptr;           /*!< Pointer to time between ticks slice structure*/
  ENCODER_POSIF_CCU4_SLICE_t*     const     timestamp_trigger_slice_ptr; /*!< Pointer to trigger generator slice structure*/
  XMC_CCU4_SLICE_EVENT_CONFIG_t*  const     timestamp_trigger_start_ptr; /*!< Pointer to trigger slice start event config structure*/
  XMC_CCU4_SLICE_EVENT_CONFIG_t*  const     pos_captureevent_ptr;        /*!< Pointer to position counter capture event structure*/
  XMC_CCU4_SLICE_EVENT_CONFIG_t*  const     rev_captureevent_ptr;        /*!< Pointer to revolution counter capture event structure*/
  XMC_CCU4_SLICE_EVENT_CONFIG_t*  const     tbt_captureevent_ptr;        /*!< Pointer to time between ticks capture event structure*/
  XMC_CCU4_SLICE_EVENT_CONFIG_t*  const     tbtp_captureevent_ptr;       /*!< Pointer to trigger at trigger point capture event structure*/
  XMC_CCU4_SLICE_EVENT_CONFIG_t*  const     pos_counterevent_ptr;        /*!< Pointer to position counter event structure*/
  XMC_CCU4_SLICE_EVENT_CONFIG_t*  const     pos_countdir_event_ptr;      /*!< Pointer to position counter direction counting event structure*/
  XMC_CCU4_SLICE_EVENT_CONFIG_t*  const     rev_counterevent_ptr;        /*!< Pointer to revolution counter capture event structure*/
  XMC_CCU4_SLICE_EVENT_CONFIG_t*  const     rev_countdir_event_ptr;      /*!< Pointer to revolution counter direction counting event structure*/
  XMC_GPIO_CONFIG_t *             const     encoder_pinconfig_ptr;       /*!< Pointer to the GPIO encoder pin configuration*/
  XMC_GPIO_CONFIG_t *             const     enable_enc_pin_cfg_ptr;      /*!< Pointer to the GPIO encoder enable pin configuration.*/
  GLOBAL_POSIF_t*                 const     global_posif_handle_ptr;     /*!< Pointer to the global_posif app handle.*/
  GLOBAL_CCU4_t*                  const     global_ccu4_handle_ptr;      /*!< Pointer to the global_ccu4 app handle.*/
  ENCODER_POSIF_ISR_t*            const     trigger_gen_isr_ptr;         /*!< Pointer to the trigger generator isr.*/
  MOTOR_LIB_PT1Handle_t*          const     speed_pt1_filter;            /*!< Pointer to the speed pt1 filter.*/
  ENCODER_POSIF_STATE_t                     state;                       /*!< This is the APP state.*/
  float                                     rotor_angle_2nd_order;       /*!< rotor angle based on 2nd order calculation*/
  int32_t                                   position_count;              /*!< position counter for 1st order calculation*/
  int32_t                                   revolution_count;            /*!< it is revolution counter*/
  int32_t                                   time_bw_ticks;               /*!< time captured between two ticks*/
  int32_t                                   time_bw_ticks_prev;          /*!< time captured between previous two ticks*/
  uint32_t                                  time_stamp_count;            /*!< time captured at configured trigger point*/
  uint32_t                                  time_offset;                 /*!< user required time offset in float*/
  int32_t                                   rotor_angle_1st_order;       /*!< rotor angle based on 1st order calculation*/
  int32_t                                   rotor_speed;                 /*!< rotor angle based on 1st order calculation*/
  uint32_t                                  absolute_poscount;           /*!< absolute position count from position counter*/
  int32_t                                   extrapolated_count;          /*!< extrapolated position count*/
  int32_t                                   rotor_angle_prev;            /*!< previous rotor angle*/
  int32_t                                   rotor_angle;                 /*!< final rotor angle*/
} ENCODER_POSIF_t;

/**
 * @}
 */
/**
 * @ingroup ENCODER_POSIF_apidoc
 * @{
 */
/***********************************************************************************************************************
 * API Prototypes
 **********************************************************************************************************************/
/**
 * @brief Get ENCODER_POSIF APP version
 * @return DAVE_APP_VERSION_t APP version information (major, minor and patch number)
 *
 * \par<b>Description: </b><br>
 * The function can be used to check application software compatibility with a
 * specific version of the APP.
 *
 * Example Usage:
 *
 * @code
 * #include "DAVE.h"
 *
 * int main(void) {
 *   DAVE_STATUS_t init_status;
 *   DAVE_APP_VERSION_t version;
 *
 *   // ENCODER_POSIF_Init() is called from DAVE_Init().
 *   init_status = DAVE_Init();
 *
 *   version = ENCODER_POSIF_GetAppVersion();
 *
 *   // More code here
 *
 *   while(1) {
 *
 *   }
 *   return (0);
 * }
 * @endcode<BR>
 */
DAVE_APP_VERSION_t ENCODER_POSIF_GetAppVersion(void);
/**
 * @brief This function initialize the ENCODER_POSIF APP as per user configured values.
 * @param HandlePtr pointer to an object of ENCODER_POSIF module
 * @return ENCODER_POSIF_STATUS_t: status of the operation
 * <BR>
 * \par<b>Description: </b><br>
 *  This API is called in definition of DAVE_init or top level APP, by code generation
 *  and therefore should not be explicitly called for the normal operation.
 *  Using other APIs only after DAVE_init is called successfully (returns DAVE_STATUS_SUCCESS).\n
 *
 * Example Usage:
 *
 * <BR>
 * @code
 * #include "DAVE.h"
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *
 *   // ENCODER_POSIF_Init(&ENCODER_POSIF_0) is called from DAVE_Init().
 *   init_status = DAVE_Init();
 *
 *   // More code here
 *
 *   while(1) {
 *
 *   }
 *   return (0);
 * }
 * @endcode<BR>
 */
ENCODER_POSIF_STATUS_t ENCODER_POSIF_Init(ENCODER_POSIF_t * const HandlePtr);
/**
 * @brief This API starts the ccu4 timer clock and then start the POSIF module.
 * @param HandlePtr pointer to an object of ENCODER_POSIF module
 * @return <b>void</b>
 * <BR>
 * \par<b>Description: </b><br>
 * Invoke this API when APP state is ENCODER_POSIF_INITIALISED or else this API will have no effect on functionality.\n
 *
 * Example Usage:
 * <BR>
 * @code
 * #include "DAVE.h"
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   status = DAVE_Init();                 // Initialization of DAVE APPs
 *
 *   if(status == DAVE_STATUS_SUCCESS)
 *   {
 *     ENCODER_POSIF_Start(&ENCODER_POSIF_0);
 *   }
 *   while(1U)
 *   {
 *
 *   }
 * }
 * @endcode<BR>
 */
void ENCODER_POSIF_Start(ENCODER_POSIF_t * const HandlePtr);
/**
 * @brief This function will stop POSIF and CCU4 slice.
 * @param HandlePtr pointer to an object of ENCODER_POSIF module
 * @return <b>void</b>
 * <BR>
 * \par<b>Description: </b><br>
 * Invoke this API when module is running.
 * Any operation on the ENCODER_POSIF module will have no effect after this API is called.
 * <BR>
 * \par<b>Note:</b><br>
 * Invoke this API when APP state is ENCODER_POSIF_RUNNING or else it has no effect on functionality.
 * <BR>
 *
 * Example Usage:
 * <BR>
 * @code
 * #include "DAVE.h"
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   status = DAVE_Init();                 // Initialization of DAVE APPs
 *
 *   if(status == DAVE_STATUS_SUCCESS)
 *   {
 *     ENCODER_POSIF_Start(&ENCODER_POSIF_0);
 *   }
 *
 *   ENCODER_POSIF_Stop(&ENCODER_POSIF_0);  // call when ENCODER_POSIF_0.state == ENCODER_POSIF_RUNNING
 *   
 *   while(1U)
 *   {
 *
 *   }
 * }
 * @endcode<BR>
 */
void ENCODER_POSIF_Stop(ENCODER_POSIF_t * const HandlePtr);

/**
 * @brief This function will return the rotor angle(with MSB aligned 24 bit resolution).
 * @param HandlePtr pointer to an object of ENCODER_POSIF module
 * @return <b>int32_t</b>
 * \par<b>Description: </b><br>
 * This function will return the rotor angle(with MSB aligned 24 bit resolution).Invoke this API when module is running.
 * <BR>
 * \par<b>Note:</b><br>
 * Invoke this API when APP state is ENCODER_POSIF_RUNNING or else it has no effect on functionality.
 * <BR>
 * Example Usage:
 * <BR>
 *
 * @code
 * #include "DAVE.h"
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   int32_t angle;
 *   init_status = DAVE_Init();
 *   ENCODER_POSIF_Start(&ENCODER_POSIF_0);
 *   while(1U)
 *   {
 *     angle = ENCODER_POSIF_GetRotorAngle(&ENCODER_POSIF_0);
 *   }
 * }
 * @endcode<BR>
 */
int32_t ENCODER_POSIF_GetRotorAngle(ENCODER_POSIF_t * const HandlePtr,uint32_t t_offset);
/**
 * @brief The time toffset is one which tells angle extrapolation time for future
 * @param HandlePtr pointer to an object of ENCODER_POSIF module
 * @return <b>ENCODER_POSIF_STATUS_t</b>
 * \par<b>Description: </b><br>
 * The time toffset is one which tells angle extrapolation time for future.This function will set the toffset in nanoseconds.
 * <BR>
 * Example Usage:
 * <BR>
 *
 * @code
 * #include "DAVE.h"
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   ENCODER_POSIF_STATUS_t status;
 *   init_status = DAVE_Init();
 *   ENCODER_POSIF_Start(&ENCODER_POSIF_0);
 *   status = ENCODER_POSIF_SetToffset(&ENCODER_POSIF_0,25000);
 *
 *   while(1U)
 *   {
 *
 *   }
 * }
 * @endcode<BR>
 */
ENCODER_POSIF_STATUS_t ENCODER_POSIF_SetToffset(ENCODER_POSIF_t* const HandlePtr, uint32_t Toffset);
/**
 * @brief This function will return the speed of rotation in 2^14 scale.
 * @param HandlePtr pointer to an object of ENCODER_POSIF module
 * @return <b>int32_t</b>
 * \par<b>Description: </b><br>
 * This function will return the rotor speed in 2^14 scale.Invoke this API in ISR .
 * <BR>
 * \par<b>Note:</b><br>
 * Invoke this API when APP state is ENCODER_POSIF_RUNNING or else it has no effect on functionality.
 * <BR>
 * Example Usage:
 * <BR>
 *
 * @code
 * #include "DAVE.h"
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   int32_t speed;
 *   init_status = DAVE_Init();
 *   ENCODER_POSIF_Start(&ENCODER_POSIF_0);
 *   while(1U)
 *   {
 *
 *   }
 * }
 * @endcode<BR>
 */
int32_t ENCODER_POSIF_SpeedCalculation(ENCODER_POSIF_t* const HandlePtr);
/**
 * @brief This function will return the number of motor revolution count.
 * @param HandlePtr pointer to an object of ENCODER_POSIF module
 * @return <b>int32_t</b>
 * \par<b>Description: </b><br>
 * This function will return the motor revolution count.Invoke this API when module is running.
 * <BR>
 * \par<b>Note:</b><br>
 * Invoke this API when APP state is ENCODER_POSIF_RUNNING or else it has no effect on functionality.
 * <BR>
 * Example Usage:
 * <BR>
 *
 * @code
 * #include "DAVE.h"
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   int32_t rev_cnt;
 *   init_status = DAVE_Init();
 *   ENCODER_POSIF_Start(&ENCODER_POSIF_0);
 *
 *
 *   while(1U)
 *   {
 *     rev_cnt = ENCODER_POSIF_GetRevolutionCount(&ENCODER_POSIF_0);
 *   }
 * }
 * @endcode<BR>
 */
int32_t ENCODER_POSIF_GetRevolutionCount(ENCODER_POSIF_t * const HandlePtr);
/**
 * @brief This function will return the current direction of rotation.
 * @param HandlePtr pointer to an object of ENCODER_POSIF module
 * @return <b>ENCODER_POSIF_Direction_t</b>
 * \par<b>Description: </b><br>
 * This function will return the current direction of rotation..Invoke this API when module is running.<br>
 * ENCODER_POSIF_ANTICLOCKWISE_DIRECTION<br>
 * ENCODER_POSIF_CLOCKWISE_DIRECTION<br>
 * <BR>
 * Example Usage:
 * <BR>
 *
 * @code
 * #include "DAVE.h"
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   ENCODER_POSIF_Direction_t dir;
 *   init_status = DAVE_Init();
 *   ENCODER_POSIF_Start(&ENCODER_POSIF_0);
 *   dir = ENCODER_POSIF_GetDirection(&ENCODER_POSIF_0);
 *
 *   while(1U)
 *   {
 *
 *   }
 * }
 * @endcode<BR>
 */
__STATIC_INLINE ENCODER_POSIF_Direction_t ENCODER_POSIF_GetDirection(ENCODER_POSIF_t * const HandlePtr)
{
  return ((ENCODER_POSIF_Direction_t)XMC_POSIF_QD_GetDirection(HandlePtr->global_ptr));
}
/**
 * @brief Enables the encoder enable pin.
 * @param HandlePtr Pointer of the APP user configuration\n
 * @return void
 * \par<b>Description:</b><br>
 * Function enables encoder pin if applicable \n
 * Calling this API sets or resets the encoder enable pin based on active level
 * configuration.<br>
 * calling this function will not have any effect if encoder enable pin configuration
 * is set to disabled in GUI.
 * Example Usage:
 * @code
   #include "DAVE.h"
   int main (void)
   {
     DAVE_STATUS_t status;
     status = DAVE_Init(); //ENCODER_POSIF_Init() called by DAVE_Init()
     ENCODER_POSIF_Start((ENCODER_POSIF_t*)&ENCODER_POSIF_0);
     //Do something
     ENCODER_POSIF_EncoderEnable((ENCODER_POSIF_t*)&ENCODER_POSIF_0);
     while(1);
     return 0;
   }
 * @endcode
 * \par<b>Related APIs:</b><br>
 * ENCODER_POSIF_EncoderDisable()
 */
void ENCODER_POSIF_EncoderEnable(ENCODER_POSIF_t* const HandlePtr);
/**
 * @brief Disables the encoder enable pin.
 * @param HandlePtr Pointer of the APP user configuration\n
 * @return void
 * \par<b>Description:</b><br>
 * Function disables encoder pin if applicable \n
 * Calling this API sets or resets the encoder enable pin based on active level
 * configuration.<br>
 * calling this function will not have any effect if encoder enable pin configuration
 * is set to disabled in GUI.
 * Example Usage:
 * @code
   #include "DAVE.h"
   int main (void)
   {
     DAVE_STATUS_t status;
     status = DAVE_Init(); //ENCODER_POSIF_Init() called by DAVE_Init()
     ENCODER_POSIF_Start((ENCODER_POSIF_t*)&ENCODER_POSIF_0);
     //Do something
     ENCODER_POSIF_EncoderDisable((ENCODER_POSIF_t*)&ENCODER_POSIF_0);
     while(1);
     return 0;
   }
 * @endcode
 * \par<b>Related APIs:</b><br>
 * ENCODER_POSIF_EncoderEnable()
 */
void ENCODER_POSIF_EncoderDisable(ENCODER_POSIF_t* const HandlePtr);

#include "encoder_posif_extern.h"

/**
 * @}
 */
#ifdef __cplusplus
}
#endif

#endif /* ENCODER_POSIF_H_ */

