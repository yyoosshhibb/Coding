/**
 * @file encoder_posif.c
 * @date 2015-07-06
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * ENCODER_POSIF v4.0.6 - To get the motor position and\nspeed using  incremental encoder.
 *
 * Copyright (c) 2015-2020, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-07-06:
 *     - Initial version
 *
 * 2019-11-26:
 *     - Added irqctrl field to ENCODER_POSIF_ISR_t for XMC14
 *
 * @endcond
 *
 */


/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#include "encoder_posif.h"
/***********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/

/***********************************************************************************************************************
 * LOCAL DATA
 **********************************************************************************************************************/

/***********************************************************************************************************************
 * LOCAL ROUTINES
 **********************************************************************************************************************/
/**
 * This function initializes all gpio pins
 */
static void ENCODER_POSIF_GPIO_Init(ENCODER_POSIF_t* const HandlePtr);
/**
 * This function initializes isr for timer stamp trigger slice
 */
static void ENCODER_POSIF_TimeStampISR_Config(ENCODER_POSIF_t* const HandlePtr);
/**
 * This function performs revolution counter configuration
 */
static void ENCODER_POSIF_RevolutionCounterConfig(ENCODER_POSIF_t* const HandlePtr);
/**
 * This function enables confugred events
 */
void ENCODER_POSIF_EventEnable(ENCODER_POSIF_t* const HandlePtr);
/**
 * This function disables the event if it is configured
 */
void ENCODER_POSIF_EventDisable(ENCODER_POSIF_t* const HandlePtr);
#if (UC_FAMILY == XMC4)
/**
 * This function calculates angle based on 2nd order extrapolation technique
 */
int32_t ENCODER_POSIF_2ndOrder_AngleCalculation(ENCODER_POSIF_t* const HandlePtr);
#endif
/**
 * This function calculates angle based on 1st order extrapolation technique
 */
int32_t ENCODER_POSIF_1stOrder_AngleCalculation(ENCODER_POSIF_t* const HandlePtr);
/**
 * This function reads the captured timer count from capture register(CV)
 */
void ENCODER_POSIF_ReadCaptureValue(ENCODER_POSIF_t* const HandlePtr);
/**
 * This function initiates the ISR
 */
static void ENCODER_POSIF_ISRInit(ENCODER_POSIF_ISR_t*const HandlePtr);
static void ENCODER_POSIF_RevolutionCounterConfig(ENCODER_POSIF_t* const HandlePtr)
{
  if(1U == HandlePtr->config_ptr->enable_rev_counter)
  {
    XMC_CCU4_SLICE_CaptureInit(HandlePtr->revolution_counter_ptr->slice_ptr, HandlePtr->revolution_counter_init_ptr);
    XMC_CCU4_SLICE_SetTimerPeriodMatch(HandlePtr->revolution_counter_ptr->slice_ptr, HandlePtr->config_ptr->rev_counter_overflow);
    /*counts based on position counter period match event(falling edge of ST)*/
    XMC_CCU4_SLICE_CountConfig(HandlePtr->revolution_counter_ptr->slice_ptr, XMC_CCU4_SLICE_EVENT_0);
    /*POSIFx_OUT1 is mapped to event 1 to take care of direction*/
    XMC_CCU4_SLICE_DirectionConfig(HandlePtr->revolution_counter_ptr->slice_ptr, XMC_CCU4_SLICE_EVENT_1);
    /*capture channel 0 is used to capture revolution at time stamp trigger*/
    XMC_CCU4_SLICE_Capture0Config(HandlePtr->revolution_counter_ptr->slice_ptr, XMC_CCU4_SLICE_EVENT_2);
    XMC_CCU4_SLICE_ConfigureEvent(HandlePtr->revolution_counter_ptr->slice_ptr, XMC_CCU4_SLICE_EVENT_0,
                                                                              HandlePtr->rev_counterevent_ptr);
    XMC_CCU4_SLICE_ConfigureEvent(HandlePtr->revolution_counter_ptr->slice_ptr, XMC_CCU4_SLICE_EVENT_1,
                                                                              HandlePtr->rev_countdir_event_ptr);
    XMC_CCU4_SLICE_ConfigureEvent(HandlePtr->revolution_counter_ptr->slice_ptr, XMC_CCU4_SLICE_EVENT_2,
                                                                              HandlePtr->rev_captureevent_ptr);
    if(1U == HandlePtr->config_ptr->enable_revcnt_event)
    {
      XMC_CCU4_SLICE_EnableEvent(HandlePtr->revolution_counter_ptr->slice_ptr,XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH);
      /*CCU4 interrupt node configuration*/
      XMC_CCU4_SLICE_SetInterruptNode(HandlePtr->revolution_counter_ptr->slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH,
                                                                           HandlePtr->config_ptr->rev_counter_pm_sr);
    }
    XMC_CCU4_EnableShadowTransfer(HandlePtr->revolution_counter_ptr->module_ptr,
		                        HandlePtr->revolution_counter_ptr->shadow_transfer_msk);

  }
}
static void ENCODER_POSIF_TimeStampISR_Config(ENCODER_POSIF_t* const HandlePtr)
{
  if(1U == HandlePtr->config_ptr->enable_anglecalc_isr)
  {
    ENCODER_POSIF_ISRInit(HandlePtr->trigger_gen_isr_ptr);
    XMC_CCU4_SLICE_EnableEvent(HandlePtr->timestamp_trigger_slice_ptr->slice_ptr,XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH);
  }
}
static void ENCODER_POSIF_GPIO_Init(ENCODER_POSIF_t* const HandlePtr)
{
  /*GPIO initialization for phases*/
  XMC_GPIO_Init(HandlePtr->encoder_input_ptr[0]->port, HandlePtr->encoder_input_ptr[0]->pin,
                                                     HandlePtr->encoder_pinconfig_ptr);
  XMC_GPIO_Init(HandlePtr->encoder_input_ptr[1]->port, HandlePtr->encoder_input_ptr[1]->pin,
                                                     HandlePtr->encoder_pinconfig_ptr);
  /*GPIO initialization for index pin*/
  if (ENCODER_POSIF_ENCODER_WITH_INDEX_SIGNAL == HandlePtr->config_ptr->encoder_type)
  {
    XMC_GPIO_Init(HandlePtr->encoder_input_ptr[2]->port, HandlePtr->encoder_input_ptr[2]->pin,
                                                       HandlePtr->encoder_pinconfig_ptr);
  }
  /*GPIO initialization for encoder enable pin*/
  if (ENCODER_POSIF_EPIN_DISABLED != HandlePtr->config_ptr->encoder_pin)
  {
    XMC_GPIO_Init(HandlePtr->encoder_enable_input_ptr->port, HandlePtr->encoder_enable_input_ptr->pin,
                                                           HandlePtr->enable_enc_pin_cfg_ptr);
  }
}
/**
 * This function enables encoder
 */
void ENCODER_POSIF_EncoderEnable(ENCODER_POSIF_t* const HandlePtr)
{
  /*Encoder Enable pin settings.*/
  if (ENCODER_POSIF_EPIN_HIGH == HandlePtr->config_ptr->encoder_pin)
  {
    XMC_GPIO_SetOutputHigh(HandlePtr->encoder_enable_input_ptr->port,HandlePtr->encoder_enable_input_ptr->pin);
  }
  if (ENCODER_POSIF_EPIN_LOW == HandlePtr->config_ptr->encoder_pin)
  {
    XMC_GPIO_SetOutputLow(HandlePtr->encoder_enable_input_ptr->port,HandlePtr->encoder_enable_input_ptr->pin);
  }
}
/**
 * This function disables encoder
 */
void ENCODER_POSIF_EncoderDisable(ENCODER_POSIF_t* const HandlePtr)
{
  /*Encoder Disable pin settings.*/
  if (ENCODER_POSIF_EPIN_HIGH == HandlePtr->config_ptr->encoder_pin)
  {
    XMC_GPIO_SetOutputLow(HandlePtr->encoder_enable_input_ptr->port,HandlePtr->encoder_enable_input_ptr->pin);
  }
  if (ENCODER_POSIF_EPIN_LOW == HandlePtr->config_ptr->encoder_pin)
  {
    XMC_GPIO_SetOutputHigh(HandlePtr->encoder_enable_input_ptr->port,HandlePtr->encoder_enable_input_ptr->pin);
  }
}
/*
 * This function enables the posif events
 */
void ENCODER_POSIF_EventEnable(ENCODER_POSIF_t* const HandlePtr)
{
  if(1U == HandlePtr->config_ptr->enable_index_evt)
  {
	/*Enable index event*/
    XMC_POSIF_EnableEvent(HandlePtr->global_ptr,XMC_POSIF_IRQ_EVENT_INDX);
  }
  if(1U == HandlePtr->config_ptr->enable_phaseerr_evt)
  {
    /*Enable phase error event*/
    XMC_POSIF_EnableEvent(HandlePtr->global_ptr,XMC_POSIF_IRQ_EVENT_ERR);
  }
  if(1U == HandlePtr->config_ptr->enable_dirchange_evt)
  {
    /*Enable direction change event*/
    XMC_POSIF_EnableEvent(HandlePtr->global_ptr,XMC_POSIF_IRQ_EVENT_DIR);
  }
  if(1U == HandlePtr->config_ptr->enable_qclk_evt)
  {
	/*Enable Qclock event*/
    XMC_POSIF_EnableEvent(HandlePtr->global_ptr,XMC_POSIF_IRQ_EVENT_CNT);
  }
  if(1U == HandlePtr->config_ptr->enable_pclk_evt)
  {
    /*Enable Pclock event*/
    XMC_POSIF_EnableEvent(HandlePtr->global_ptr,XMC_POSIF_IRQ_EVENT_PCLK);
  }
}
/*
 * This function disables the posif events
 */
void ENCODER_POSIF_EventDisable(ENCODER_POSIF_t* const HandlePtr)
{
  if(1U == HandlePtr->config_ptr->enable_index_evt)
  {
	/*Disable index event*/
    XMC_POSIF_DisableEvent(HandlePtr->global_ptr,XMC_POSIF_IRQ_EVENT_INDX);
  }
  if(1U == HandlePtr->config_ptr->enable_phaseerr_evt)
  {
	/*Disable phase error event*/
    XMC_POSIF_DisableEvent(HandlePtr->global_ptr,XMC_POSIF_IRQ_EVENT_ERR);
  }
  if(1U == HandlePtr->config_ptr->enable_dirchange_evt)
  {
	/*Disable direction change event*/
    XMC_POSIF_DisableEvent(HandlePtr->global_ptr,XMC_POSIF_IRQ_EVENT_DIR);
  }
  if(1U == HandlePtr->config_ptr->enable_qclk_evt)
  {
	/*Disable Qclock event*/
    XMC_POSIF_DisableEvent(HandlePtr->global_ptr,XMC_POSIF_IRQ_EVENT_CNT);
  }
  if(1U == HandlePtr->config_ptr->enable_pclk_evt)
  {
	/*Disable Pclock event*/
    XMC_POSIF_DisableEvent(HandlePtr->global_ptr,XMC_POSIF_IRQ_EVENT_PCLK);
  }
}
/*
 * This function reads captured value from capture register
 */
void ENCODER_POSIF_ReadCaptureValue(ENCODER_POSIF_t* const HandlePtr)
{
  uint32_t abs_poscount;
  uint32_t time_bw_ticks;
  #if (UC_FAMILY == XMC4)
  uint32_t time_bw_ticks_prev;
  #endif
  uint32_t time_trigger_point;
  /*Absolute position count  from capture register 1*/
  abs_poscount = XMC_CCU4_SLICE_GetCaptureRegisterValue(HandlePtr->position_counter_ptr->slice_ptr, (uint8_t) 1);
  HandlePtr->absolute_poscount = (uint32_t)(abs_poscount & (uint32_t) 0xFFFF);

  /*time between ticks from capture register 1*/
  time_bw_ticks = XMC_CCU4_SLICE_GetCaptureRegisterValue(HandlePtr->time_bw_ticks_ptr->slice_ptr, (uint8_t) 1);
  time_bw_ticks      = (time_bw_ticks & (uint32_t) 0xFFFF);
  HandlePtr->time_bw_ticks = (int32_t)(time_bw_ticks);

  /*time between tick and time stamp point from capture register 3*/
  time_trigger_point = XMC_CCU4_SLICE_GetCaptureRegisterValue(HandlePtr->time_bw_ticks_ptr->slice_ptr, (uint8_t) 3);
  HandlePtr->time_stamp_count = (uint32_t)(time_trigger_point & (uint32_t) 0xFFFF);

  #if (UC_FAMILY == XMC4)
  if(ENCODER_POSIF_2ND_ORDER_EXTRAPOLATION == HandlePtr->config_ptr->extrapolation_type)
  {
    /*Previous time between ticks from capture register 0*/
    time_bw_ticks_prev = XMC_CCU4_SLICE_GetCaptureRegisterValue(HandlePtr->time_bw_ticks_ptr->slice_ptr, (uint8_t) 0);
    time_bw_ticks_prev = (uint32_t)((uint32_t)time_bw_ticks_prev & (uint32_t)0xFFFF);
    HandlePtr->time_bw_ticks_prev = (int32_t)(time_bw_ticks_prev);
  }
  #endif
}
/*
 * First order angle calculation
 */
int32_t ENCODER_POSIF_1stOrder_AngleCalculation(ENCODER_POSIF_t* const HandlePtr)
{
  uint32_t extrapolated_count;
  uint32_t abspos_count;
  int32_t rotor_angle_1st_order;
  int32_t time_bw_ticks;
  ENCODER_POSIF_ReadCaptureValue(HandlePtr);
  /*
   * extrapolated_angle1 = (Capture time between last tick and capture trigger point + time_offset)/time between ticks
   */
  extrapolated_count             = ((HandlePtr->time_stamp_count + HandlePtr->time_offset) << ENCODER_POSIF_15BITSHIFT);
  abspos_count                   = (HandlePtr->absolute_poscount << ENCODER_POSIF_16BITSHIFT);
  time_bw_ticks                  = HandlePtr->time_bw_ticks;
  if(time_bw_ticks != 0)
  {
    HandlePtr->extrapolated_count  = ((int32_t)extrapolated_count/(HandlePtr->time_bw_ticks));
  }
  /*rotorangle= (absolute pos count + extrapolated_angle1) * (2^16/No.of ticks)*/
  rotor_angle_1st_order          = (HandlePtr->extrapolated_count + (int32_t)abspos_count) *
                                                           HandlePtr->config_ptr->angle_scale;
  /*right shift 16 bit and return to make result as 16 bit angle*/
  return (rotor_angle_1st_order);
}

#if (UC_FAMILY == XMC4)
/*
 * Second order angle calculation
 */
int32_t ENCODER_POSIF_2ndOrder_AngleCalculation(ENCODER_POSIF_t* const HandlePtr)
{
  float extrapolated_count1;
  float extrapolated_count2;
  float angle_sqr_half;
  ENCODER_POSIF_ReadCaptureValue(HandlePtr);
  /*
   * extrapolated_angle1 = (Capture time between last tick and capture trigger point + time_offset)/time between ticks
   */
  extrapolated_count1            = (((float)HandlePtr->time_stamp_count + (float)HandlePtr->time_offset)/
		                              (float)HandlePtr->time_bw_ticks);
  /*(Angle^2)/2*/
  angle_sqr_half                 = ((extrapolated_count1 * extrapolated_count1)/2.0f);

  /*1-(Capture time between last tick/Capture time between second last tick)*/
  extrapolated_count2            = 1.0f - (float)((float)HandlePtr->time_bw_ticks/(float)HandlePtr->time_bw_ticks_prev);

  extrapolated_count2            = angle_sqr_half * extrapolated_count2;

  /*(absolute position count + extrapolated_count2 + extrapolated_count1) * scale*/
  HandlePtr->rotor_angle_2nd_order = ((float)HandlePtr->absolute_poscount + extrapolated_count1 + extrapolated_count2) *
                                                                            (float)HandlePtr->config_ptr->angle_scale;
  return ((int32_t)((int32_t)HandlePtr->rotor_angle_2nd_order*255));

}
#endif

/**********************************************************************************************************************
* API IMPLEMENTATION
**********************************************************************************************************************/
/* Returns the version of the ENCODER_POSIF App. */
DAVE_APP_VERSION_t ENCODER_POSIF_GetAppVersion(void)
{
  DAVE_APP_VERSION_t version;

  version.major = ENCODER_POSIF_MAJOR_VERSION;
  version.minor = ENCODER_POSIF_MINOR_VERSION;
  version.patch = ENCODER_POSIF_PATCH_VERSION;

  return version;
}
/*
 * This function configure the the NVIC Node.
 */
static void ENCODER_POSIF_ISRInit(ENCODER_POSIF_ISR_t*const HandlePtr)
{
  /*set the priority and sub priority*/
#if (UC_FAMILY == XMC1)
  NVIC_SetPriority((IRQn_Type)HandlePtr->node_id,(uint32_t)HandlePtr->priority);
#else
  NVIC_SetPriority((IRQn_Type)HandlePtr->node_id,
                    NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
                   (uint32_t)HandlePtr->priority,(uint32_t)HandlePtr->sub_priority));
#endif

#if (UC_SERIES == XMC14)
  XMC_SCU_SetInterruptControl((IRQn_Type)HandlePtr->node_id, HandlePtr->irqctrl);
#endif

  /*Enable the IRQ*/
  NVIC_EnableIRQ((IRQn_Type)HandlePtr->node_id);
}
/**
 * This function initializes the encoder_posif App and low level app.
 */
ENCODER_POSIF_STATUS_t ENCODER_POSIF_Init(ENCODER_POSIF_t * const HandlePtr)
{
  ENCODER_POSIF_STATUS_t status = ENCODER_POSIF_STATUS_SUCCESS;

#if (ENCODER_POSIF_ERU_AVAILABLE == 1U)
  uint32_t etl_count = 0U;
#endif
  if (ENCODER_POSIF_UNINITIALISED == HandlePtr->state)
  {

    if (ENCODER_POSIF_STATUS_FAILURE == (ENCODER_POSIF_STATUS_t) GLOBAL_POSIF_Init(HandlePtr->global_posif_handle_ptr))
    {
      /* Failure during GLOBAL_POSIF app initialization */
      status = ENCODER_POSIF_STATUS_FAILURE;
    }

    if (ENCODER_POSIF_STATUS_FAILURE == (ENCODER_POSIF_STATUS_t) GLOBAL_CCU4_Init(HandlePtr->global_ccu4_handle_ptr))
    {
      /* Failure during GLOBAL_CCU4 app initialization */
      status = ENCODER_POSIF_STATUS_FAILURE;
    }

    XMC_POSIF_Init(HandlePtr->global_ptr, HandlePtr->posifconfig_ptr);

    if (ENCODER_POSIF_STATUS_FAILURE
        == (ENCODER_POSIF_STATUS_t) XMC_POSIF_QD_Init(HandlePtr->global_ptr, HandlePtr->posif_qd_ptr))
    {
      /* Failure during posif mode configuration */
      status = ENCODER_POSIF_STATUS_FAILURE;
    }

    if(status == ENCODER_POSIF_STATUS_SUCCESS)
    {
      #if (ENCODER_POSIF_ERU_AVAILABLE == 1U)
      /* ERU initialization */
      for(etl_count=0; etl_count<3; etl_count++)
      {
        if( HandlePtr->config_ptr->enable_eru[etl_count] == 1U)
        {
          XMC_ERU_ETL_Init( HandlePtr->etl_resource_ptr[etl_count]->eru,HandlePtr->etl_resource_ptr[etl_count]->etl_channel,
                                                                      HandlePtr->etl_conf_ptr[etl_count]);
          XMC_ERU_OGU_Init( HandlePtr->etl_resource_ptr[etl_count]->eru,HandlePtr->etl_resource_ptr[etl_count]->ogu_channel,
                                                                      HandlePtr->ogu_conf_ptr[etl_count]);
        }
      }
      #endif
      ENCODER_POSIF_GPIO_Init(HandlePtr);
      /*capture/compare init*/
      XMC_CCU4_SLICE_CaptureInit(HandlePtr->position_counter_ptr->slice_ptr, HandlePtr->position_counter_init_ptr);
      XMC_CCU4_SLICE_CaptureInit(HandlePtr->time_bw_ticks_ptr->slice_ptr, HandlePtr->time_bw_ticks_init_ptr);
      XMC_CCU4_SLICE_CompareInit(HandlePtr->timestamp_trigger_slice_ptr->slice_ptr, HandlePtr->trigger_slice_init_ptr);
      XMC_CCU4_SLICE_SetTimerPeriodMatch(HandlePtr->timestamp_trigger_slice_ptr->slice_ptr,
                                                                HandlePtr->config_ptr->timestamp_period);
      XMC_CCU4_SLICE_SetTimerCompareMatch(HandlePtr->timestamp_trigger_slice_ptr->slice_ptr, 2U);
      /* Configure external start to event 0 */
      XMC_CCU4_SLICE_ConfigureEvent(HandlePtr->timestamp_trigger_slice_ptr->slice_ptr,XMC_CCU4_SLICE_EVENT_0,
    		                                                              HandlePtr->timestamp_trigger_start_ptr);
      XMC_CCU4_SLICE_SetTimerPeriodMatch(HandlePtr->position_counter_ptr->slice_ptr,
                                       HandlePtr->config_ptr->ticks_per_revolution);
      XMC_CCU4_SLICE_SetTimerCompareMatch(HandlePtr->position_counter_ptr->slice_ptr, 1U);
      XMC_CCU4_SLICE_CountConfig(HandlePtr->position_counter_ptr->slice_ptr, XMC_CCU4_SLICE_EVENT_0);
      XMC_CCU4_SLICE_DirectionConfig(HandlePtr->position_counter_ptr->slice_ptr, XMC_CCU4_SLICE_EVENT_1);
      /*capture channel 0 is used to capture position at trigger stamp time*/
      XMC_CCU4_SLICE_Capture0Config(HandlePtr->position_counter_ptr->slice_ptr, XMC_CCU4_SLICE_EVENT_2);
      /*position counter event configuration*/
      XMC_CCU4_SLICE_ConfigureEvent(HandlePtr->position_counter_ptr->slice_ptr, XMC_CCU4_SLICE_EVENT_0,
                                                                              HandlePtr->pos_counterevent_ptr);
      XMC_CCU4_SLICE_ConfigureEvent(HandlePtr->position_counter_ptr->slice_ptr, XMC_CCU4_SLICE_EVENT_1,
                                                                              HandlePtr->pos_countdir_event_ptr);
      XMC_CCU4_SLICE_ConfigureEvent(HandlePtr->position_counter_ptr->slice_ptr, XMC_CCU4_SLICE_EVENT_2,
                                                                              HandlePtr->pos_captureevent_ptr);
      /*time between ticks counter event configuration
       *it uses both the capture channels
       *cap0 is used capture time at ticks pulse
       *cap1 is used to capture time at time stamp trigger*/
      XMC_CCU4_SLICE_Capture0Config(HandlePtr->time_bw_ticks_ptr->slice_ptr, XMC_CCU4_SLICE_EVENT_0);
      XMC_CCU4_SLICE_Capture1Config(HandlePtr->time_bw_ticks_ptr->slice_ptr, XMC_CCU4_SLICE_EVENT_1);
      /*time between ticks counter event configuration*/
      XMC_CCU4_SLICE_ConfigureEvent(HandlePtr->time_bw_ticks_ptr->slice_ptr, XMC_CCU4_SLICE_EVENT_0,
                                                                           HandlePtr->tbt_captureevent_ptr);
      XMC_CCU4_SLICE_ConfigureEvent(HandlePtr->time_bw_ticks_ptr->slice_ptr, XMC_CCU4_SLICE_EVENT_1,
                                                                           HandlePtr->tbtp_captureevent_ptr);
      /* ISR initialization for time stamp trigger timer*/
      ENCODER_POSIF_TimeStampISR_Config(HandlePtr);
      /*shadow transfer*/
      XMC_CCU4_EnableShadowTransfer(HandlePtr->position_counter_ptr->module_ptr,
                                  HandlePtr->position_counter_ptr->shadow_transfer_msk);
      XMC_CCU4_EnableShadowTransfer(HandlePtr->time_bw_ticks_ptr->module_ptr,
                                  HandlePtr->time_bw_ticks_ptr->shadow_transfer_msk);
      XMC_CCU4_EnableShadowTransfer(HandlePtr->timestamp_trigger_slice_ptr->module_ptr,
                                  HandlePtr->timestamp_trigger_slice_ptr->shadow_transfer_msk);

      /*Revolution counter configuration*/
      ENCODER_POSIF_RevolutionCounterConfig(HandlePtr);
      /*CCU4 interrupt node configuration*/
      XMC_CCU4_SLICE_SetInterruptNode(HandlePtr->timestamp_trigger_slice_ptr->slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH,
                                                                           HandlePtr->config_ptr->timestamp_slice_pm_sr);

      /*Posif interrupt node configuration*/
      XMC_POSIF_SetInterruptNode(HandlePtr->global_ptr, XMC_POSIF_IRQ_EVENT_INDX,
                               (XMC_POSIF_SR_ID_t)HandlePtr->config_ptr->posif_qd_sr[0]);
      XMC_POSIF_SetInterruptNode(HandlePtr->global_ptr, XMC_POSIF_IRQ_EVENT_ERR,
                               (XMC_POSIF_SR_ID_t)HandlePtr->config_ptr->posif_qd_sr[1]);
      XMC_POSIF_SetInterruptNode(HandlePtr->global_ptr, XMC_POSIF_IRQ_EVENT_CNT,
                               (XMC_POSIF_SR_ID_t)HandlePtr->config_ptr->posif_qd_sr[2]);
      XMC_POSIF_SetInterruptNode(HandlePtr->global_ptr, XMC_POSIF_IRQ_EVENT_DIR,
                               (XMC_POSIF_SR_ID_t)HandlePtr->config_ptr->posif_qd_sr[3]);
      XMC_POSIF_SetInterruptNode(HandlePtr->global_ptr, XMC_POSIF_IRQ_EVENT_PCLK,
                               (XMC_POSIF_SR_ID_t)HandlePtr->config_ptr->posif_qd_sr[4]);
    }

    if (status != ENCODER_POSIF_STATUS_FAILURE)
    {
      HandlePtr->state = ENCODER_POSIF_INITIALISED;
    }
  }
  return status;
}

void ENCODER_POSIF_Start(ENCODER_POSIF_t* const HandlePtr)
{
  if (HandlePtr->state == ENCODER_POSIF_INITIALISED)
  {
    HandlePtr->state = ENCODER_POSIF_RUNNING;
    /* Clear IDLE mode.*/
    XMC_CCU4_EnableClock(HandlePtr->position_counter_ptr->module_ptr,HandlePtr->position_counter_ptr->slice_number);
    XMC_CCU4_EnableClock(HandlePtr->time_bw_ticks_ptr->module_ptr, HandlePtr->time_bw_ticks_ptr->slice_number);
    XMC_CCU4_EnableClock(HandlePtr->timestamp_trigger_slice_ptr->module_ptr, HandlePtr->timestamp_trigger_slice_ptr->slice_number);
    if(1U == HandlePtr->config_ptr->enable_rev_counter)
    {
      XMC_CCU4_EnableClock(HandlePtr->revolution_counter_ptr->module_ptr,
                           HandlePtr->revolution_counter_ptr->slice_number);
      XMC_CCU4_SLICE_StartTimer(HandlePtr->revolution_counter_ptr->slice_ptr);
    }
    ENCODER_POSIF_EventEnable(HandlePtr);
    /* configure the Start trigger function*/
    XMC_CCU4_SLICE_StartConfig(HandlePtr->timestamp_trigger_slice_ptr->slice_ptr, XMC_CCU4_SLICE_EVENT_0,
                                                                        XMC_CCU4_SLICE_START_MODE_TIMER_START_CLEAR);
    ENCODER_POSIF_EncoderEnable(HandlePtr);
    XMC_POSIF_Start(HandlePtr->global_ptr);
    XMC_CCU4_SLICE_StartTimer(HandlePtr->time_bw_ticks_ptr->slice_ptr);
    XMC_CCU4_SLICE_StartTimer(HandlePtr->position_counter_ptr->slice_ptr);
  }
}

void ENCODER_POSIF_Stop(ENCODER_POSIF_t* const HandlePtr)
{
  if (HandlePtr->state == ENCODER_POSIF_RUNNING)
  {
    HandlePtr->state = ENCODER_POSIF_INITIALISED;
    ENCODER_POSIF_EncoderDisable(HandlePtr);
    ENCODER_POSIF_EventDisable(HandlePtr);
    XMC_POSIF_Stop(HandlePtr->global_ptr);
    XMC_CCU4_SLICE_StopTimer(HandlePtr->time_bw_ticks_ptr->slice_ptr);
    XMC_CCU4_SLICE_StopTimer(HandlePtr->timestamp_trigger_slice_ptr->slice_ptr);
  }
}

int32_t ENCODER_POSIF_GetRotorAngle(ENCODER_POSIF_t* const HandlePtr,uint32_t t_offset)
{
  int32_t rotor_angle;
  HandlePtr->time_offset =
      (uint32_t)(((uint32_t)(t_offset * HandlePtr->config_ptr->time_offset_scale))/ENCODER_POSIF_MICROSECCONV);
#if (UC_FAMILY == XMC4)
  if(ENCODER_POSIF_2ND_ORDER_EXTRAPOLATION == HandlePtr->config_ptr->extrapolation_type)
  {
    rotor_angle = ENCODER_POSIF_2ndOrder_AngleCalculation(HandlePtr);
  }
  else
  {
#endif
    rotor_angle = ENCODER_POSIF_1stOrder_AngleCalculation(HandlePtr);
#if (UC_FAMILY == XMC4)
  }
#endif
  return (rotor_angle);
}
/*This API sets the Toffset value in terms of nano seconds*/
ENCODER_POSIF_STATUS_t ENCODER_POSIF_SetToffset(ENCODER_POSIF_t* const HandlePtr, uint32_t t_offset)
{
  ENCODER_POSIF_STATUS_t status = ENCODER_POSIF_STATUS_SUCCESS;
  if(t_offset <= HandlePtr->config_ptr->max_toffset)
  {
    /* calculate the Toffset to Toffset count*/
    HandlePtr->time_offset =
        (uint32_t)(((uint32_t)(t_offset * HandlePtr->config_ptr->time_offset_scale))/ENCODER_POSIF_MICROSECCONV);
  }
  else
  {
    status = ENCODER_POSIF_STATUS_INVALID_PARAM;
  }
  return (status);
}

int32_t ENCODER_POSIF_SpeedCalculation(ENCODER_POSIF_t* const HandlePtr)
{
  int16_t speed = 0;

  uint32_t time_bw_ticks;

  time_bw_ticks = XMC_CCU4_SLICE_GetCaptureRegisterValue(HandlePtr->time_bw_ticks_ptr->slice_ptr, (uint8_t) 1);

  time_bw_ticks      = (time_bw_ticks & (uint32_t) 0xFFFF);

  HandlePtr->time_bw_ticks = (int32_t)(time_bw_ticks);

  if(HandlePtr->time_bw_ticks != 0)
  {
    speed = (int16_t)((HandlePtr->config_ptr->speed_const)/(HandlePtr->time_bw_ticks));
  }
  if(ENCODER_POSIF_ANTICLOCKWISE_DIRECTION ==
                             (ENCODER_POSIF_Direction_t)(((POSIF0->QDC & POSIF_QDC_DVAL_Msk)>>8U)))
  {
    speed = (int16_t)(speed * -1);
  }
  MOTOR_LIB_PT1Controller(HandlePtr->speed_pt1_filter,(int32_t)(speed));

  return(HandlePtr->speed_pt1_filter->pt1_out_val);
}
int32_t ENCODER_POSIF_GetRevolutionCount(ENCODER_POSIF_t * const HandlePtr)
{
  uint32_t revolution_count;
  if(1U == HandlePtr->config_ptr->enable_rev_counter)
  {
	/*Read capture register value from capture channel 0*/
    revolution_count = XMC_CCU4_SLICE_GetCaptureRegisterValue(HandlePtr->revolution_counter_ptr->slice_ptr, (uint8_t) 1);
    revolution_count = (uint32_t)(revolution_count & (uint32_t) 0xFFFF);
    HandlePtr->revolution_count = (int32_t)revolution_count;
  }
  else
  {
    HandlePtr->revolution_count = 0;
  }
  return (HandlePtr->revolution_count);
}


