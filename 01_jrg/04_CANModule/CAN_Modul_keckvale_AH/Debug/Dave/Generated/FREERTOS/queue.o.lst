   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,6
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "queue.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .comm xQueueRegistry,64,4
  20              	 .section .text.xQueueGenericReset,"ax",%progbits
  21              	 .align 2
  22              	 .global xQueueGenericReset
  23              	 .thumb
  24              	 .thumb_func
  26              	xQueueGenericReset:
  27              	.LFB137:
  28              	 .file 1 "../Dave/Generated/FREERTOS/queue.c"
   1:../Dave/Generated/FREERTOS/queue.c **** /*
   2:../Dave/Generated/FREERTOS/queue.c ****  * FreeRTOS Kernel V10.0.1
   3:../Dave/Generated/FREERTOS/queue.c ****  * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:../Dave/Generated/FREERTOS/queue.c ****  *
   5:../Dave/Generated/FREERTOS/queue.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:../Dave/Generated/FREERTOS/queue.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:../Dave/Generated/FREERTOS/queue.c ****  * the Software without restriction, including without limitation the rights to
   8:../Dave/Generated/FREERTOS/queue.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:../Dave/Generated/FREERTOS/queue.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:../Dave/Generated/FREERTOS/queue.c ****  * subject to the following conditions:
  11:../Dave/Generated/FREERTOS/queue.c ****  *
  12:../Dave/Generated/FREERTOS/queue.c ****  * The above copyright notice and this permission notice shall be included in all
  13:../Dave/Generated/FREERTOS/queue.c ****  * copies or substantial portions of the Software.
  14:../Dave/Generated/FREERTOS/queue.c ****  *
  15:../Dave/Generated/FREERTOS/queue.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:../Dave/Generated/FREERTOS/queue.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:../Dave/Generated/FREERTOS/queue.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:../Dave/Generated/FREERTOS/queue.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:../Dave/Generated/FREERTOS/queue.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:../Dave/Generated/FREERTOS/queue.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:../Dave/Generated/FREERTOS/queue.c ****  *
  22:../Dave/Generated/FREERTOS/queue.c ****  * http://www.FreeRTOS.org
  23:../Dave/Generated/FREERTOS/queue.c ****  * http://aws.amazon.com/freertos
  24:../Dave/Generated/FREERTOS/queue.c ****  *
  25:../Dave/Generated/FREERTOS/queue.c ****  * 1 tab == 4 spaces!
  26:../Dave/Generated/FREERTOS/queue.c ****  */
  27:../Dave/Generated/FREERTOS/queue.c **** 
  28:../Dave/Generated/FREERTOS/queue.c **** #include <stdlib.h>
  29:../Dave/Generated/FREERTOS/queue.c **** #include <string.h>
  30:../Dave/Generated/FREERTOS/queue.c **** 
  31:../Dave/Generated/FREERTOS/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  32:../Dave/Generated/FREERTOS/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  33:../Dave/Generated/FREERTOS/queue.c **** task.h is included from an application file. */
  34:../Dave/Generated/FREERTOS/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  35:../Dave/Generated/FREERTOS/queue.c **** 
  36:../Dave/Generated/FREERTOS/queue.c **** #include "FreeRTOS.h"
  37:../Dave/Generated/FREERTOS/queue.c **** #include "task.h"
  38:../Dave/Generated/FREERTOS/queue.c **** #include "queue.h"
  39:../Dave/Generated/FREERTOS/queue.c **** 
  40:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  41:../Dave/Generated/FREERTOS/queue.c **** 	#include "croutine.h"
  42:../Dave/Generated/FREERTOS/queue.c **** #endif
  43:../Dave/Generated/FREERTOS/queue.c **** 
  44:../Dave/Generated/FREERTOS/queue.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  45:../Dave/Generated/FREERTOS/queue.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  46:../Dave/Generated/FREERTOS/queue.c **** header files above, but not in this file, in order to generate the correct
  47:../Dave/Generated/FREERTOS/queue.c **** privileged Vs unprivileged linkage and placement. */
  48:../Dave/Generated/FREERTOS/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  49:../Dave/Generated/FREERTOS/queue.c **** 
  50:../Dave/Generated/FREERTOS/queue.c **** 
  51:../Dave/Generated/FREERTOS/queue.c **** /* Constants used with the cRxLock and cTxLock structure members. */
  52:../Dave/Generated/FREERTOS/queue.c **** #define queueUNLOCKED					( ( int8_t ) -1 )
  53:../Dave/Generated/FREERTOS/queue.c **** #define queueLOCKED_UNMODIFIED			( ( int8_t ) 0 )
  54:../Dave/Generated/FREERTOS/queue.c **** 
  55:../Dave/Generated/FREERTOS/queue.c **** /* When the Queue_t structure is used to represent a base queue its pcHead and
  56:../Dave/Generated/FREERTOS/queue.c **** pcTail members are used as pointers into the queue storage area.  When the
  57:../Dave/Generated/FREERTOS/queue.c **** Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
  58:../Dave/Generated/FREERTOS/queue.c **** not necessary, and the pcHead pointer is set to NULL to indicate that the
  59:../Dave/Generated/FREERTOS/queue.c **** pcTail pointer actually points to the mutex holder (if any).  Map alternative
  60:../Dave/Generated/FREERTOS/queue.c **** names to the pcHead and pcTail structure members to ensure the readability of
  61:../Dave/Generated/FREERTOS/queue.c **** the code is maintained despite this dual use of two structure members.  An
  62:../Dave/Generated/FREERTOS/queue.c **** alternative implementation would be to use a union, but use of a union is
  63:../Dave/Generated/FREERTOS/queue.c **** against the coding standard (although an exception to the standard has been
  64:../Dave/Generated/FREERTOS/queue.c **** permitted where the dual use also significantly changes the type of the
  65:../Dave/Generated/FREERTOS/queue.c **** structure member). */
  66:../Dave/Generated/FREERTOS/queue.c **** #define pxMutexHolder					pcTail
  67:../Dave/Generated/FREERTOS/queue.c **** #define uxQueueType						pcHead
  68:../Dave/Generated/FREERTOS/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
  69:../Dave/Generated/FREERTOS/queue.c **** 
  70:../Dave/Generated/FREERTOS/queue.c **** /* Semaphores do not actually store or copy data, so have an item size of
  71:../Dave/Generated/FREERTOS/queue.c **** zero. */
  72:../Dave/Generated/FREERTOS/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
  73:../Dave/Generated/FREERTOS/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
  74:../Dave/Generated/FREERTOS/queue.c **** 
  75:../Dave/Generated/FREERTOS/queue.c **** #if( configUSE_PREEMPTION == 0 )
  76:../Dave/Generated/FREERTOS/queue.c **** 	/* If the cooperative scheduler is being used then a yield should not be
  77:../Dave/Generated/FREERTOS/queue.c **** 	performed just because a higher priority task has been woken. */
  78:../Dave/Generated/FREERTOS/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION()
  79:../Dave/Generated/FREERTOS/queue.c **** #else
  80:../Dave/Generated/FREERTOS/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
  81:../Dave/Generated/FREERTOS/queue.c **** #endif
  82:../Dave/Generated/FREERTOS/queue.c **** 
  83:../Dave/Generated/FREERTOS/queue.c **** /*
  84:../Dave/Generated/FREERTOS/queue.c ****  * Definition of the queue used by the scheduler.
  85:../Dave/Generated/FREERTOS/queue.c ****  * Items are queued by copy, not reference.  See the following link for the
  86:../Dave/Generated/FREERTOS/queue.c ****  * rationale: http://www.freertos.org/Embedded-RTOS-Queues.html
  87:../Dave/Generated/FREERTOS/queue.c ****  */
  88:../Dave/Generated/FREERTOS/queue.c **** typedef struct QueueDefinition
  89:../Dave/Generated/FREERTOS/queue.c **** {
  90:../Dave/Generated/FREERTOS/queue.c **** 	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
  91:../Dave/Generated/FREERTOS/queue.c **** 	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte i
  92:../Dave/Generated/FREERTOS/queue.c **** 	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
  93:../Dave/Generated/FREERTOS/queue.c **** 
  94:../Dave/Generated/FREERTOS/queue.c **** 	union							/* Use of a union is an exception to the coding standard to ensure two mutually exclus
  95:../Dave/Generated/FREERTOS/queue.c **** 	{
  96:../Dave/Generated/FREERTOS/queue.c **** 		int8_t *pcReadFrom;			/*< Points to the last place that a queued item was read from when the stru
  97:../Dave/Generated/FREERTOS/queue.c **** 		UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex h
  98:../Dave/Generated/FREERTOS/queue.c **** 	} u;
  99:../Dave/Generated/FREERTOS/queue.c **** 
 100:../Dave/Generated/FREERTOS/queue.c **** 	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  
 101:../Dave/Generated/FREERTOS/queue.c **** 	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.
 102:../Dave/Generated/FREERTOS/queue.c **** 
 103:../Dave/Generated/FREERTOS/queue.c **** 	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
 104:../Dave/Generated/FREERTOS/queue.c **** 	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, n
 105:../Dave/Generated/FREERTOS/queue.c **** 	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
 106:../Dave/Generated/FREERTOS/queue.c **** 
 107:../Dave/Generated/FREERTOS/queue.c **** 	volatile int8_t cRxLock;		/*< Stores the number of items received from the queue (removed from the
 108:../Dave/Generated/FREERTOS/queue.c **** 	volatile int8_t cTxLock;		/*< Stores the number of items transmitted to the queue (added to the qu
 109:../Dave/Generated/FREERTOS/queue.c **** 
 110:../Dave/Generated/FREERTOS/queue.c **** 	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 111:../Dave/Generated/FREERTOS/queue.c **** 		uint8_t ucStaticallyAllocated;	/*< Set to pdTRUE if the memory used by the queue was statically a
 112:../Dave/Generated/FREERTOS/queue.c **** 	#endif
 113:../Dave/Generated/FREERTOS/queue.c **** 
 114:../Dave/Generated/FREERTOS/queue.c **** 	#if ( configUSE_QUEUE_SETS == 1 )
 115:../Dave/Generated/FREERTOS/queue.c **** 		struct QueueDefinition *pxQueueSetContainer;
 116:../Dave/Generated/FREERTOS/queue.c **** 	#endif
 117:../Dave/Generated/FREERTOS/queue.c **** 
 118:../Dave/Generated/FREERTOS/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 119:../Dave/Generated/FREERTOS/queue.c **** 		UBaseType_t uxQueueNumber;
 120:../Dave/Generated/FREERTOS/queue.c **** 		uint8_t ucQueueType;
 121:../Dave/Generated/FREERTOS/queue.c **** 	#endif
 122:../Dave/Generated/FREERTOS/queue.c **** 
 123:../Dave/Generated/FREERTOS/queue.c **** } xQUEUE;
 124:../Dave/Generated/FREERTOS/queue.c **** 
 125:../Dave/Generated/FREERTOS/queue.c **** /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
 126:../Dave/Generated/FREERTOS/queue.c **** name below to enable the use of older kernel aware debuggers. */
 127:../Dave/Generated/FREERTOS/queue.c **** typedef xQUEUE Queue_t;
 128:../Dave/Generated/FREERTOS/queue.c **** 
 129:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 130:../Dave/Generated/FREERTOS/queue.c **** 
 131:../Dave/Generated/FREERTOS/queue.c **** /*
 132:../Dave/Generated/FREERTOS/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 133:../Dave/Generated/FREERTOS/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 134:../Dave/Generated/FREERTOS/queue.c ****  */
 135:../Dave/Generated/FREERTOS/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
 136:../Dave/Generated/FREERTOS/queue.c **** 
 137:../Dave/Generated/FREERTOS/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 138:../Dave/Generated/FREERTOS/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 139:../Dave/Generated/FREERTOS/queue.c **** 	more user friendly. */
 140:../Dave/Generated/FREERTOS/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 141:../Dave/Generated/FREERTOS/queue.c **** 	{
 142:../Dave/Generated/FREERTOS/queue.c **** 		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single c
 143:../Dave/Generated/FREERTOS/queue.c **** 		QueueHandle_t xHandle;
 144:../Dave/Generated/FREERTOS/queue.c **** 	} xQueueRegistryItem;
 145:../Dave/Generated/FREERTOS/queue.c **** 
 146:../Dave/Generated/FREERTOS/queue.c **** 	/* The old xQueueRegistryItem name is maintained above then typedefed to the
 147:../Dave/Generated/FREERTOS/queue.c **** 	new xQueueRegistryItem name below to enable the use of older kernel aware
 148:../Dave/Generated/FREERTOS/queue.c **** 	debuggers. */
 149:../Dave/Generated/FREERTOS/queue.c **** 	typedef xQueueRegistryItem QueueRegistryItem_t;
 150:../Dave/Generated/FREERTOS/queue.c **** 
 151:../Dave/Generated/FREERTOS/queue.c **** 	/* The queue registry is simply an array of QueueRegistryItem_t structures.
 152:../Dave/Generated/FREERTOS/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 153:../Dave/Generated/FREERTOS/queue.c **** 	array position being vacant. */
 154:../Dave/Generated/FREERTOS/queue.c **** 	PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 155:../Dave/Generated/FREERTOS/queue.c **** 
 156:../Dave/Generated/FREERTOS/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
 157:../Dave/Generated/FREERTOS/queue.c **** 
 158:../Dave/Generated/FREERTOS/queue.c **** /*
 159:../Dave/Generated/FREERTOS/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 160:../Dave/Generated/FREERTOS/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 161:../Dave/Generated/FREERTOS/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 162:../Dave/Generated/FREERTOS/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 163:../Dave/Generated/FREERTOS/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 164:../Dave/Generated/FREERTOS/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 165:../Dave/Generated/FREERTOS/queue.c ****  */
 166:../Dave/Generated/FREERTOS/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
 167:../Dave/Generated/FREERTOS/queue.c **** 
 168:../Dave/Generated/FREERTOS/queue.c **** /*
 169:../Dave/Generated/FREERTOS/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 170:../Dave/Generated/FREERTOS/queue.c ****  *
 171:../Dave/Generated/FREERTOS/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 172:../Dave/Generated/FREERTOS/queue.c ****  */
 173:../Dave/Generated/FREERTOS/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 174:../Dave/Generated/FREERTOS/queue.c **** 
 175:../Dave/Generated/FREERTOS/queue.c **** /*
 176:../Dave/Generated/FREERTOS/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 177:../Dave/Generated/FREERTOS/queue.c ****  *
 178:../Dave/Generated/FREERTOS/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 179:../Dave/Generated/FREERTOS/queue.c ****  */
 180:../Dave/Generated/FREERTOS/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 181:../Dave/Generated/FREERTOS/queue.c **** 
 182:../Dave/Generated/FREERTOS/queue.c **** /*
 183:../Dave/Generated/FREERTOS/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 184:../Dave/Generated/FREERTOS/queue.c ****  * back of the queue.
 185:../Dave/Generated/FREERTOS/queue.c ****  */
 186:../Dave/Generated/FREERTOS/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
 187:../Dave/Generated/FREERTOS/queue.c **** 
 188:../Dave/Generated/FREERTOS/queue.c **** /*
 189:../Dave/Generated/FREERTOS/queue.c ****  * Copies an item out of a queue.
 190:../Dave/Generated/FREERTOS/queue.c ****  */
 191:../Dave/Generated/FREERTOS/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCT
 192:../Dave/Generated/FREERTOS/queue.c **** 
 193:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
 194:../Dave/Generated/FREERTOS/queue.c **** 	/*
 195:../Dave/Generated/FREERTOS/queue.c **** 	 * Checks to see if a queue is a member of a queue set, and if so, notifies
 196:../Dave/Generated/FREERTOS/queue.c **** 	 * the queue set that the queue contains data.
 197:../Dave/Generated/FREERTOS/queue.c **** 	 */
 198:../Dave/Generated/FREERTOS/queue.c **** 	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCop
 199:../Dave/Generated/FREERTOS/queue.c **** #endif
 200:../Dave/Generated/FREERTOS/queue.c **** 
 201:../Dave/Generated/FREERTOS/queue.c **** /*
 202:../Dave/Generated/FREERTOS/queue.c ****  * Called after a Queue_t structure has been allocated either statically or
 203:../Dave/Generated/FREERTOS/queue.c ****  * dynamically to fill in the structure's members.
 204:../Dave/Generated/FREERTOS/queue.c ****  */
 205:../Dave/Generated/FREERTOS/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, u
 206:../Dave/Generated/FREERTOS/queue.c **** 
 207:../Dave/Generated/FREERTOS/queue.c **** /*
 208:../Dave/Generated/FREERTOS/queue.c ****  * Mutexes are a special type of queue.  When a mutex is created, first the
 209:../Dave/Generated/FREERTOS/queue.c ****  * queue is created, then prvInitialiseMutex() is called to configure the queue
 210:../Dave/Generated/FREERTOS/queue.c ****  * as a mutex.
 211:../Dave/Generated/FREERTOS/queue.c ****  */
 212:../Dave/Generated/FREERTOS/queue.c **** #if( configUSE_MUTEXES == 1 )
 213:../Dave/Generated/FREERTOS/queue.c **** 	static void prvInitialiseMutex( Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;
 214:../Dave/Generated/FREERTOS/queue.c **** #endif
 215:../Dave/Generated/FREERTOS/queue.c **** 
 216:../Dave/Generated/FREERTOS/queue.c **** #if( configUSE_MUTEXES == 1 )
 217:../Dave/Generated/FREERTOS/queue.c **** 	/*
 218:../Dave/Generated/FREERTOS/queue.c **** 	 * If a task waiting for a mutex causes the mutex holder to inherit a
 219:../Dave/Generated/FREERTOS/queue.c **** 	 * priority, but the waiting task times out, then the holder should
 220:../Dave/Generated/FREERTOS/queue.c **** 	 * disinherit the priority - but only down to the highest priority of any
 221:../Dave/Generated/FREERTOS/queue.c **** 	 * other tasks that are waiting for the same mutex.  This function returns
 222:../Dave/Generated/FREERTOS/queue.c **** 	 * that priority.
 223:../Dave/Generated/FREERTOS/queue.c **** 	 */
 224:../Dave/Generated/FREERTOS/queue.c **** 	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue ) PRIVILEGE
 225:../Dave/Generated/FREERTOS/queue.c **** #endif
 226:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 227:../Dave/Generated/FREERTOS/queue.c **** 
 228:../Dave/Generated/FREERTOS/queue.c **** /*
 229:../Dave/Generated/FREERTOS/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 230:../Dave/Generated/FREERTOS/queue.c ****  * accessing the queue event lists.
 231:../Dave/Generated/FREERTOS/queue.c ****  */
 232:../Dave/Generated/FREERTOS/queue.c **** #define prvLockQueue( pxQueue )								\
 233:../Dave/Generated/FREERTOS/queue.c **** 	taskENTER_CRITICAL();									\
 234:../Dave/Generated/FREERTOS/queue.c **** 	{														\
 235:../Dave/Generated/FREERTOS/queue.c **** 		if( ( pxQueue )->cRxLock == queueUNLOCKED )			\
 236:../Dave/Generated/FREERTOS/queue.c **** 		{													\
 237:../Dave/Generated/FREERTOS/queue.c **** 			( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED;	\
 238:../Dave/Generated/FREERTOS/queue.c **** 		}													\
 239:../Dave/Generated/FREERTOS/queue.c **** 		if( ( pxQueue )->cTxLock == queueUNLOCKED )			\
 240:../Dave/Generated/FREERTOS/queue.c **** 		{													\
 241:../Dave/Generated/FREERTOS/queue.c **** 			( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED;	\
 242:../Dave/Generated/FREERTOS/queue.c **** 		}													\
 243:../Dave/Generated/FREERTOS/queue.c **** 	}														\
 244:../Dave/Generated/FREERTOS/queue.c **** 	taskEXIT_CRITICAL()
 245:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 246:../Dave/Generated/FREERTOS/queue.c **** 
 247:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
 248:../Dave/Generated/FREERTOS/queue.c **** {
  29              	 .loc 1 248 0
  30              	 .cfi_startproc
  31              	 
  32              	 
  33 0000 80B5     	 push {r7,lr}
  34              	 .cfi_def_cfa_offset 8
  35              	 .cfi_offset 7,-8
  36              	 .cfi_offset 14,-4
  37 0002 84B0     	 sub sp,sp,#16
  38              	 .cfi_def_cfa_offset 24
  39 0004 00AF     	 add r7,sp,#0
  40              	 .cfi_def_cfa_register 7
  41 0006 7860     	 str r0,[r7,#4]
  42 0008 3960     	 str r1,[r7]
 249:../Dave/Generated/FREERTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
  43              	 .loc 1 249 0
  44 000a 7B68     	 ldr r3,[r7,#4]
  45 000c FB60     	 str r3,[r7,#12]
 250:../Dave/Generated/FREERTOS/queue.c **** 
 251:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue );
  46              	 .loc 1 251 0
  47 000e FB68     	 ldr r3,[r7,#12]
  48 0010 002B     	 cmp r3,#0
  49 0012 09D1     	 bne .L2
  50              	.LBB108:
  51              	.LBB109:
  52              	 .file 2 "../Dave/Generated/FREERTOS/portable/GCC/portmacro.h"
   1:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*
   2:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * FreeRTOS Kernel V10.0.1
   3:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  *
   5:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * this software and associated documentation files (the "Software"), to deal in
   7:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * the Software without restriction, including without limitation the rights to
   8:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * subject to the following conditions:
  11:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  *
  12:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * The above copyright notice and this permission notice shall be included in all
  13:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * copies or substantial portions of the Software.
  14:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  *
  15:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  *
  22:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * http://www.FreeRTOS.org
  23:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * http://aws.amazon.com/freertos
  24:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  *
  25:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * 1 tab == 4 spaces!
  26:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  */
  27:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  28:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  29:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #ifndef PORTMACRO_H
  30:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define PORTMACRO_H
  31:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  32:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #ifdef __cplusplus
  33:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** extern "C" {
  34:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #endif
  35:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  36:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*-----------------------------------------------------------
  37:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * Port specific definitions.
  38:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  *
  39:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * The settings in this file configure FreeRTOS correctly for the
  40:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * given hardware and compiler.
  41:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  *
  42:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * These settings should not be altered.
  43:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  *-----------------------------------------------------------
  44:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  */
  45:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  46:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /* Type definitions. */
  47:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portCHAR		char
  48:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portFLOAT		float
  49:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portDOUBLE		double
  50:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portLONG		long
  51:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portSHORT		short
  52:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portSTACK_TYPE	uint32_t
  53:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portBASE_TYPE	long
  54:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  55:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** typedef portSTACK_TYPE StackType_t;
  56:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** typedef long BaseType_t;
  57:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** typedef unsigned long UBaseType_t;
  58:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  59:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #if( configUSE_16_BIT_TICKS == 1 )
  60:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	typedef uint16_t TickType_t;
  61:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#define portMAX_DELAY ( TickType_t ) 0xffff
  62:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #else
  63:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	typedef uint32_t TickType_t;
  64:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
  65:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  66:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
  67:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	not need to be guarded with a critical section. */
  68:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#define portTICK_TYPE_IS_ATOMIC 1
  69:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #endif
  70:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*-----------------------------------------------------------*/
  71:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  72:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /* Architecture specifics. */
  73:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portSTACK_GROWTH			( -1 )
  74:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
  75:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portBYTE_ALIGNMENT			8
  76:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*-----------------------------------------------------------*/
  77:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  78:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /* Scheduler utilities. */
  79:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portYIELD() 															\
  80:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** {																				\
  81:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	/* Set a PendSV to request a context switch. */								\
  82:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
  83:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 																				\
  84:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	/* Barriers are normally not required but do ensure the code is completely	\
  85:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	within the specified behaviour for the architecture. */						\
  86:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	__asm volatile( "dsb" ::: "memory" );										\
  87:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	__asm volatile( "isb" );													\
  88:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** }
  89:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  90:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
  91:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
  92:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD()
  93:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
  94:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*-----------------------------------------------------------*/
  95:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  96:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /* Critical section management. */
  97:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** extern void vPortEnterCritical( void );
  98:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** extern void vPortExitCritical( void );
  99:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
 100:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)
 101:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
 102:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portENABLE_INTERRUPTS()					vPortSetBASEPRI(0)
 103:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portENTER_CRITICAL()					vPortEnterCritical()
 104:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portEXIT_CRITICAL()						vPortExitCritical()
 105:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 106:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*-----------------------------------------------------------*/
 107:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 108:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /* Task function macros as described on the FreeRTOS.org WEB site.  These are
 109:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** not necessary for to use this port.  They are defined so the common demo files
 110:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** (which build with all the ports) will build. */
 111:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
 112:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
 113:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*-----------------------------------------------------------*/
 114:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 115:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /* Tickless idle/low power functionality. */
 116:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #ifndef portSUPPRESS_TICKS_AND_SLEEP
 117:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
 118:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdl
 119:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #endif
 120:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*-----------------------------------------------------------*/
 121:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 122:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /* Architecture specific optimisations. */
 123:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
 124:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
 125:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #endif
 126:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 127:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
 128:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 129:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	/* Generic helper function. */
 130:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitma
 131:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	{
 132:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	uint8_t ucReturn;
 133:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 134:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 135:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		return ucReturn;
 136:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	}
 137:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 138:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	/* Check the configuration. */
 139:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#if( configMAX_PRIORITIES > 32 )
 140:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is 
 141:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#endif
 142:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 143:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	/* Store/clear the ready priorities in a bit map. */
 144:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL 
 145:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL 
 146:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 147:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	/*-----------------------------------------------------------*/
 148:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 149:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( ui
 150:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 151:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 152:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 153:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*-----------------------------------------------------------*/
 154:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 155:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #ifdef configASSERT
 156:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	void vPortValidateInterruptPriority( void );
 157:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
 158:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #endif
 159:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 160:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /* portNOP() is not required by this port. */
 161:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portNOP()
 162:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 163:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portINLINE	__inline
 164:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 165:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #ifndef portFORCE_INLINE
 166:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#define portFORCE_INLINE inline __attribute__(( always_inline))
 167:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #endif
 168:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 169:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
 170:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** {
 171:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** uint32_t ulCurrentInterrupt;
 172:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** BaseType_t xReturn;
 173:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 174:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	/* Obtain the number of the currently executing interrupt. */
 175:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
 176:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 177:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	if( ulCurrentInterrupt == 0 )
 178:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	{
 179:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		xReturn = pdFALSE;
 180:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	}
 181:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	else
 182:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	{
 183:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		xReturn = pdTRUE;
 184:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	}
 185:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 186:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	return xReturn;
 187:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** }
 188:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 189:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*-----------------------------------------------------------*/
 190:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 191:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** portFORCE_INLINE static void vPortRaiseBASEPRI( void )
 192:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** {
 193:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** uint32_t ulNewBASEPRI;
 194:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	__asm volatile
  53              	 .loc 2 195 0 discriminator 1
  54              	
  55 0014 4FF0FC03 	 mov r3,#252
  56 0018 83F31188 	 msr basepri,r3
  57 001c BFF36F8F 	 isb 
  58 0020 BFF34F8F 	 dsb 
  59              	
  60              	
  61              	 .thumb
  62 0024 BB60     	 str r3,[r7,#8]
  63              	.L3:
  64              	.LBE109:
  65              	.LBE108:
  66              	 .loc 1 251 0 discriminator 1
  67 0026 FEE7     	 b .L3
  68              	.L2:
 252:../Dave/Generated/FREERTOS/queue.c **** 
 253:../Dave/Generated/FREERTOS/queue.c **** 	taskENTER_CRITICAL();
  69              	 .loc 1 253 0
  70 0028 FFF7FEFF 	 bl vPortEnterCritical
 254:../Dave/Generated/FREERTOS/queue.c **** 	{
 255:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
  71              	 .loc 1 255 0
  72 002c FB68     	 ldr r3,[r7,#12]
  73 002e 1A68     	 ldr r2,[r3]
  74 0030 FB68     	 ldr r3,[r7,#12]
  75 0032 DB6B     	 ldr r3,[r3,#60]
  76 0034 F968     	 ldr r1,[r7,#12]
  77 0036 096C     	 ldr r1,[r1,#64]
  78 0038 01FB03F3 	 mul r3,r1,r3
  79 003c 1A44     	 add r2,r2,r3
  80 003e FB68     	 ldr r3,[r7,#12]
  81 0040 5A60     	 str r2,[r3,#4]
 256:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
  82              	 .loc 1 256 0
  83 0042 FB68     	 ldr r3,[r7,#12]
  84 0044 0022     	 movs r2,#0
  85 0046 9A63     	 str r2,[r3,#56]
 257:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
  86              	 .loc 1 257 0
  87 0048 FB68     	 ldr r3,[r7,#12]
  88 004a 1A68     	 ldr r2,[r3]
  89 004c FB68     	 ldr r3,[r7,#12]
  90 004e 9A60     	 str r2,[r3,#8]
 258:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue-
  91              	 .loc 1 258 0
  92 0050 FB68     	 ldr r3,[r7,#12]
  93 0052 1A68     	 ldr r2,[r3]
  94 0054 FB68     	 ldr r3,[r7,#12]
  95 0056 DB6B     	 ldr r3,[r3,#60]
  96 0058 013B     	 subs r3,r3,#1
  97 005a F968     	 ldr r1,[r7,#12]
  98 005c 096C     	 ldr r1,[r1,#64]
  99 005e 01FB03F3 	 mul r3,r1,r3
 100 0062 1A44     	 add r2,r2,r3
 101 0064 FB68     	 ldr r3,[r7,#12]
 102 0066 DA60     	 str r2,[r3,#12]
 259:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
 103              	 .loc 1 259 0
 104 0068 FB68     	 ldr r3,[r7,#12]
 105 006a FF22     	 movs r2,#255
 106 006c 83F84420 	 strb r2,[r3,#68]
 260:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
 107              	 .loc 1 260 0
 108 0070 FB68     	 ldr r3,[r7,#12]
 109 0072 FF22     	 movs r2,#255
 110 0074 83F84520 	 strb r2,[r3,#69]
 261:../Dave/Generated/FREERTOS/queue.c **** 
 262:../Dave/Generated/FREERTOS/queue.c **** 		if( xNewQueue == pdFALSE )
 111              	 .loc 1 262 0
 112 0078 3B68     	 ldr r3,[r7]
 113 007a 002B     	 cmp r3,#0
 114 007c 14D1     	 bne .L4
 263:../Dave/Generated/FREERTOS/queue.c **** 		{
 264:../Dave/Generated/FREERTOS/queue.c **** 			/* If there are tasks blocked waiting to read from the queue, then
 265:../Dave/Generated/FREERTOS/queue.c **** 			the tasks will remain blocked as after this function exits the queue
 266:../Dave/Generated/FREERTOS/queue.c **** 			will still be empty.  If there are tasks blocked waiting to write to
 267:../Dave/Generated/FREERTOS/queue.c **** 			the queue, then one should be unblocked as after this function exits
 268:../Dave/Generated/FREERTOS/queue.c **** 			it will be possible to write to it. */
 269:../Dave/Generated/FREERTOS/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 115              	 .loc 1 269 0
 116 007e FB68     	 ldr r3,[r7,#12]
 117 0080 1B69     	 ldr r3,[r3,#16]
 118 0082 002B     	 cmp r3,#0
 119 0084 1AD0     	 beq .L5
 270:../Dave/Generated/FREERTOS/queue.c **** 			{
 271:../Dave/Generated/FREERTOS/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 120              	 .loc 1 271 0
 121 0086 FB68     	 ldr r3,[r7,#12]
 122 0088 1033     	 adds r3,r3,#16
 123 008a 1846     	 mov r0,r3
 124 008c FFF7FEFF 	 bl xTaskRemoveFromEventList
 125 0090 0346     	 mov r3,r0
 126 0092 002B     	 cmp r3,#0
 127 0094 12D0     	 beq .L5
 272:../Dave/Generated/FREERTOS/queue.c **** 				{
 273:../Dave/Generated/FREERTOS/queue.c **** 					queueYIELD_IF_USING_PREEMPTION();
 128              	 .loc 1 273 0
 129 0096 0D4B     	 ldr r3,.L7
 130 0098 4FF08052 	 mov r2,#268435456
 131 009c 1A60     	 str r2,[r3]
 132              	
 133 009e BFF34F8F 	 dsb
 134              	
 135              	
 136 00a2 BFF36F8F 	 isb
 137              	
 138              	 .thumb
 139 00a6 09E0     	 b .L5
 140              	.L4:
 274:../Dave/Generated/FREERTOS/queue.c **** 				}
 275:../Dave/Generated/FREERTOS/queue.c **** 				else
 276:../Dave/Generated/FREERTOS/queue.c **** 				{
 277:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 278:../Dave/Generated/FREERTOS/queue.c **** 				}
 279:../Dave/Generated/FREERTOS/queue.c **** 			}
 280:../Dave/Generated/FREERTOS/queue.c **** 			else
 281:../Dave/Generated/FREERTOS/queue.c **** 			{
 282:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 283:../Dave/Generated/FREERTOS/queue.c **** 			}
 284:../Dave/Generated/FREERTOS/queue.c **** 		}
 285:../Dave/Generated/FREERTOS/queue.c **** 		else
 286:../Dave/Generated/FREERTOS/queue.c **** 		{
 287:../Dave/Generated/FREERTOS/queue.c **** 			/* Ensure the event queues start in the correct state. */
 288:../Dave/Generated/FREERTOS/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 141              	 .loc 1 288 0
 142 00a8 FB68     	 ldr r3,[r7,#12]
 143 00aa 1033     	 adds r3,r3,#16
 144 00ac 1846     	 mov r0,r3
 145 00ae FFF7FEFF 	 bl vListInitialise
 289:../Dave/Generated/FREERTOS/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 146              	 .loc 1 289 0
 147 00b2 FB68     	 ldr r3,[r7,#12]
 148 00b4 2433     	 adds r3,r3,#36
 149 00b6 1846     	 mov r0,r3
 150 00b8 FFF7FEFF 	 bl vListInitialise
 151              	.L5:
 290:../Dave/Generated/FREERTOS/queue.c **** 		}
 291:../Dave/Generated/FREERTOS/queue.c **** 	}
 292:../Dave/Generated/FREERTOS/queue.c **** 	taskEXIT_CRITICAL();
 152              	 .loc 1 292 0
 153 00bc FFF7FEFF 	 bl vPortExitCritical
 293:../Dave/Generated/FREERTOS/queue.c **** 
 294:../Dave/Generated/FREERTOS/queue.c **** 	/* A value is returned for calling semantic consistency with previous
 295:../Dave/Generated/FREERTOS/queue.c **** 	versions. */
 296:../Dave/Generated/FREERTOS/queue.c **** 	return pdPASS;
 154              	 .loc 1 296 0
 155 00c0 0123     	 movs r3,#1
 297:../Dave/Generated/FREERTOS/queue.c **** }
 156              	 .loc 1 297 0
 157 00c2 1846     	 mov r0,r3
 158 00c4 1037     	 adds r7,r7,#16
 159              	 .cfi_def_cfa_offset 8
 160 00c6 BD46     	 mov sp,r7
 161              	 .cfi_def_cfa_register 13
 162              	 
 163 00c8 80BD     	 pop {r7,pc}
 164              	.L8:
 165 00ca 00BF     	 .align 2
 166              	.L7:
 167 00cc 04ED00E0 	 .word -536810236
 168              	 .cfi_endproc
 169              	.LFE137:
 171              	 .section .text.xQueueGenericCreate,"ax",%progbits
 172              	 .align 2
 173              	 .global xQueueGenericCreate
 174              	 .thumb
 175              	 .thumb_func
 177              	xQueueGenericCreate:
 178              	.LFB138:
 298:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 299:../Dave/Generated/FREERTOS/queue.c **** 
 300:../Dave/Generated/FREERTOS/queue.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 301:../Dave/Generated/FREERTOS/queue.c **** 
 302:../Dave/Generated/FREERTOS/queue.c **** 	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItem
 303:../Dave/Generated/FREERTOS/queue.c **** 	{
 304:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t *pxNewQueue;
 305:../Dave/Generated/FREERTOS/queue.c **** 
 306:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 307:../Dave/Generated/FREERTOS/queue.c **** 
 308:../Dave/Generated/FREERTOS/queue.c **** 		/* The StaticQueue_t structure and the queue storage area must be
 309:../Dave/Generated/FREERTOS/queue.c **** 		supplied. */
 310:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( pxStaticQueue != NULL );
 311:../Dave/Generated/FREERTOS/queue.c **** 
 312:../Dave/Generated/FREERTOS/queue.c **** 		/* A queue storage area should be provided if the item size is not 0, and
 313:../Dave/Generated/FREERTOS/queue.c **** 		should not be provided if the item size is 0. */
 314:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
 315:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 316:../Dave/Generated/FREERTOS/queue.c **** 
 317:../Dave/Generated/FREERTOS/queue.c **** 		#if( configASSERT_DEFINED == 1 )
 318:../Dave/Generated/FREERTOS/queue.c **** 		{
 319:../Dave/Generated/FREERTOS/queue.c **** 			/* Sanity check that the size of the structure used to declare a
 320:../Dave/Generated/FREERTOS/queue.c **** 			variable of type StaticQueue_t or StaticSemaphore_t equals the size of
 321:../Dave/Generated/FREERTOS/queue.c **** 			the real queue and semaphore structures. */
 322:../Dave/Generated/FREERTOS/queue.c **** 			volatile size_t xSize = sizeof( StaticQueue_t );
 323:../Dave/Generated/FREERTOS/queue.c **** 			configASSERT( xSize == sizeof( Queue_t ) );
 324:../Dave/Generated/FREERTOS/queue.c **** 		}
 325:../Dave/Generated/FREERTOS/queue.c **** 		#endif /* configASSERT_DEFINED */
 326:../Dave/Generated/FREERTOS/queue.c **** 
 327:../Dave/Generated/FREERTOS/queue.c **** 		/* The address of a statically allocated queue was passed in, use it.
 328:../Dave/Generated/FREERTOS/queue.c **** 		The address of a statically allocated storage area was also passed in
 329:../Dave/Generated/FREERTOS/queue.c **** 		but is already set. */
 330:../Dave/Generated/FREERTOS/queue.c **** 		pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 Unusual cast is ok as the structures are d
 331:../Dave/Generated/FREERTOS/queue.c **** 
 332:../Dave/Generated/FREERTOS/queue.c **** 		if( pxNewQueue != NULL )
 333:../Dave/Generated/FREERTOS/queue.c **** 		{
 334:../Dave/Generated/FREERTOS/queue.c **** 			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 335:../Dave/Generated/FREERTOS/queue.c **** 			{
 336:../Dave/Generated/FREERTOS/queue.c **** 				/* Queues can be allocated wither statically or dynamically, so
 337:../Dave/Generated/FREERTOS/queue.c **** 				note this queue was allocated statically in case the queue is
 338:../Dave/Generated/FREERTOS/queue.c **** 				later deleted. */
 339:../Dave/Generated/FREERTOS/queue.c **** 				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 340:../Dave/Generated/FREERTOS/queue.c **** 			}
 341:../Dave/Generated/FREERTOS/queue.c **** 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 342:../Dave/Generated/FREERTOS/queue.c **** 
 343:../Dave/Generated/FREERTOS/queue.c **** 			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 344:../Dave/Generated/FREERTOS/queue.c **** 		}
 345:../Dave/Generated/FREERTOS/queue.c **** 		else
 346:../Dave/Generated/FREERTOS/queue.c **** 		{
 347:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_CREATE_FAILED( ucQueueType );
 348:../Dave/Generated/FREERTOS/queue.c **** 		}
 349:../Dave/Generated/FREERTOS/queue.c **** 
 350:../Dave/Generated/FREERTOS/queue.c **** 		return pxNewQueue;
 351:../Dave/Generated/FREERTOS/queue.c **** 	}
 352:../Dave/Generated/FREERTOS/queue.c **** 
 353:../Dave/Generated/FREERTOS/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 354:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 355:../Dave/Generated/FREERTOS/queue.c **** 
 356:../Dave/Generated/FREERTOS/queue.c **** #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 357:../Dave/Generated/FREERTOS/queue.c **** 
 358:../Dave/Generated/FREERTOS/queue.c **** 	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, 
 359:../Dave/Generated/FREERTOS/queue.c **** 	{
 179              	 .loc 1 359 0
 180              	 .cfi_startproc
 181              	 
 182              	 
 183 0000 90B5     	 push {r4,r7,lr}
 184              	 .cfi_def_cfa_offset 12
 185              	 .cfi_offset 4,-12
 186              	 .cfi_offset 7,-8
 187              	 .cfi_offset 14,-4
 188 0002 8BB0     	 sub sp,sp,#44
 189              	 .cfi_def_cfa_offset 56
 190 0004 02AF     	 add r7,sp,#8
 191              	 .cfi_def_cfa 7,48
 192 0006 F860     	 str r0,[r7,#12]
 193 0008 B960     	 str r1,[r7,#8]
 194 000a 1346     	 mov r3,r2
 195 000c FB71     	 strb r3,[r7,#7]
 360:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t *pxNewQueue;
 361:../Dave/Generated/FREERTOS/queue.c **** 	size_t xQueueSizeInBytes;
 362:../Dave/Generated/FREERTOS/queue.c **** 	uint8_t *pucQueueStorage;
 363:../Dave/Generated/FREERTOS/queue.c **** 
 364:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 196              	 .loc 1 364 0
 197 000e FB68     	 ldr r3,[r7,#12]
 198 0010 002B     	 cmp r3,#0
 199 0012 09D1     	 bne .L10
 200              	.LBB110:
 201              	.LBB111:
 202              	 .loc 2 195 0 discriminator 1
 203              	
 204 0014 4FF0FC03 	 mov r3,#252
 205 0018 83F31188 	 msr basepri,r3
 206 001c BFF36F8F 	 isb 
 207 0020 BFF34F8F 	 dsb 
 208              	
 209              	
 210              	 .thumb
 211 0024 3B61     	 str r3,[r7,#16]
 212              	.L11:
 213              	.LBE111:
 214              	.LBE110:
 215              	 .loc 1 364 0 discriminator 1
 216 0026 FEE7     	 b .L11
 217              	.L10:
 365:../Dave/Generated/FREERTOS/queue.c **** 
 366:../Dave/Generated/FREERTOS/queue.c **** 		if( uxItemSize == ( UBaseType_t ) 0 )
 218              	 .loc 1 366 0
 219 0028 BB68     	 ldr r3,[r7,#8]
 220 002a 002B     	 cmp r3,#0
 221 002c 02D1     	 bne .L12
 367:../Dave/Generated/FREERTOS/queue.c **** 		{
 368:../Dave/Generated/FREERTOS/queue.c **** 			/* There is not going to be a queue storage area. */
 369:../Dave/Generated/FREERTOS/queue.c **** 			xQueueSizeInBytes = ( size_t ) 0;
 222              	 .loc 1 369 0
 223 002e 0023     	 movs r3,#0
 224 0030 FB61     	 str r3,[r7,#28]
 225 0032 04E0     	 b .L13
 226              	.L12:
 370:../Dave/Generated/FREERTOS/queue.c **** 		}
 371:../Dave/Generated/FREERTOS/queue.c **** 		else
 372:../Dave/Generated/FREERTOS/queue.c **** 		{
 373:../Dave/Generated/FREERTOS/queue.c **** 			/* Allocate enough space to hold the maximum number of items that
 374:../Dave/Generated/FREERTOS/queue.c **** 			can be in the queue at any time. */
 375:../Dave/Generated/FREERTOS/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as t
 227              	 .loc 1 375 0
 228 0034 FB68     	 ldr r3,[r7,#12]
 229 0036 BA68     	 ldr r2,[r7,#8]
 230 0038 02FB03F3 	 mul r3,r2,r3
 231 003c FB61     	 str r3,[r7,#28]
 232              	.L13:
 376:../Dave/Generated/FREERTOS/queue.c **** 		}
 377:../Dave/Generated/FREERTOS/queue.c **** 
 378:../Dave/Generated/FREERTOS/queue.c **** 		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 233              	 .loc 1 378 0
 234 003e FB69     	 ldr r3,[r7,#28]
 235 0040 5433     	 adds r3,r3,#84
 236 0042 1846     	 mov r0,r3
 237 0044 FFF7FEFF 	 bl pvPortMalloc
 238 0048 B861     	 str r0,[r7,#24]
 379:../Dave/Generated/FREERTOS/queue.c **** 
 380:../Dave/Generated/FREERTOS/queue.c **** 		if( pxNewQueue != NULL )
 239              	 .loc 1 380 0
 240 004a BB69     	 ldr r3,[r7,#24]
 241 004c 002B     	 cmp r3,#0
 242 004e 0BD0     	 beq .L14
 381:../Dave/Generated/FREERTOS/queue.c **** 		{
 382:../Dave/Generated/FREERTOS/queue.c **** 			/* Jump past the queue structure to find the location of the queue
 383:../Dave/Generated/FREERTOS/queue.c **** 			storage area. */
 384:../Dave/Generated/FREERTOS/queue.c **** 			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
 243              	 .loc 1 384 0
 244 0050 BB69     	 ldr r3,[r7,#24]
 245 0052 5433     	 adds r3,r3,#84
 246 0054 7B61     	 str r3,[r7,#20]
 385:../Dave/Generated/FREERTOS/queue.c **** 
 386:../Dave/Generated/FREERTOS/queue.c **** 			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
 387:../Dave/Generated/FREERTOS/queue.c **** 			{
 388:../Dave/Generated/FREERTOS/queue.c **** 				/* Queues can be created either statically or dynamically, so
 389:../Dave/Generated/FREERTOS/queue.c **** 				note this task was created dynamically in case it is later
 390:../Dave/Generated/FREERTOS/queue.c **** 				deleted. */
 391:../Dave/Generated/FREERTOS/queue.c **** 				pxNewQueue->ucStaticallyAllocated = pdFALSE;
 392:../Dave/Generated/FREERTOS/queue.c **** 			}
 393:../Dave/Generated/FREERTOS/queue.c **** 			#endif /* configSUPPORT_STATIC_ALLOCATION */
 394:../Dave/Generated/FREERTOS/queue.c **** 
 395:../Dave/Generated/FREERTOS/queue.c **** 			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 247              	 .loc 1 395 0
 248 0056 FC79     	 ldrb r4,[r7,#7]
 249 0058 BB69     	 ldr r3,[r7,#24]
 250 005a 0093     	 str r3,[sp]
 251 005c F868     	 ldr r0,[r7,#12]
 252 005e B968     	 ldr r1,[r7,#8]
 253 0060 7A69     	 ldr r2,[r7,#20]
 254 0062 2346     	 mov r3,r4
 255 0064 FFF7FEFF 	 bl prvInitialiseNewQueue
 256              	.L14:
 396:../Dave/Generated/FREERTOS/queue.c **** 		}
 397:../Dave/Generated/FREERTOS/queue.c **** 		else
 398:../Dave/Generated/FREERTOS/queue.c **** 		{
 399:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_CREATE_FAILED( ucQueueType );
 400:../Dave/Generated/FREERTOS/queue.c **** 		}
 401:../Dave/Generated/FREERTOS/queue.c **** 
 402:../Dave/Generated/FREERTOS/queue.c **** 		return pxNewQueue;
 257              	 .loc 1 402 0
 258 0068 BB69     	 ldr r3,[r7,#24]
 403:../Dave/Generated/FREERTOS/queue.c **** 	}
 259              	 .loc 1 403 0
 260 006a 1846     	 mov r0,r3
 261 006c 2437     	 adds r7,r7,#36
 262              	 .cfi_def_cfa_offset 12
 263 006e BD46     	 mov sp,r7
 264              	 .cfi_def_cfa_register 13
 265              	 
 266 0070 90BD     	 pop {r4,r7,pc}
 267              	 .cfi_endproc
 268              	.LFE138:
 270 0072 00BF     	 .section .text.prvInitialiseNewQueue,"ax",%progbits
 271              	 .align 2
 272              	 .thumb
 273              	 .thumb_func
 275              	prvInitialiseNewQueue:
 276              	.LFB139:
 404:../Dave/Generated/FREERTOS/queue.c **** 
 405:../Dave/Generated/FREERTOS/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 406:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 407:../Dave/Generated/FREERTOS/queue.c **** 
 408:../Dave/Generated/FREERTOS/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, u
 409:../Dave/Generated/FREERTOS/queue.c **** {
 277              	 .loc 1 409 0
 278              	 .cfi_startproc
 279              	 
 280              	 
 281 0000 80B5     	 push {r7,lr}
 282              	 .cfi_def_cfa_offset 8
 283              	 .cfi_offset 7,-8
 284              	 .cfi_offset 14,-4
 285 0002 84B0     	 sub sp,sp,#16
 286              	 .cfi_def_cfa_offset 24
 287 0004 00AF     	 add r7,sp,#0
 288              	 .cfi_def_cfa_register 7
 289 0006 F860     	 str r0,[r7,#12]
 290 0008 B960     	 str r1,[r7,#8]
 291 000a 7A60     	 str r2,[r7,#4]
 292 000c FB70     	 strb r3,[r7,#3]
 410:../Dave/Generated/FREERTOS/queue.c **** 	/* Remove compiler warnings about unused parameters should
 411:../Dave/Generated/FREERTOS/queue.c **** 	configUSE_TRACE_FACILITY not be set to 1. */
 412:../Dave/Generated/FREERTOS/queue.c **** 	( void ) ucQueueType;
 413:../Dave/Generated/FREERTOS/queue.c **** 
 414:../Dave/Generated/FREERTOS/queue.c **** 	if( uxItemSize == ( UBaseType_t ) 0 )
 293              	 .loc 1 414 0
 294 000e BB68     	 ldr r3,[r7,#8]
 295 0010 002B     	 cmp r3,#0
 296 0012 03D1     	 bne .L17
 415:../Dave/Generated/FREERTOS/queue.c **** 	{
 416:../Dave/Generated/FREERTOS/queue.c **** 		/* No RAM was allocated for the queue storage area, but PC head cannot
 417:../Dave/Generated/FREERTOS/queue.c **** 		be set to NULL because NULL is used as a key to say the queue is used as
 418:../Dave/Generated/FREERTOS/queue.c **** 		a mutex.  Therefore just set pcHead to point to the queue as a benign
 419:../Dave/Generated/FREERTOS/queue.c **** 		value that is known to be within the memory map. */
 420:../Dave/Generated/FREERTOS/queue.c **** 		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 297              	 .loc 1 420 0
 298 0014 BB69     	 ldr r3,[r7,#24]
 299 0016 BA69     	 ldr r2,[r7,#24]
 300 0018 1A60     	 str r2,[r3]
 301 001a 02E0     	 b .L18
 302              	.L17:
 421:../Dave/Generated/FREERTOS/queue.c **** 	}
 422:../Dave/Generated/FREERTOS/queue.c **** 	else
 423:../Dave/Generated/FREERTOS/queue.c **** 	{
 424:../Dave/Generated/FREERTOS/queue.c **** 		/* Set the head to the start of the queue storage area. */
 425:../Dave/Generated/FREERTOS/queue.c **** 		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 303              	 .loc 1 425 0
 304 001c BB69     	 ldr r3,[r7,#24]
 305 001e 7A68     	 ldr r2,[r7,#4]
 306 0020 1A60     	 str r2,[r3]
 307              	.L18:
 426:../Dave/Generated/FREERTOS/queue.c **** 	}
 427:../Dave/Generated/FREERTOS/queue.c **** 
 428:../Dave/Generated/FREERTOS/queue.c **** 	/* Initialise the queue members as described where the queue type is
 429:../Dave/Generated/FREERTOS/queue.c **** 	defined. */
 430:../Dave/Generated/FREERTOS/queue.c **** 	pxNewQueue->uxLength = uxQueueLength;
 308              	 .loc 1 430 0
 309 0022 BB69     	 ldr r3,[r7,#24]
 310 0024 FA68     	 ldr r2,[r7,#12]
 311 0026 DA63     	 str r2,[r3,#60]
 431:../Dave/Generated/FREERTOS/queue.c **** 	pxNewQueue->uxItemSize = uxItemSize;
 312              	 .loc 1 431 0
 313 0028 BB69     	 ldr r3,[r7,#24]
 314 002a BA68     	 ldr r2,[r7,#8]
 315 002c 1A64     	 str r2,[r3,#64]
 432:../Dave/Generated/FREERTOS/queue.c **** 	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 316              	 .loc 1 432 0
 317 002e B869     	 ldr r0,[r7,#24]
 318 0030 0121     	 movs r1,#1
 319 0032 FFF7FEFF 	 bl xQueueGenericReset
 433:../Dave/Generated/FREERTOS/queue.c **** 
 434:../Dave/Generated/FREERTOS/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 435:../Dave/Generated/FREERTOS/queue.c **** 	{
 436:../Dave/Generated/FREERTOS/queue.c **** 		pxNewQueue->ucQueueType = ucQueueType;
 320              	 .loc 1 436 0
 321 0036 BB69     	 ldr r3,[r7,#24]
 322 0038 FA78     	 ldrb r2,[r7,#3]
 323 003a 83F85020 	 strb r2,[r3,#80]
 437:../Dave/Generated/FREERTOS/queue.c **** 	}
 438:../Dave/Generated/FREERTOS/queue.c **** 	#endif /* configUSE_TRACE_FACILITY */
 439:../Dave/Generated/FREERTOS/queue.c **** 
 440:../Dave/Generated/FREERTOS/queue.c **** 	#if( configUSE_QUEUE_SETS == 1 )
 441:../Dave/Generated/FREERTOS/queue.c **** 	{
 442:../Dave/Generated/FREERTOS/queue.c **** 		pxNewQueue->pxQueueSetContainer = NULL;
 324              	 .loc 1 442 0
 325 003e BB69     	 ldr r3,[r7,#24]
 326 0040 0022     	 movs r2,#0
 327 0042 9A64     	 str r2,[r3,#72]
 443:../Dave/Generated/FREERTOS/queue.c **** 	}
 444:../Dave/Generated/FREERTOS/queue.c **** 	#endif /* configUSE_QUEUE_SETS */
 445:../Dave/Generated/FREERTOS/queue.c **** 
 446:../Dave/Generated/FREERTOS/queue.c **** 	traceQUEUE_CREATE( pxNewQueue );
 447:../Dave/Generated/FREERTOS/queue.c **** }
 328              	 .loc 1 447 0
 329 0044 1037     	 adds r7,r7,#16
 330              	 .cfi_def_cfa_offset 8
 331 0046 BD46     	 mov sp,r7
 332              	 .cfi_def_cfa_register 13
 333              	 
 334 0048 80BD     	 pop {r7,pc}
 335              	 .cfi_endproc
 336              	.LFE139:
 338 004a 00BF     	 .section .text.prvInitialiseMutex,"ax",%progbits
 339              	 .align 2
 340              	 .thumb
 341              	 .thumb_func
 343              	prvInitialiseMutex:
 344              	.LFB140:
 448:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 449:../Dave/Generated/FREERTOS/queue.c **** 
 450:../Dave/Generated/FREERTOS/queue.c **** #if( configUSE_MUTEXES == 1 )
 451:../Dave/Generated/FREERTOS/queue.c **** 
 452:../Dave/Generated/FREERTOS/queue.c **** 	static void prvInitialiseMutex( Queue_t *pxNewQueue )
 453:../Dave/Generated/FREERTOS/queue.c **** 	{
 345              	 .loc 1 453 0
 346              	 .cfi_startproc
 347              	 
 348              	 
 349 0000 80B5     	 push {r7,lr}
 350              	 .cfi_def_cfa_offset 8
 351              	 .cfi_offset 7,-8
 352              	 .cfi_offset 14,-4
 353 0002 82B0     	 sub sp,sp,#8
 354              	 .cfi_def_cfa_offset 16
 355 0004 00AF     	 add r7,sp,#0
 356              	 .cfi_def_cfa_register 7
 357 0006 7860     	 str r0,[r7,#4]
 454:../Dave/Generated/FREERTOS/queue.c **** 		if( pxNewQueue != NULL )
 358              	 .loc 1 454 0
 359 0008 7B68     	 ldr r3,[r7,#4]
 360 000a 002B     	 cmp r3,#0
 361 000c 0ED0     	 beq .L19
 455:../Dave/Generated/FREERTOS/queue.c **** 		{
 456:../Dave/Generated/FREERTOS/queue.c **** 			/* The queue create function will set all the queue structure members
 457:../Dave/Generated/FREERTOS/queue.c **** 			correctly for a generic queue, but this function is creating a
 458:../Dave/Generated/FREERTOS/queue.c **** 			mutex.  Overwrite those members that need to be set differently -
 459:../Dave/Generated/FREERTOS/queue.c **** 			in particular the information required for priority inheritance. */
 460:../Dave/Generated/FREERTOS/queue.c **** 			pxNewQueue->pxMutexHolder = NULL;
 362              	 .loc 1 460 0
 363 000e 7B68     	 ldr r3,[r7,#4]
 364 0010 0022     	 movs r2,#0
 365 0012 5A60     	 str r2,[r3,#4]
 461:../Dave/Generated/FREERTOS/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 366              	 .loc 1 461 0
 367 0014 7B68     	 ldr r3,[r7,#4]
 368 0016 0022     	 movs r2,#0
 369 0018 1A60     	 str r2,[r3]
 462:../Dave/Generated/FREERTOS/queue.c **** 
 463:../Dave/Generated/FREERTOS/queue.c **** 			/* In case this is a recursive mutex. */
 464:../Dave/Generated/FREERTOS/queue.c **** 			pxNewQueue->u.uxRecursiveCallCount = 0;
 370              	 .loc 1 464 0
 371 001a 7B68     	 ldr r3,[r7,#4]
 372 001c 0022     	 movs r2,#0
 373 001e DA60     	 str r2,[r3,#12]
 465:../Dave/Generated/FREERTOS/queue.c **** 
 466:../Dave/Generated/FREERTOS/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 467:../Dave/Generated/FREERTOS/queue.c **** 
 468:../Dave/Generated/FREERTOS/queue.c **** 			/* Start with the semaphore in the expected state. */
 469:../Dave/Generated/FREERTOS/queue.c **** 			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 374              	 .loc 1 469 0
 375 0020 7868     	 ldr r0,[r7,#4]
 376 0022 0021     	 movs r1,#0
 377 0024 0022     	 movs r2,#0
 378 0026 0023     	 movs r3,#0
 379 0028 FFF7FEFF 	 bl xQueueGenericSend
 380              	.L19:
 470:../Dave/Generated/FREERTOS/queue.c **** 		}
 471:../Dave/Generated/FREERTOS/queue.c **** 		else
 472:../Dave/Generated/FREERTOS/queue.c **** 		{
 473:../Dave/Generated/FREERTOS/queue.c **** 			traceCREATE_MUTEX_FAILED();
 474:../Dave/Generated/FREERTOS/queue.c **** 		}
 475:../Dave/Generated/FREERTOS/queue.c **** 	}
 381              	 .loc 1 475 0
 382 002c 0837     	 adds r7,r7,#8
 383              	 .cfi_def_cfa_offset 8
 384 002e BD46     	 mov sp,r7
 385              	 .cfi_def_cfa_register 13
 386              	 
 387 0030 80BD     	 pop {r7,pc}
 388              	 .cfi_endproc
 389              	.LFE140:
 391 0032 00BF     	 .section .text.xQueueCreateMutex,"ax",%progbits
 392              	 .align 2
 393              	 .global xQueueCreateMutex
 394              	 .thumb
 395              	 .thumb_func
 397              	xQueueCreateMutex:
 398              	.LFB141:
 476:../Dave/Generated/FREERTOS/queue.c **** 
 477:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_MUTEXES */
 478:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 479:../Dave/Generated/FREERTOS/queue.c **** 
 480:../Dave/Generated/FREERTOS/queue.c **** #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 481:../Dave/Generated/FREERTOS/queue.c **** 
 482:../Dave/Generated/FREERTOS/queue.c **** 	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
 483:../Dave/Generated/FREERTOS/queue.c **** 	{
 399              	 .loc 1 483 0
 400              	 .cfi_startproc
 401              	 
 402              	 
 403 0000 80B5     	 push {r7,lr}
 404              	 .cfi_def_cfa_offset 8
 405              	 .cfi_offset 7,-8
 406              	 .cfi_offset 14,-4
 407 0002 86B0     	 sub sp,sp,#24
 408              	 .cfi_def_cfa_offset 32
 409 0004 00AF     	 add r7,sp,#0
 410              	 .cfi_def_cfa_register 7
 411 0006 0346     	 mov r3,r0
 412 0008 FB71     	 strb r3,[r7,#7]
 484:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t *pxNewQueue;
 485:../Dave/Generated/FREERTOS/queue.c **** 	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 413              	 .loc 1 485 0
 414 000a 0123     	 movs r3,#1
 415 000c 7B61     	 str r3,[r7,#20]
 416 000e 0023     	 movs r3,#0
 417 0010 3B61     	 str r3,[r7,#16]
 486:../Dave/Generated/FREERTOS/queue.c **** 
 487:../Dave/Generated/FREERTOS/queue.c **** 		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 418              	 .loc 1 487 0
 419 0012 FB79     	 ldrb r3,[r7,#7]
 420 0014 7869     	 ldr r0,[r7,#20]
 421 0016 3969     	 ldr r1,[r7,#16]
 422 0018 1A46     	 mov r2,r3
 423 001a FFF7FEFF 	 bl xQueueGenericCreate
 424 001e F860     	 str r0,[r7,#12]
 488:../Dave/Generated/FREERTOS/queue.c **** 		prvInitialiseMutex( pxNewQueue );
 425              	 .loc 1 488 0
 426 0020 F868     	 ldr r0,[r7,#12]
 427 0022 FFF7FEFF 	 bl prvInitialiseMutex
 489:../Dave/Generated/FREERTOS/queue.c **** 
 490:../Dave/Generated/FREERTOS/queue.c **** 		return pxNewQueue;
 428              	 .loc 1 490 0
 429 0026 FB68     	 ldr r3,[r7,#12]
 491:../Dave/Generated/FREERTOS/queue.c **** 	}
 430              	 .loc 1 491 0
 431 0028 1846     	 mov r0,r3
 432 002a 1837     	 adds r7,r7,#24
 433              	 .cfi_def_cfa_offset 8
 434 002c BD46     	 mov sp,r7
 435              	 .cfi_def_cfa_register 13
 436              	 
 437 002e 80BD     	 pop {r7,pc}
 438              	 .cfi_endproc
 439              	.LFE141:
 441              	 .section .text.xQueueGetMutexHolder,"ax",%progbits
 442              	 .align 2
 443              	 .global xQueueGetMutexHolder
 444              	 .thumb
 445              	 .thumb_func
 447              	xQueueGetMutexHolder:
 448              	.LFB142:
 492:../Dave/Generated/FREERTOS/queue.c **** 
 493:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_MUTEXES */
 494:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 495:../Dave/Generated/FREERTOS/queue.c **** 
 496:../Dave/Generated/FREERTOS/queue.c **** #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 497:../Dave/Generated/FREERTOS/queue.c **** 
 498:../Dave/Generated/FREERTOS/queue.c **** 	QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue )
 499:../Dave/Generated/FREERTOS/queue.c **** 	{
 500:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t *pxNewQueue;
 501:../Dave/Generated/FREERTOS/queue.c **** 	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 502:../Dave/Generated/FREERTOS/queue.c **** 
 503:../Dave/Generated/FREERTOS/queue.c **** 		/* Prevent compiler warnings about unused parameters if
 504:../Dave/Generated/FREERTOS/queue.c **** 		configUSE_TRACE_FACILITY does not equal 1. */
 505:../Dave/Generated/FREERTOS/queue.c **** 		( void ) ucQueueType;
 506:../Dave/Generated/FREERTOS/queue.c **** 
 507:../Dave/Generated/FREERTOS/queue.c **** 		pxNewQueue = ( Queue_t * ) xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQ
 508:../Dave/Generated/FREERTOS/queue.c **** 		prvInitialiseMutex( pxNewQueue );
 509:../Dave/Generated/FREERTOS/queue.c **** 
 510:../Dave/Generated/FREERTOS/queue.c **** 		return pxNewQueue;
 511:../Dave/Generated/FREERTOS/queue.c **** 	}
 512:../Dave/Generated/FREERTOS/queue.c **** 
 513:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_MUTEXES */
 514:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 515:../Dave/Generated/FREERTOS/queue.c **** 
 516:../Dave/Generated/FREERTOS/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 517:../Dave/Generated/FREERTOS/queue.c **** 
 518:../Dave/Generated/FREERTOS/queue.c **** 	void* xQueueGetMutexHolder( QueueHandle_t xSemaphore )
 519:../Dave/Generated/FREERTOS/queue.c **** 	{
 449              	 .loc 1 519 0
 450              	 .cfi_startproc
 451              	 
 452              	 
 453 0000 80B5     	 push {r7,lr}
 454              	 .cfi_def_cfa_offset 8
 455              	 .cfi_offset 7,-8
 456              	 .cfi_offset 14,-4
 457 0002 84B0     	 sub sp,sp,#16
 458              	 .cfi_def_cfa_offset 24
 459 0004 00AF     	 add r7,sp,#0
 460              	 .cfi_def_cfa_register 7
 461 0006 7860     	 str r0,[r7,#4]
 520:../Dave/Generated/FREERTOS/queue.c **** 	void *pxReturn;
 521:../Dave/Generated/FREERTOS/queue.c **** 
 522:../Dave/Generated/FREERTOS/queue.c **** 		/* This function is called by xSemaphoreGetMutexHolder(), and should not
 523:../Dave/Generated/FREERTOS/queue.c **** 		be called directly.  Note:  This is a good way of determining if the
 524:../Dave/Generated/FREERTOS/queue.c **** 		calling task is the mutex holder, but not a good way of determining the
 525:../Dave/Generated/FREERTOS/queue.c **** 		identity of the mutex holder, as the holder may change between the
 526:../Dave/Generated/FREERTOS/queue.c **** 		following critical section exiting and the function returning. */
 527:../Dave/Generated/FREERTOS/queue.c **** 		taskENTER_CRITICAL();
 462              	 .loc 1 527 0
 463 0008 FFF7FEFF 	 bl vPortEnterCritical
 528:../Dave/Generated/FREERTOS/queue.c **** 		{
 529:../Dave/Generated/FREERTOS/queue.c **** 			if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 464              	 .loc 1 529 0
 465 000c 7B68     	 ldr r3,[r7,#4]
 466 000e 1B68     	 ldr r3,[r3]
 467 0010 002B     	 cmp r3,#0
 468 0012 03D1     	 bne .L24
 530:../Dave/Generated/FREERTOS/queue.c **** 			{
 531:../Dave/Generated/FREERTOS/queue.c **** 				pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pxMutexHolder;
 469              	 .loc 1 531 0
 470 0014 7B68     	 ldr r3,[r7,#4]
 471 0016 5B68     	 ldr r3,[r3,#4]
 472 0018 FB60     	 str r3,[r7,#12]
 473 001a 01E0     	 b .L25
 474              	.L24:
 532:../Dave/Generated/FREERTOS/queue.c **** 			}
 533:../Dave/Generated/FREERTOS/queue.c **** 			else
 534:../Dave/Generated/FREERTOS/queue.c **** 			{
 535:../Dave/Generated/FREERTOS/queue.c **** 				pxReturn = NULL;
 475              	 .loc 1 535 0
 476 001c 0023     	 movs r3,#0
 477 001e FB60     	 str r3,[r7,#12]
 478              	.L25:
 536:../Dave/Generated/FREERTOS/queue.c **** 			}
 537:../Dave/Generated/FREERTOS/queue.c **** 		}
 538:../Dave/Generated/FREERTOS/queue.c **** 		taskEXIT_CRITICAL();
 479              	 .loc 1 538 0
 480 0020 FFF7FEFF 	 bl vPortExitCritical
 539:../Dave/Generated/FREERTOS/queue.c **** 
 540:../Dave/Generated/FREERTOS/queue.c **** 		return pxReturn;
 481              	 .loc 1 540 0
 482 0024 FB68     	 ldr r3,[r7,#12]
 541:../Dave/Generated/FREERTOS/queue.c **** 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 483              	 .loc 1 541 0
 484 0026 1846     	 mov r0,r3
 485 0028 1037     	 adds r7,r7,#16
 486              	 .cfi_def_cfa_offset 8
 487 002a BD46     	 mov sp,r7
 488              	 .cfi_def_cfa_register 13
 489              	 
 490 002c 80BD     	 pop {r7,pc}
 491              	 .cfi_endproc
 492              	.LFE142:
 494 002e 00BF     	 .section .text.xQueueGetMutexHolderFromISR,"ax",%progbits
 495              	 .align 2
 496              	 .global xQueueGetMutexHolderFromISR
 497              	 .thumb
 498              	 .thumb_func
 500              	xQueueGetMutexHolderFromISR:
 501              	.LFB143:
 542:../Dave/Generated/FREERTOS/queue.c **** 
 543:../Dave/Generated/FREERTOS/queue.c **** #endif
 544:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 545:../Dave/Generated/FREERTOS/queue.c **** 
 546:../Dave/Generated/FREERTOS/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 547:../Dave/Generated/FREERTOS/queue.c **** 
 548:../Dave/Generated/FREERTOS/queue.c **** 	void* xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore )
 549:../Dave/Generated/FREERTOS/queue.c **** 	{
 502              	 .loc 1 549 0
 503              	 .cfi_startproc
 504              	 
 505              	 
 506              	 
 507 0000 80B4     	 push {r7}
 508              	 .cfi_def_cfa_offset 4
 509              	 .cfi_offset 7,-4
 510 0002 85B0     	 sub sp,sp,#20
 511              	 .cfi_def_cfa_offset 24
 512 0004 00AF     	 add r7,sp,#0
 513              	 .cfi_def_cfa_register 7
 514 0006 7860     	 str r0,[r7,#4]
 550:../Dave/Generated/FREERTOS/queue.c **** 	void *pxReturn;
 551:../Dave/Generated/FREERTOS/queue.c **** 
 552:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( xSemaphore );
 515              	 .loc 1 552 0
 516 0008 7B68     	 ldr r3,[r7,#4]
 517 000a 002B     	 cmp r3,#0
 518 000c 09D1     	 bne .L28
 519              	.LBB112:
 520              	.LBB113:
 521              	 .loc 2 195 0 discriminator 1
 522              	
 523 000e 4FF0FC03 	 mov r3,#252
 524 0012 83F31188 	 msr basepri,r3
 525 0016 BFF36F8F 	 isb 
 526 001a BFF34F8F 	 dsb 
 527              	
 528              	
 529              	 .thumb
 530 001e BB60     	 str r3,[r7,#8]
 531              	.L29:
 532              	.LBE113:
 533              	.LBE112:
 534              	 .loc 1 552 0 discriminator 1
 535 0020 FEE7     	 b .L29
 536              	.L28:
 553:../Dave/Generated/FREERTOS/queue.c **** 
 554:../Dave/Generated/FREERTOS/queue.c **** 		/* Mutexes cannot be used in interrupt service routines, so the mutex
 555:../Dave/Generated/FREERTOS/queue.c **** 		holder should not change in an ISR, and therefore a critical section is
 556:../Dave/Generated/FREERTOS/queue.c **** 		not required here. */
 557:../Dave/Generated/FREERTOS/queue.c **** 		if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 537              	 .loc 1 557 0
 538 0022 7B68     	 ldr r3,[r7,#4]
 539 0024 1B68     	 ldr r3,[r3]
 540 0026 002B     	 cmp r3,#0
 541 0028 03D1     	 bne .L30
 558:../Dave/Generated/FREERTOS/queue.c **** 		{
 559:../Dave/Generated/FREERTOS/queue.c **** 			pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pxMutexHolder;
 542              	 .loc 1 559 0
 543 002a 7B68     	 ldr r3,[r7,#4]
 544 002c 5B68     	 ldr r3,[r3,#4]
 545 002e FB60     	 str r3,[r7,#12]
 546 0030 01E0     	 b .L31
 547              	.L30:
 560:../Dave/Generated/FREERTOS/queue.c **** 		}
 561:../Dave/Generated/FREERTOS/queue.c **** 		else
 562:../Dave/Generated/FREERTOS/queue.c **** 		{
 563:../Dave/Generated/FREERTOS/queue.c **** 			pxReturn = NULL;
 548              	 .loc 1 563 0
 549 0032 0023     	 movs r3,#0
 550 0034 FB60     	 str r3,[r7,#12]
 551              	.L31:
 564:../Dave/Generated/FREERTOS/queue.c **** 		}
 565:../Dave/Generated/FREERTOS/queue.c **** 
 566:../Dave/Generated/FREERTOS/queue.c **** 		return pxReturn;
 552              	 .loc 1 566 0
 553 0036 FB68     	 ldr r3,[r7,#12]
 567:../Dave/Generated/FREERTOS/queue.c **** 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 554              	 .loc 1 567 0
 555 0038 1846     	 mov r0,r3
 556 003a 1437     	 adds r7,r7,#20
 557              	 .cfi_def_cfa_offset 4
 558 003c BD46     	 mov sp,r7
 559              	 .cfi_def_cfa_register 13
 560              	 
 561 003e 5DF8047B 	 ldr r7,[sp],#4
 562              	 .cfi_restore 7
 563              	 .cfi_def_cfa_offset 0
 564 0042 7047     	 bx lr
 565              	 .cfi_endproc
 566              	.LFE143:
 568              	 .section .text.xQueueGiveMutexRecursive,"ax",%progbits
 569              	 .align 2
 570              	 .global xQueueGiveMutexRecursive
 571              	 .thumb
 572              	 .thumb_func
 574              	xQueueGiveMutexRecursive:
 575              	.LFB144:
 568:../Dave/Generated/FREERTOS/queue.c **** 
 569:../Dave/Generated/FREERTOS/queue.c **** #endif
 570:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 571:../Dave/Generated/FREERTOS/queue.c **** 
 572:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 573:../Dave/Generated/FREERTOS/queue.c **** 
 574:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
 575:../Dave/Generated/FREERTOS/queue.c **** 	{
 576              	 .loc 1 575 0
 577              	 .cfi_startproc
 578              	 
 579              	 
 580 0000 90B5     	 push {r4,r7,lr}
 581              	 .cfi_def_cfa_offset 12
 582              	 .cfi_offset 4,-12
 583              	 .cfi_offset 7,-8
 584              	 .cfi_offset 14,-4
 585 0002 87B0     	 sub sp,sp,#28
 586              	 .cfi_def_cfa_offset 40
 587 0004 00AF     	 add r7,sp,#0
 588              	 .cfi_def_cfa_register 7
 589 0006 7860     	 str r0,[r7,#4]
 576:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xReturn;
 577:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 590              	 .loc 1 577 0
 591 0008 7B68     	 ldr r3,[r7,#4]
 592 000a 3B61     	 str r3,[r7,#16]
 578:../Dave/Generated/FREERTOS/queue.c **** 
 579:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( pxMutex );
 593              	 .loc 1 579 0
 594 000c 3B69     	 ldr r3,[r7,#16]
 595 000e 002B     	 cmp r3,#0
 596 0010 09D1     	 bne .L34
 597              	.LBB114:
 598              	.LBB115:
 599              	 .loc 2 195 0 discriminator 1
 600              	
 601 0012 4FF0FC03 	 mov r3,#252
 602 0016 83F31188 	 msr basepri,r3
 603 001a BFF36F8F 	 isb 
 604 001e BFF34F8F 	 dsb 
 605              	
 606              	
 607              	 .thumb
 608 0022 FB60     	 str r3,[r7,#12]
 609              	.L35:
 610              	.LBE115:
 611              	.LBE114:
 612              	 .loc 1 579 0 discriminator 1
 613 0024 FEE7     	 b .L35
 614              	.L34:
 580:../Dave/Generated/FREERTOS/queue.c **** 
 581:../Dave/Generated/FREERTOS/queue.c **** 		/* If this is the task that holds the mutex then pxMutexHolder will not
 582:../Dave/Generated/FREERTOS/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 583:../Dave/Generated/FREERTOS/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 584:../Dave/Generated/FREERTOS/queue.c **** 		this is the only condition we are interested in it does not matter if
 585:../Dave/Generated/FREERTOS/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 586:../Dave/Generated/FREERTOS/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 587:../Dave/Generated/FREERTOS/queue.c **** 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redunda
 615              	 .loc 1 587 0
 616 0026 3B69     	 ldr r3,[r7,#16]
 617 0028 5C68     	 ldr r4,[r3,#4]
 618 002a FFF7FEFF 	 bl xTaskGetCurrentTaskHandle
 619 002e 0346     	 mov r3,r0
 620 0030 9C42     	 cmp r4,r3
 621 0032 11D1     	 bne .L36
 588:../Dave/Generated/FREERTOS/queue.c **** 		{
 589:../Dave/Generated/FREERTOS/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 590:../Dave/Generated/FREERTOS/queue.c **** 
 591:../Dave/Generated/FREERTOS/queue.c **** 			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
 592:../Dave/Generated/FREERTOS/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 593:../Dave/Generated/FREERTOS/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 594:../Dave/Generated/FREERTOS/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 595:../Dave/Generated/FREERTOS/queue.c **** 			uxRecursiveCallCount member. */
 596:../Dave/Generated/FREERTOS/queue.c **** 			( pxMutex->u.uxRecursiveCallCount )--;
 622              	 .loc 1 596 0
 623 0034 3B69     	 ldr r3,[r7,#16]
 624 0036 DB68     	 ldr r3,[r3,#12]
 625 0038 5A1E     	 subs r2,r3,#1
 626 003a 3B69     	 ldr r3,[r7,#16]
 627 003c DA60     	 str r2,[r3,#12]
 597:../Dave/Generated/FREERTOS/queue.c **** 
 598:../Dave/Generated/FREERTOS/queue.c **** 			/* Has the recursive call count unwound to 0? */
 599:../Dave/Generated/FREERTOS/queue.c **** 			if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 628              	 .loc 1 599 0
 629 003e 3B69     	 ldr r3,[r7,#16]
 630 0040 DB68     	 ldr r3,[r3,#12]
 631 0042 002B     	 cmp r3,#0
 632 0044 05D1     	 bne .L37
 600:../Dave/Generated/FREERTOS/queue.c **** 			{
 601:../Dave/Generated/FREERTOS/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 602:../Dave/Generated/FREERTOS/queue.c **** 				task that might be waiting to access the mutex. */
 603:../Dave/Generated/FREERTOS/queue.c **** 				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 633              	 .loc 1 603 0
 634 0046 3869     	 ldr r0,[r7,#16]
 635 0048 0021     	 movs r1,#0
 636 004a 0022     	 movs r2,#0
 637 004c 0023     	 movs r3,#0
 638 004e FFF7FEFF 	 bl xQueueGenericSend
 639              	.L37:
 604:../Dave/Generated/FREERTOS/queue.c **** 			}
 605:../Dave/Generated/FREERTOS/queue.c **** 			else
 606:../Dave/Generated/FREERTOS/queue.c **** 			{
 607:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 608:../Dave/Generated/FREERTOS/queue.c **** 			}
 609:../Dave/Generated/FREERTOS/queue.c **** 
 610:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdPASS;
 640              	 .loc 1 610 0
 641 0052 0123     	 movs r3,#1
 642 0054 7B61     	 str r3,[r7,#20]
 643 0056 01E0     	 b .L38
 644              	.L36:
 611:../Dave/Generated/FREERTOS/queue.c **** 		}
 612:../Dave/Generated/FREERTOS/queue.c **** 		else
 613:../Dave/Generated/FREERTOS/queue.c **** 		{
 614:../Dave/Generated/FREERTOS/queue.c **** 			/* The mutex cannot be given because the calling task is not the
 615:../Dave/Generated/FREERTOS/queue.c **** 			holder. */
 616:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdFAIL;
 645              	 .loc 1 616 0
 646 0058 0023     	 movs r3,#0
 647 005a 7B61     	 str r3,[r7,#20]
 648              	.L38:
 617:../Dave/Generated/FREERTOS/queue.c **** 
 618:../Dave/Generated/FREERTOS/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 619:../Dave/Generated/FREERTOS/queue.c **** 		}
 620:../Dave/Generated/FREERTOS/queue.c **** 
 621:../Dave/Generated/FREERTOS/queue.c **** 		return xReturn;
 649              	 .loc 1 621 0
 650 005c 7B69     	 ldr r3,[r7,#20]
 622:../Dave/Generated/FREERTOS/queue.c **** 	}
 651              	 .loc 1 622 0
 652 005e 1846     	 mov r0,r3
 653 0060 1C37     	 adds r7,r7,#28
 654              	 .cfi_def_cfa_offset 12
 655 0062 BD46     	 mov sp,r7
 656              	 .cfi_def_cfa_register 13
 657              	 
 658 0064 90BD     	 pop {r4,r7,pc}
 659              	 .cfi_endproc
 660              	.LFE144:
 662 0066 00BF     	 .section .text.xQueueTakeMutexRecursive,"ax",%progbits
 663              	 .align 2
 664              	 .global xQueueTakeMutexRecursive
 665              	 .thumb
 666              	 .thumb_func
 668              	xQueueTakeMutexRecursive:
 669              	.LFB145:
 623:../Dave/Generated/FREERTOS/queue.c **** 
 624:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 625:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 626:../Dave/Generated/FREERTOS/queue.c **** 
 627:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 628:../Dave/Generated/FREERTOS/queue.c **** 
 629:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
 630:../Dave/Generated/FREERTOS/queue.c **** 	{
 670              	 .loc 1 630 0
 671              	 .cfi_startproc
 672              	 
 673              	 
 674 0000 90B5     	 push {r4,r7,lr}
 675              	 .cfi_def_cfa_offset 12
 676              	 .cfi_offset 4,-12
 677              	 .cfi_offset 7,-8
 678              	 .cfi_offset 14,-4
 679 0002 87B0     	 sub sp,sp,#28
 680              	 .cfi_def_cfa_offset 40
 681 0004 00AF     	 add r7,sp,#0
 682              	 .cfi_def_cfa_register 7
 683 0006 7860     	 str r0,[r7,#4]
 684 0008 3960     	 str r1,[r7]
 631:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xReturn;
 632:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 685              	 .loc 1 632 0
 686 000a 7B68     	 ldr r3,[r7,#4]
 687 000c 3B61     	 str r3,[r7,#16]
 633:../Dave/Generated/FREERTOS/queue.c **** 
 634:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( pxMutex );
 688              	 .loc 1 634 0
 689 000e 3B69     	 ldr r3,[r7,#16]
 690 0010 002B     	 cmp r3,#0
 691 0012 09D1     	 bne .L41
 692              	.LBB116:
 693              	.LBB117:
 694              	 .loc 2 195 0 discriminator 1
 695              	
 696 0014 4FF0FC03 	 mov r3,#252
 697 0018 83F31188 	 msr basepri,r3
 698 001c BFF36F8F 	 isb 
 699 0020 BFF34F8F 	 dsb 
 700              	
 701              	
 702              	 .thumb
 703 0024 FB60     	 str r3,[r7,#12]
 704              	.L42:
 705              	.LBE117:
 706              	.LBE116:
 707              	 .loc 1 634 0 discriminator 1
 708 0026 FEE7     	 b .L42
 709              	.L41:
 635:../Dave/Generated/FREERTOS/queue.c **** 
 636:../Dave/Generated/FREERTOS/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 637:../Dave/Generated/FREERTOS/queue.c **** 		xQueueGiveMutexRecursive(). */
 638:../Dave/Generated/FREERTOS/queue.c **** 
 639:../Dave/Generated/FREERTOS/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 640:../Dave/Generated/FREERTOS/queue.c **** 
 641:../Dave/Generated/FREERTOS/queue.c **** 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not r
 710              	 .loc 1 641 0
 711 0028 3B69     	 ldr r3,[r7,#16]
 712 002a 5C68     	 ldr r4,[r3,#4]
 713 002c FFF7FEFF 	 bl xTaskGetCurrentTaskHandle
 714 0030 0346     	 mov r3,r0
 715 0032 9C42     	 cmp r4,r3
 716 0034 07D1     	 bne .L43
 642:../Dave/Generated/FREERTOS/queue.c **** 		{
 643:../Dave/Generated/FREERTOS/queue.c **** 			( pxMutex->u.uxRecursiveCallCount )++;
 717              	 .loc 1 643 0
 718 0036 3B69     	 ldr r3,[r7,#16]
 719 0038 DB68     	 ldr r3,[r3,#12]
 720 003a 5A1C     	 adds r2,r3,#1
 721 003c 3B69     	 ldr r3,[r7,#16]
 722 003e DA60     	 str r2,[r3,#12]
 644:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdPASS;
 723              	 .loc 1 644 0
 724 0040 0123     	 movs r3,#1
 725 0042 7B61     	 str r3,[r7,#20]
 726 0044 0CE0     	 b .L44
 727              	.L43:
 645:../Dave/Generated/FREERTOS/queue.c **** 		}
 646:../Dave/Generated/FREERTOS/queue.c **** 		else
 647:../Dave/Generated/FREERTOS/queue.c **** 		{
 648:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
 728              	 .loc 1 648 0
 729 0046 3869     	 ldr r0,[r7,#16]
 730 0048 3968     	 ldr r1,[r7]
 731 004a FFF7FEFF 	 bl xQueueSemaphoreTake
 732 004e 7861     	 str r0,[r7,#20]
 649:../Dave/Generated/FREERTOS/queue.c **** 
 650:../Dave/Generated/FREERTOS/queue.c **** 			/* pdPASS will only be returned if the mutex was successfully
 651:../Dave/Generated/FREERTOS/queue.c **** 			obtained.  The calling task may have entered the Blocked state
 652:../Dave/Generated/FREERTOS/queue.c **** 			before reaching here. */
 653:../Dave/Generated/FREERTOS/queue.c **** 			if( xReturn != pdFAIL )
 733              	 .loc 1 653 0
 734 0050 7B69     	 ldr r3,[r7,#20]
 735 0052 002B     	 cmp r3,#0
 736 0054 04D0     	 beq .L44
 654:../Dave/Generated/FREERTOS/queue.c **** 			{
 655:../Dave/Generated/FREERTOS/queue.c **** 				( pxMutex->u.uxRecursiveCallCount )++;
 737              	 .loc 1 655 0
 738 0056 3B69     	 ldr r3,[r7,#16]
 739 0058 DB68     	 ldr r3,[r3,#12]
 740 005a 5A1C     	 adds r2,r3,#1
 741 005c 3B69     	 ldr r3,[r7,#16]
 742 005e DA60     	 str r2,[r3,#12]
 743              	.L44:
 656:../Dave/Generated/FREERTOS/queue.c **** 			}
 657:../Dave/Generated/FREERTOS/queue.c **** 			else
 658:../Dave/Generated/FREERTOS/queue.c **** 			{
 659:../Dave/Generated/FREERTOS/queue.c **** 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 660:../Dave/Generated/FREERTOS/queue.c **** 			}
 661:../Dave/Generated/FREERTOS/queue.c **** 		}
 662:../Dave/Generated/FREERTOS/queue.c **** 
 663:../Dave/Generated/FREERTOS/queue.c **** 		return xReturn;
 744              	 .loc 1 663 0
 745 0060 7B69     	 ldr r3,[r7,#20]
 664:../Dave/Generated/FREERTOS/queue.c **** 	}
 746              	 .loc 1 664 0
 747 0062 1846     	 mov r0,r3
 748 0064 1C37     	 adds r7,r7,#28
 749              	 .cfi_def_cfa_offset 12
 750 0066 BD46     	 mov sp,r7
 751              	 .cfi_def_cfa_register 13
 752              	 
 753 0068 90BD     	 pop {r4,r7,pc}
 754              	 .cfi_endproc
 755              	.LFE145:
 757 006a 00BF     	 .section .text.xQueueCreateCountingSemaphore,"ax",%progbits
 758              	 .align 2
 759              	 .global xQueueCreateCountingSemaphore
 760              	 .thumb
 761              	 .thumb_func
 763              	xQueueCreateCountingSemaphore:
 764              	.LFB146:
 665:../Dave/Generated/FREERTOS/queue.c **** 
 666:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 667:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 668:../Dave/Generated/FREERTOS/queue.c **** 
 669:../Dave/Generated/FREERTOS/queue.c **** #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 670:../Dave/Generated/FREERTOS/queue.c **** 
 671:../Dave/Generated/FREERTOS/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t
 672:../Dave/Generated/FREERTOS/queue.c **** 	{
 673:../Dave/Generated/FREERTOS/queue.c **** 	QueueHandle_t xHandle;
 674:../Dave/Generated/FREERTOS/queue.c **** 
 675:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( uxMaxCount != 0 );
 676:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 677:../Dave/Generated/FREERTOS/queue.c **** 
 678:../Dave/Generated/FREERTOS/queue.c **** 		xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStatic
 679:../Dave/Generated/FREERTOS/queue.c **** 
 680:../Dave/Generated/FREERTOS/queue.c **** 		if( xHandle != NULL )
 681:../Dave/Generated/FREERTOS/queue.c **** 		{
 682:../Dave/Generated/FREERTOS/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 683:../Dave/Generated/FREERTOS/queue.c **** 
 684:../Dave/Generated/FREERTOS/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 685:../Dave/Generated/FREERTOS/queue.c **** 		}
 686:../Dave/Generated/FREERTOS/queue.c **** 		else
 687:../Dave/Generated/FREERTOS/queue.c **** 		{
 688:../Dave/Generated/FREERTOS/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 689:../Dave/Generated/FREERTOS/queue.c **** 		}
 690:../Dave/Generated/FREERTOS/queue.c **** 
 691:../Dave/Generated/FREERTOS/queue.c **** 		return xHandle;
 692:../Dave/Generated/FREERTOS/queue.c **** 	}
 693:../Dave/Generated/FREERTOS/queue.c **** 
 694:../Dave/Generated/FREERTOS/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 695:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 696:../Dave/Generated/FREERTOS/queue.c **** 
 697:../Dave/Generated/FREERTOS/queue.c **** #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 698:../Dave/Generated/FREERTOS/queue.c **** 
 699:../Dave/Generated/FREERTOS/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxIni
 700:../Dave/Generated/FREERTOS/queue.c **** 	{
 765              	 .loc 1 700 0
 766              	 .cfi_startproc
 767              	 
 768              	 
 769 0000 80B5     	 push {r7,lr}
 770              	 .cfi_def_cfa_offset 8
 771              	 .cfi_offset 7,-8
 772              	 .cfi_offset 14,-4
 773 0002 86B0     	 sub sp,sp,#24
 774              	 .cfi_def_cfa_offset 32
 775 0004 00AF     	 add r7,sp,#0
 776              	 .cfi_def_cfa_register 7
 777 0006 7860     	 str r0,[r7,#4]
 778 0008 3960     	 str r1,[r7]
 701:../Dave/Generated/FREERTOS/queue.c **** 	QueueHandle_t xHandle;
 702:../Dave/Generated/FREERTOS/queue.c **** 
 703:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( uxMaxCount != 0 );
 779              	 .loc 1 703 0
 780 000a 7B68     	 ldr r3,[r7,#4]
 781 000c 002B     	 cmp r3,#0
 782 000e 09D1     	 bne .L47
 783              	.LBB118:
 784              	.LBB119:
 785              	 .loc 2 195 0 discriminator 1
 786              	
 787 0010 4FF0FC03 	 mov r3,#252
 788 0014 83F31188 	 msr basepri,r3
 789 0018 BFF36F8F 	 isb 
 790 001c BFF34F8F 	 dsb 
 791              	
 792              	
 793              	 .thumb
 794 0020 3B61     	 str r3,[r7,#16]
 795              	.L48:
 796              	.LBE119:
 797              	.LBE118:
 798              	 .loc 1 703 0 discriminator 1
 799 0022 FEE7     	 b .L48
 800              	.L47:
 704:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 801              	 .loc 1 704 0
 802 0024 3A68     	 ldr r2,[r7]
 803 0026 7B68     	 ldr r3,[r7,#4]
 804 0028 9A42     	 cmp r2,r3
 805 002a 09D9     	 bls .L49
 806              	.LBB120:
 807              	.LBB121:
 808              	 .loc 2 195 0 discriminator 1
 809              	
 810 002c 4FF0FC03 	 mov r3,#252
 811 0030 83F31188 	 msr basepri,r3
 812 0034 BFF36F8F 	 isb 
 813 0038 BFF34F8F 	 dsb 
 814              	
 815              	
 816              	 .thumb
 817 003c FB60     	 str r3,[r7,#12]
 818              	.L50:
 819              	.LBE121:
 820              	.LBE120:
 821              	 .loc 1 704 0 discriminator 2
 822 003e FEE7     	 b .L50
 823              	.L49:
 705:../Dave/Generated/FREERTOS/queue.c **** 
 706:../Dave/Generated/FREERTOS/queue.c **** 		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUN
 824              	 .loc 1 706 0
 825 0040 7868     	 ldr r0,[r7,#4]
 826 0042 0021     	 movs r1,#0
 827 0044 0222     	 movs r2,#2
 828 0046 FFF7FEFF 	 bl xQueueGenericCreate
 829 004a 7861     	 str r0,[r7,#20]
 707:../Dave/Generated/FREERTOS/queue.c **** 
 708:../Dave/Generated/FREERTOS/queue.c **** 		if( xHandle != NULL )
 830              	 .loc 1 708 0
 831 004c 7B69     	 ldr r3,[r7,#20]
 832 004e 002B     	 cmp r3,#0
 833 0050 02D0     	 beq .L51
 709:../Dave/Generated/FREERTOS/queue.c **** 		{
 710:../Dave/Generated/FREERTOS/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 834              	 .loc 1 710 0
 835 0052 7B69     	 ldr r3,[r7,#20]
 836 0054 3A68     	 ldr r2,[r7]
 837 0056 9A63     	 str r2,[r3,#56]
 838              	.L51:
 711:../Dave/Generated/FREERTOS/queue.c **** 
 712:../Dave/Generated/FREERTOS/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 713:../Dave/Generated/FREERTOS/queue.c **** 		}
 714:../Dave/Generated/FREERTOS/queue.c **** 		else
 715:../Dave/Generated/FREERTOS/queue.c **** 		{
 716:../Dave/Generated/FREERTOS/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 717:../Dave/Generated/FREERTOS/queue.c **** 		}
 718:../Dave/Generated/FREERTOS/queue.c **** 
 719:../Dave/Generated/FREERTOS/queue.c **** 		return xHandle;
 839              	 .loc 1 719 0
 840 0058 7B69     	 ldr r3,[r7,#20]
 720:../Dave/Generated/FREERTOS/queue.c **** 	}
 841              	 .loc 1 720 0
 842 005a 1846     	 mov r0,r3
 843 005c 1837     	 adds r7,r7,#24
 844              	 .cfi_def_cfa_offset 8
 845 005e BD46     	 mov sp,r7
 846              	 .cfi_def_cfa_register 13
 847              	 
 848 0060 80BD     	 pop {r7,pc}
 849              	 .cfi_endproc
 850              	.LFE146:
 852 0062 00BF     	 .section .text.xQueueGenericSend,"ax",%progbits
 853              	 .align 2
 854              	 .global xQueueGenericSend
 855              	 .thumb
 856              	 .thumb_func
 858              	xQueueGenericSend:
 859              	.LFB147:
 721:../Dave/Generated/FREERTOS/queue.c **** 
 722:../Dave/Generated/FREERTOS/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 723:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 724:../Dave/Generated/FREERTOS/queue.c **** 
 725:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xT
 726:../Dave/Generated/FREERTOS/queue.c **** {
 860              	 .loc 1 726 0
 861              	 .cfi_startproc
 862              	 
 863              	 
 864 0000 80B5     	 push {r7,lr}
 865              	 .cfi_def_cfa_offset 8
 866              	 .cfi_offset 7,-8
 867              	 .cfi_offset 14,-4
 868 0002 8EB0     	 sub sp,sp,#56
 869              	 .cfi_def_cfa_offset 64
 870 0004 00AF     	 add r7,sp,#0
 871              	 .cfi_def_cfa_register 7
 872 0006 F860     	 str r0,[r7,#12]
 873 0008 B960     	 str r1,[r7,#8]
 874 000a 7A60     	 str r2,[r7,#4]
 875 000c 3B60     	 str r3,[r7]
 727:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 876              	 .loc 1 727 0
 877 000e 0023     	 movs r3,#0
 878 0010 7B63     	 str r3,[r7,#52]
 728:../Dave/Generated/FREERTOS/queue.c **** TimeOut_t xTimeOut;
 729:../Dave/Generated/FREERTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 879              	 .loc 1 729 0
 880 0012 FB68     	 ldr r3,[r7,#12]
 881 0014 3B63     	 str r3,[r7,#48]
 730:../Dave/Generated/FREERTOS/queue.c **** 
 731:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue );
 882              	 .loc 1 731 0
 883 0016 3B6B     	 ldr r3,[r7,#48]
 884 0018 002B     	 cmp r3,#0
 885 001a 09D1     	 bne .L54
 886              	.LBB122:
 887              	.LBB123:
 888              	 .loc 2 195 0 discriminator 1
 889              	
 890 001c 4FF0FC03 	 mov r3,#252
 891 0020 83F31188 	 msr basepri,r3
 892 0024 BFF36F8F 	 isb 
 893 0028 BFF34F8F 	 dsb 
 894              	
 895              	
 896              	 .thumb
 897 002c BB62     	 str r3,[r7,#40]
 898              	.L55:
 899              	.LBE123:
 900              	.LBE122:
 901              	 .loc 1 731 0 discriminator 1
 902 002e FEE7     	 b .L55
 903              	.L54:
 732:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 904              	 .loc 1 732 0
 905 0030 BB68     	 ldr r3,[r7,#8]
 906 0032 002B     	 cmp r3,#0
 907 0034 03D1     	 bne .L56
 908              	 .loc 1 732 0 is_stmt 0 discriminator 2
 909 0036 3B6B     	 ldr r3,[r7,#48]
 910 0038 1B6C     	 ldr r3,[r3,#64]
 911 003a 002B     	 cmp r3,#0
 912 003c 01D1     	 bne .L57
 913              	.L56:
 914              	 .loc 1 732 0 discriminator 3
 915 003e 0123     	 movs r3,#1
 916 0040 00E0     	 b .L58
 917              	.L57:
 918              	 .loc 1 732 0 discriminator 4
 919 0042 0023     	 movs r3,#0
 920              	.L58:
 921              	 .loc 1 732 0 discriminator 6
 922 0044 002B     	 cmp r3,#0
 923 0046 09D1     	 bne .L59
 924              	.LBB124:
 925              	.LBB125:
 926              	 .loc 2 195 0 is_stmt 1 discriminator 7
 927              	
 928 0048 4FF0FC03 	 mov r3,#252
 929 004c 83F31188 	 msr basepri,r3
 930 0050 BFF36F8F 	 isb 
 931 0054 BFF34F8F 	 dsb 
 932              	
 933              	
 934              	 .thumb
 935 0058 7B62     	 str r3,[r7,#36]
 936              	.L60:
 937              	.LBE125:
 938              	.LBE124:
 939              	 .loc 1 732 0 discriminator 2
 940 005a FEE7     	 b .L60
 941              	.L59:
 733:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 942              	 .loc 1 733 0
 943 005c 3B68     	 ldr r3,[r7]
 944 005e 022B     	 cmp r3,#2
 945 0060 03D1     	 bne .L61
 946              	 .loc 1 733 0 is_stmt 0 discriminator 2
 947 0062 3B6B     	 ldr r3,[r7,#48]
 948 0064 DB6B     	 ldr r3,[r3,#60]
 949 0066 012B     	 cmp r3,#1
 950 0068 01D1     	 bne .L62
 951              	.L61:
 952              	 .loc 1 733 0 discriminator 3
 953 006a 0123     	 movs r3,#1
 954 006c 00E0     	 b .L63
 955              	.L62:
 956              	 .loc 1 733 0 discriminator 4
 957 006e 0023     	 movs r3,#0
 958              	.L63:
 959              	 .loc 1 733 0 discriminator 6
 960 0070 002B     	 cmp r3,#0
 961 0072 09D1     	 bne .L64
 962              	.LBB126:
 963              	.LBB127:
 964              	 .loc 2 195 0 is_stmt 1 discriminator 7
 965              	
 966 0074 4FF0FC03 	 mov r3,#252
 967 0078 83F31188 	 msr basepri,r3
 968 007c BFF36F8F 	 isb 
 969 0080 BFF34F8F 	 dsb 
 970              	
 971              	
 972              	 .thumb
 973 0084 3B62     	 str r3,[r7,#32]
 974              	.L65:
 975              	.LBE127:
 976              	.LBE126:
 977              	 .loc 1 733 0 discriminator 3
 978 0086 FEE7     	 b .L65
 979              	.L64:
 734:../Dave/Generated/FREERTOS/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 735:../Dave/Generated/FREERTOS/queue.c **** 	{
 736:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
 980              	 .loc 1 736 0
 981 0088 FFF7FEFF 	 bl xTaskGetSchedulerState
 982 008c 0346     	 mov r3,r0
 983 008e 002B     	 cmp r3,#0
 984 0090 02D1     	 bne .L66
 985              	 .loc 1 736 0 is_stmt 0 discriminator 2
 986 0092 7B68     	 ldr r3,[r7,#4]
 987 0094 002B     	 cmp r3,#0
 988 0096 01D1     	 bne .L67
 989              	.L66:
 990              	 .loc 1 736 0 discriminator 3
 991 0098 0123     	 movs r3,#1
 992 009a 00E0     	 b .L68
 993              	.L67:
 994              	 .loc 1 736 0 discriminator 4
 995 009c 0023     	 movs r3,#0
 996              	.L68:
 997              	 .loc 1 736 0 discriminator 6
 998 009e 002B     	 cmp r3,#0
 999 00a0 09D1     	 bne .L69
 1000              	.LBB128:
 1001              	.LBB129:
 1002              	 .loc 2 195 0 is_stmt 1 discriminator 7
 1003              	
 1004 00a2 4FF0FC03 	 mov r3,#252
 1005 00a6 83F31188 	 msr basepri,r3
 1006 00aa BFF36F8F 	 isb 
 1007 00ae BFF34F8F 	 dsb 
 1008              	
 1009              	
 1010              	 .thumb
 1011 00b2 FB61     	 str r3,[r7,#28]
 1012              	.L70:
 1013              	.LBE129:
 1014              	.LBE128:
 1015              	 .loc 1 736 0 discriminator 4
 1016 00b4 FEE7     	 b .L70
 1017              	.L69:
 737:../Dave/Generated/FREERTOS/queue.c **** 	}
 738:../Dave/Generated/FREERTOS/queue.c **** 	#endif
 739:../Dave/Generated/FREERTOS/queue.c **** 
 740:../Dave/Generated/FREERTOS/queue.c **** 
 741:../Dave/Generated/FREERTOS/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 742:../Dave/Generated/FREERTOS/queue.c **** 	statements within the function itself.  This is done in the interest
 743:../Dave/Generated/FREERTOS/queue.c **** 	of execution time efficiency. */
 744:../Dave/Generated/FREERTOS/queue.c **** 	for( ;; )
 745:../Dave/Generated/FREERTOS/queue.c **** 	{
 746:../Dave/Generated/FREERTOS/queue.c **** 		taskENTER_CRITICAL();
 1018              	 .loc 1 746 0
 1019 00b6 FFF7FEFF 	 bl vPortEnterCritical
 747:../Dave/Generated/FREERTOS/queue.c **** 		{
 748:../Dave/Generated/FREERTOS/queue.c **** 			/* Is there room on the queue now?  The running task must be the
 749:../Dave/Generated/FREERTOS/queue.c **** 			highest priority task wanting to access the queue.  If the head item
 750:../Dave/Generated/FREERTOS/queue.c **** 			in the queue is to be overwritten then it does not matter if the
 751:../Dave/Generated/FREERTOS/queue.c **** 			queue is full. */
 752:../Dave/Generated/FREERTOS/queue.c **** 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 1020              	 .loc 1 752 0
 1021 00ba 3B6B     	 ldr r3,[r7,#48]
 1022 00bc 9A6B     	 ldr r2,[r3,#56]
 1023 00be 3B6B     	 ldr r3,[r7,#48]
 1024 00c0 DB6B     	 ldr r3,[r3,#60]
 1025 00c2 9A42     	 cmp r2,r3
 1026 00c4 02D3     	 bcc .L71
 1027              	 .loc 1 752 0 is_stmt 0 discriminator 1
 1028 00c6 3B68     	 ldr r3,[r7]
 1029 00c8 022B     	 cmp r3,#2
 1030 00ca 3DD1     	 bne .L72
 1031              	.L71:
 753:../Dave/Generated/FREERTOS/queue.c **** 			{
 754:../Dave/Generated/FREERTOS/queue.c **** 				traceQUEUE_SEND( pxQueue );
 755:../Dave/Generated/FREERTOS/queue.c **** 				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 1032              	 .loc 1 755 0 is_stmt 1
 1033 00cc 386B     	 ldr r0,[r7,#48]
 1034 00ce B968     	 ldr r1,[r7,#8]
 1035 00d0 3A68     	 ldr r2,[r7]
 1036 00d2 FFF7FEFF 	 bl prvCopyDataToQueue
 1037 00d6 F862     	 str r0,[r7,#44]
 756:../Dave/Generated/FREERTOS/queue.c **** 
 757:../Dave/Generated/FREERTOS/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 758:../Dave/Generated/FREERTOS/queue.c **** 				{
 759:../Dave/Generated/FREERTOS/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 1038              	 .loc 1 759 0
 1039 00d8 3B6B     	 ldr r3,[r7,#48]
 1040 00da 9B6C     	 ldr r3,[r3,#72]
 1041 00dc 002B     	 cmp r3,#0
 1042 00de 0FD0     	 beq .L73
 760:../Dave/Generated/FREERTOS/queue.c **** 					{
 761:../Dave/Generated/FREERTOS/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
 1043              	 .loc 1 761 0
 1044 00e0 386B     	 ldr r0,[r7,#48]
 1045 00e2 3968     	 ldr r1,[r7]
 1046 00e4 FFF7FEFF 	 bl prvNotifyQueueSetContainer
 1047 00e8 0346     	 mov r3,r0
 1048 00ea 002B     	 cmp r3,#0
 1049 00ec 28D0     	 beq .L74
 762:../Dave/Generated/FREERTOS/queue.c **** 						{
 763:../Dave/Generated/FREERTOS/queue.c **** 							/* The queue is a member of a queue set, and posting
 764:../Dave/Generated/FREERTOS/queue.c **** 							to the queue set caused a higher priority task to
 765:../Dave/Generated/FREERTOS/queue.c **** 							unblock. A context switch is required. */
 766:../Dave/Generated/FREERTOS/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 1050              	 .loc 1 766 0
 1051 00ee 4C4B     	 ldr r3,.L87
 1052 00f0 4FF08052 	 mov r2,#268435456
 1053 00f4 1A60     	 str r2,[r3]
 1054              	
 1055 00f6 BFF34F8F 	 dsb
 1056              	
 1057              	
 1058 00fa BFF36F8F 	 isb
 1059              	
 1060              	 .thumb
 1061 00fe 1FE0     	 b .L74
 1062              	.L73:
 767:../Dave/Generated/FREERTOS/queue.c **** 						}
 768:../Dave/Generated/FREERTOS/queue.c **** 						else
 769:../Dave/Generated/FREERTOS/queue.c **** 						{
 770:../Dave/Generated/FREERTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 771:../Dave/Generated/FREERTOS/queue.c **** 						}
 772:../Dave/Generated/FREERTOS/queue.c **** 					}
 773:../Dave/Generated/FREERTOS/queue.c **** 					else
 774:../Dave/Generated/FREERTOS/queue.c **** 					{
 775:../Dave/Generated/FREERTOS/queue.c **** 						/* If there was a task waiting for data to arrive on the
 776:../Dave/Generated/FREERTOS/queue.c **** 						queue then unblock it now. */
 777:../Dave/Generated/FREERTOS/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1063              	 .loc 1 777 0
 1064 0100 3B6B     	 ldr r3,[r7,#48]
 1065 0102 5B6A     	 ldr r3,[r3,#36]
 1066 0104 002B     	 cmp r3,#0
 1067 0106 10D0     	 beq .L75
 778:../Dave/Generated/FREERTOS/queue.c **** 						{
 779:../Dave/Generated/FREERTOS/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1068              	 .loc 1 779 0
 1069 0108 3B6B     	 ldr r3,[r7,#48]
 1070 010a 2433     	 adds r3,r3,#36
 1071 010c 1846     	 mov r0,r3
 1072 010e FFF7FEFF 	 bl xTaskRemoveFromEventList
 1073 0112 0346     	 mov r3,r0
 1074 0114 002B     	 cmp r3,#0
 1075 0116 13D0     	 beq .L74
 780:../Dave/Generated/FREERTOS/queue.c **** 							{
 781:../Dave/Generated/FREERTOS/queue.c **** 								/* The unblocked task has a priority higher than
 782:../Dave/Generated/FREERTOS/queue.c **** 								our own so yield immediately.  Yes it is ok to
 783:../Dave/Generated/FREERTOS/queue.c **** 								do this from within the critical section - the
 784:../Dave/Generated/FREERTOS/queue.c **** 								kernel takes care of that. */
 785:../Dave/Generated/FREERTOS/queue.c **** 								queueYIELD_IF_USING_PREEMPTION();
 1076              	 .loc 1 785 0
 1077 0118 414B     	 ldr r3,.L87
 1078 011a 4FF08052 	 mov r2,#268435456
 1079 011e 1A60     	 str r2,[r3]
 1080              	
 1081 0120 BFF34F8F 	 dsb
 1082              	
 1083              	
 1084 0124 BFF36F8F 	 isb
 1085              	
 1086              	 .thumb
 1087 0128 0AE0     	 b .L74
 1088              	.L75:
 786:../Dave/Generated/FREERTOS/queue.c **** 							}
 787:../Dave/Generated/FREERTOS/queue.c **** 							else
 788:../Dave/Generated/FREERTOS/queue.c **** 							{
 789:../Dave/Generated/FREERTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 790:../Dave/Generated/FREERTOS/queue.c **** 							}
 791:../Dave/Generated/FREERTOS/queue.c **** 						}
 792:../Dave/Generated/FREERTOS/queue.c **** 						else if( xYieldRequired != pdFALSE )
 1089              	 .loc 1 792 0
 1090 012a FB6A     	 ldr r3,[r7,#44]
 1091 012c 002B     	 cmp r3,#0
 1092 012e 07D0     	 beq .L74
 793:../Dave/Generated/FREERTOS/queue.c **** 						{
 794:../Dave/Generated/FREERTOS/queue.c **** 							/* This path is a special case that will only get
 795:../Dave/Generated/FREERTOS/queue.c **** 							executed if the task was holding multiple mutexes
 796:../Dave/Generated/FREERTOS/queue.c **** 							and the mutexes were given back in an order that is
 797:../Dave/Generated/FREERTOS/queue.c **** 							different to that in which they were taken. */
 798:../Dave/Generated/FREERTOS/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 1093              	 .loc 1 798 0
 1094 0130 3B4B     	 ldr r3,.L87
 1095 0132 4FF08052 	 mov r2,#268435456
 1096 0136 1A60     	 str r2,[r3]
 1097              	
 1098 0138 BFF34F8F 	 dsb
 1099              	
 1100              	
 1101 013c BFF36F8F 	 isb
 1102              	
 1103              	 .thumb
 1104              	.L74:
 799:../Dave/Generated/FREERTOS/queue.c **** 						}
 800:../Dave/Generated/FREERTOS/queue.c **** 						else
 801:../Dave/Generated/FREERTOS/queue.c **** 						{
 802:../Dave/Generated/FREERTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 803:../Dave/Generated/FREERTOS/queue.c **** 						}
 804:../Dave/Generated/FREERTOS/queue.c **** 					}
 805:../Dave/Generated/FREERTOS/queue.c **** 				}
 806:../Dave/Generated/FREERTOS/queue.c **** 				#else /* configUSE_QUEUE_SETS */
 807:../Dave/Generated/FREERTOS/queue.c **** 				{
 808:../Dave/Generated/FREERTOS/queue.c **** 					/* If there was a task waiting for data to arrive on the
 809:../Dave/Generated/FREERTOS/queue.c **** 					queue then unblock it now. */
 810:../Dave/Generated/FREERTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 811:../Dave/Generated/FREERTOS/queue.c **** 					{
 812:../Dave/Generated/FREERTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 813:../Dave/Generated/FREERTOS/queue.c **** 						{
 814:../Dave/Generated/FREERTOS/queue.c **** 							/* The unblocked task has a priority higher than
 815:../Dave/Generated/FREERTOS/queue.c **** 							our own so yield immediately.  Yes it is ok to do
 816:../Dave/Generated/FREERTOS/queue.c **** 							this from within the critical section - the kernel
 817:../Dave/Generated/FREERTOS/queue.c **** 							takes care of that. */
 818:../Dave/Generated/FREERTOS/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 819:../Dave/Generated/FREERTOS/queue.c **** 						}
 820:../Dave/Generated/FREERTOS/queue.c **** 						else
 821:../Dave/Generated/FREERTOS/queue.c **** 						{
 822:../Dave/Generated/FREERTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 823:../Dave/Generated/FREERTOS/queue.c **** 						}
 824:../Dave/Generated/FREERTOS/queue.c **** 					}
 825:../Dave/Generated/FREERTOS/queue.c **** 					else if( xYieldRequired != pdFALSE )
 826:../Dave/Generated/FREERTOS/queue.c **** 					{
 827:../Dave/Generated/FREERTOS/queue.c **** 						/* This path is a special case that will only get
 828:../Dave/Generated/FREERTOS/queue.c **** 						executed if the task was holding multiple mutexes and
 829:../Dave/Generated/FREERTOS/queue.c **** 						the mutexes were given back in an order that is
 830:../Dave/Generated/FREERTOS/queue.c **** 						different to that in which they were taken. */
 831:../Dave/Generated/FREERTOS/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 832:../Dave/Generated/FREERTOS/queue.c **** 					}
 833:../Dave/Generated/FREERTOS/queue.c **** 					else
 834:../Dave/Generated/FREERTOS/queue.c **** 					{
 835:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
 836:../Dave/Generated/FREERTOS/queue.c **** 					}
 837:../Dave/Generated/FREERTOS/queue.c **** 				}
 838:../Dave/Generated/FREERTOS/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
 839:../Dave/Generated/FREERTOS/queue.c **** 
 840:../Dave/Generated/FREERTOS/queue.c **** 				taskEXIT_CRITICAL();
 1105              	 .loc 1 840 0
 1106 0140 FFF7FEFF 	 bl vPortExitCritical
 841:../Dave/Generated/FREERTOS/queue.c **** 				return pdPASS;
 1107              	 .loc 1 841 0
 1108 0144 0123     	 movs r3,#1
 1109 0146 67E0     	 b .L86
 1110              	.L72:
 842:../Dave/Generated/FREERTOS/queue.c **** 			}
 843:../Dave/Generated/FREERTOS/queue.c **** 			else
 844:../Dave/Generated/FREERTOS/queue.c **** 			{
 845:../Dave/Generated/FREERTOS/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 1111              	 .loc 1 845 0
 1112 0148 7B68     	 ldr r3,[r7,#4]
 1113 014a 002B     	 cmp r3,#0
 1114 014c 03D1     	 bne .L77
 846:../Dave/Generated/FREERTOS/queue.c **** 				{
 847:../Dave/Generated/FREERTOS/queue.c **** 					/* The queue was full and no block time is specified (or
 848:../Dave/Generated/FREERTOS/queue.c **** 					the block time has expired) so leave now. */
 849:../Dave/Generated/FREERTOS/queue.c **** 					taskEXIT_CRITICAL();
 1115              	 .loc 1 849 0
 1116 014e FFF7FEFF 	 bl vPortExitCritical
 850:../Dave/Generated/FREERTOS/queue.c **** 
 851:../Dave/Generated/FREERTOS/queue.c **** 					/* Return to the original privilege level before exiting
 852:../Dave/Generated/FREERTOS/queue.c **** 					the function. */
 853:../Dave/Generated/FREERTOS/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 854:../Dave/Generated/FREERTOS/queue.c **** 					return errQUEUE_FULL;
 1117              	 .loc 1 854 0
 1118 0152 0023     	 movs r3,#0
 1119 0154 60E0     	 b .L86
 1120              	.L77:
 855:../Dave/Generated/FREERTOS/queue.c **** 				}
 856:../Dave/Generated/FREERTOS/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 1121              	 .loc 1 856 0
 1122 0156 7B6B     	 ldr r3,[r7,#52]
 1123 0158 002B     	 cmp r3,#0
 1124 015a 06D1     	 bne .L78
 857:../Dave/Generated/FREERTOS/queue.c **** 				{
 858:../Dave/Generated/FREERTOS/queue.c **** 					/* The queue was full and a block time was specified so
 859:../Dave/Generated/FREERTOS/queue.c **** 					configure the timeout structure. */
 860:../Dave/Generated/FREERTOS/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
 1125              	 .loc 1 860 0
 1126 015c 07F11403 	 add r3,r7,#20
 1127 0160 1846     	 mov r0,r3
 1128 0162 FFF7FEFF 	 bl vTaskInternalSetTimeOutState
 861:../Dave/Generated/FREERTOS/queue.c **** 					xEntryTimeSet = pdTRUE;
 1129              	 .loc 1 861 0
 1130 0166 0123     	 movs r3,#1
 1131 0168 7B63     	 str r3,[r7,#52]
 1132              	.L78:
 862:../Dave/Generated/FREERTOS/queue.c **** 				}
 863:../Dave/Generated/FREERTOS/queue.c **** 				else
 864:../Dave/Generated/FREERTOS/queue.c **** 				{
 865:../Dave/Generated/FREERTOS/queue.c **** 					/* Entry time was already set. */
 866:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 867:../Dave/Generated/FREERTOS/queue.c **** 				}
 868:../Dave/Generated/FREERTOS/queue.c **** 			}
 869:../Dave/Generated/FREERTOS/queue.c **** 		}
 870:../Dave/Generated/FREERTOS/queue.c **** 		taskEXIT_CRITICAL();
 1133              	 .loc 1 870 0
 1134 016a FFF7FEFF 	 bl vPortExitCritical
 871:../Dave/Generated/FREERTOS/queue.c **** 
 872:../Dave/Generated/FREERTOS/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 873:../Dave/Generated/FREERTOS/queue.c **** 		now the critical section has been exited. */
 874:../Dave/Generated/FREERTOS/queue.c **** 
 875:../Dave/Generated/FREERTOS/queue.c **** 		vTaskSuspendAll();
 1135              	 .loc 1 875 0
 1136 016e FFF7FEFF 	 bl vTaskSuspendAll
 876:../Dave/Generated/FREERTOS/queue.c **** 		prvLockQueue( pxQueue );
 1137              	 .loc 1 876 0
 1138 0172 FFF7FEFF 	 bl vPortEnterCritical
 1139 0176 3B6B     	 ldr r3,[r7,#48]
 1140 0178 93F84430 	 ldrb r3,[r3,#68]
 1141 017c DBB2     	 uxtb r3,r3
 1142 017e 5BB2     	 sxtb r3,r3
 1143 0180 B3F1FF3F 	 cmp r3,#-1
 1144 0184 03D1     	 bne .L79
 1145              	 .loc 1 876 0 is_stmt 0 discriminator 1
 1146 0186 3B6B     	 ldr r3,[r7,#48]
 1147 0188 0022     	 movs r2,#0
 1148 018a 83F84420 	 strb r2,[r3,#68]
 1149              	.L79:
 1150              	 .loc 1 876 0 discriminator 3
 1151 018e 3B6B     	 ldr r3,[r7,#48]
 1152 0190 93F84530 	 ldrb r3,[r3,#69]
 1153 0194 DBB2     	 uxtb r3,r3
 1154 0196 5BB2     	 sxtb r3,r3
 1155 0198 B3F1FF3F 	 cmp r3,#-1
 1156 019c 03D1     	 bne .L80
 1157              	 .loc 1 876 0 discriminator 4
 1158 019e 3B6B     	 ldr r3,[r7,#48]
 1159 01a0 0022     	 movs r2,#0
 1160 01a2 83F84520 	 strb r2,[r3,#69]
 1161              	.L80:
 1162              	 .loc 1 876 0 discriminator 6
 1163 01a6 FFF7FEFF 	 bl vPortExitCritical
 877:../Dave/Generated/FREERTOS/queue.c **** 
 878:../Dave/Generated/FREERTOS/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 879:../Dave/Generated/FREERTOS/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1164              	 .loc 1 879 0 is_stmt 1 discriminator 6
 1165 01aa 07F11402 	 add r2,r7,#20
 1166 01ae 3B1D     	 adds r3,r7,#4
 1167 01b0 1046     	 mov r0,r2
 1168 01b2 1946     	 mov r1,r3
 1169 01b4 FFF7FEFF 	 bl xTaskCheckForTimeOut
 1170 01b8 0346     	 mov r3,r0
 1171 01ba 002B     	 cmp r3,#0
 1172 01bc 24D1     	 bne .L81
 880:../Dave/Generated/FREERTOS/queue.c **** 		{
 881:../Dave/Generated/FREERTOS/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 1173              	 .loc 1 881 0
 1174 01be 386B     	 ldr r0,[r7,#48]
 1175 01c0 FFF7FEFF 	 bl prvIsQueueFull
 1176 01c4 0346     	 mov r3,r0
 1177 01c6 002B     	 cmp r3,#0
 1178 01c8 18D0     	 beq .L82
 882:../Dave/Generated/FREERTOS/queue.c **** 			{
 883:../Dave/Generated/FREERTOS/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 884:../Dave/Generated/FREERTOS/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 1179              	 .loc 1 884 0
 1180 01ca 3B6B     	 ldr r3,[r7,#48]
 1181 01cc 03F11002 	 add r2,r3,#16
 1182 01d0 7B68     	 ldr r3,[r7,#4]
 1183 01d2 1046     	 mov r0,r2
 1184 01d4 1946     	 mov r1,r3
 1185 01d6 FFF7FEFF 	 bl vTaskPlaceOnEventList
 885:../Dave/Generated/FREERTOS/queue.c **** 
 886:../Dave/Generated/FREERTOS/queue.c **** 				/* Unlocking the queue means queue events can effect the
 887:../Dave/Generated/FREERTOS/queue.c **** 				event list.  It is possible that interrupts occurring now
 888:../Dave/Generated/FREERTOS/queue.c **** 				remove this task from the event list again - but as the
 889:../Dave/Generated/FREERTOS/queue.c **** 				scheduler is suspended the task will go onto the pending
 890:../Dave/Generated/FREERTOS/queue.c **** 				ready last instead of the actual ready list. */
 891:../Dave/Generated/FREERTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 1186              	 .loc 1 891 0
 1187 01da 386B     	 ldr r0,[r7,#48]
 1188 01dc FFF7FEFF 	 bl prvUnlockQueue
 892:../Dave/Generated/FREERTOS/queue.c **** 
 893:../Dave/Generated/FREERTOS/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 894:../Dave/Generated/FREERTOS/queue.c **** 				ready list into the ready list - so it is feasible that this
 895:../Dave/Generated/FREERTOS/queue.c **** 				task is already in a ready list before it yields - in which
 896:../Dave/Generated/FREERTOS/queue.c **** 				case the yield will not cause a context switch unless there
 897:../Dave/Generated/FREERTOS/queue.c **** 				is also a higher priority task in the pending ready list. */
 898:../Dave/Generated/FREERTOS/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1189              	 .loc 1 898 0
 1190 01e0 FFF7FEFF 	 bl xTaskResumeAll
 1191 01e4 0346     	 mov r3,r0
 1192 01e6 002B     	 cmp r3,#0
 1193 01e8 15D1     	 bne .L85
 899:../Dave/Generated/FREERTOS/queue.c **** 				{
 900:../Dave/Generated/FREERTOS/queue.c **** 					portYIELD_WITHIN_API();
 1194              	 .loc 1 900 0
 1195 01ea 0D4B     	 ldr r3,.L87
 1196 01ec 4FF08052 	 mov r2,#268435456
 1197 01f0 1A60     	 str r2,[r3]
 1198              	
 1199 01f2 BFF34F8F 	 dsb
 1200              	
 1201              	
 1202 01f6 BFF36F8F 	 isb
 1203              	
 1204              	 .thumb
 1205 01fa 0CE0     	 b .L85
 1206              	.L82:
 901:../Dave/Generated/FREERTOS/queue.c **** 				}
 902:../Dave/Generated/FREERTOS/queue.c **** 			}
 903:../Dave/Generated/FREERTOS/queue.c **** 			else
 904:../Dave/Generated/FREERTOS/queue.c **** 			{
 905:../Dave/Generated/FREERTOS/queue.c **** 				/* Try again. */
 906:../Dave/Generated/FREERTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 1207              	 .loc 1 906 0
 1208 01fc 386B     	 ldr r0,[r7,#48]
 1209 01fe FFF7FEFF 	 bl prvUnlockQueue
 907:../Dave/Generated/FREERTOS/queue.c **** 				( void ) xTaskResumeAll();
 1210              	 .loc 1 907 0
 1211 0202 FFF7FEFF 	 bl xTaskResumeAll
 1212 0206 56E7     	 b .L69
 1213              	.L81:
 908:../Dave/Generated/FREERTOS/queue.c **** 			}
 909:../Dave/Generated/FREERTOS/queue.c **** 		}
 910:../Dave/Generated/FREERTOS/queue.c **** 		else
 911:../Dave/Generated/FREERTOS/queue.c **** 		{
 912:../Dave/Generated/FREERTOS/queue.c **** 			/* The timeout has expired. */
 913:../Dave/Generated/FREERTOS/queue.c **** 			prvUnlockQueue( pxQueue );
 1214              	 .loc 1 913 0
 1215 0208 386B     	 ldr r0,[r7,#48]
 1216 020a FFF7FEFF 	 bl prvUnlockQueue
 914:../Dave/Generated/FREERTOS/queue.c **** 			( void ) xTaskResumeAll();
 1217              	 .loc 1 914 0
 1218 020e FFF7FEFF 	 bl xTaskResumeAll
 915:../Dave/Generated/FREERTOS/queue.c **** 
 916:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 917:../Dave/Generated/FREERTOS/queue.c **** 			return errQUEUE_FULL;
 1219              	 .loc 1 917 0
 1220 0212 0023     	 movs r3,#0
 1221 0214 00E0     	 b .L86
 1222              	.L85:
 918:../Dave/Generated/FREERTOS/queue.c **** 		}
 919:../Dave/Generated/FREERTOS/queue.c **** 	}
 1223              	 .loc 1 919 0 discriminator 6
 1224 0216 4EE7     	 b .L69
 1225              	.L86:
 920:../Dave/Generated/FREERTOS/queue.c **** }
 1226              	 .loc 1 920 0 discriminator 7
 1227 0218 1846     	 mov r0,r3
 1228 021a 3837     	 adds r7,r7,#56
 1229              	 .cfi_def_cfa_offset 8
 1230 021c BD46     	 mov sp,r7
 1231              	 .cfi_def_cfa_register 13
 1232              	 
 1233 021e 80BD     	 pop {r7,pc}
 1234              	.L88:
 1235              	 .align 2
 1236              	.L87:
 1237 0220 04ED00E0 	 .word -536810236
 1238              	 .cfi_endproc
 1239              	.LFE147:
 1241              	 .section .text.xQueueGenericSendFromISR,"ax",%progbits
 1242              	 .align 2
 1243              	 .global xQueueGenericSendFromISR
 1244              	 .thumb
 1245              	 .thumb_func
 1247              	xQueueGenericSendFromISR:
 1248              	.LFB148:
 921:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 922:../Dave/Generated/FREERTOS/queue.c **** 
 923:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseTy
 924:../Dave/Generated/FREERTOS/queue.c **** {
 1249              	 .loc 1 924 0
 1250              	 .cfi_startproc
 1251              	 
 1252              	 
 1253 0000 80B5     	 push {r7,lr}
 1254              	 .cfi_def_cfa_offset 8
 1255              	 .cfi_offset 7,-8
 1256              	 .cfi_offset 14,-4
 1257 0002 8EB0     	 sub sp,sp,#56
 1258              	 .cfi_def_cfa_offset 64
 1259 0004 00AF     	 add r7,sp,#0
 1260              	 .cfi_def_cfa_register 7
 1261 0006 F860     	 str r0,[r7,#12]
 1262 0008 B960     	 str r1,[r7,#8]
 1263 000a 7A60     	 str r2,[r7,#4]
 1264 000c 3B60     	 str r3,[r7]
 925:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xReturn;
 926:../Dave/Generated/FREERTOS/queue.c **** UBaseType_t uxSavedInterruptStatus;
 927:../Dave/Generated/FREERTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1265              	 .loc 1 927 0
 1266 000e FB68     	 ldr r3,[r7,#12]
 1267 0010 3B63     	 str r3,[r7,#48]
 928:../Dave/Generated/FREERTOS/queue.c **** 
 929:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue );
 1268              	 .loc 1 929 0
 1269 0012 3B6B     	 ldr r3,[r7,#48]
 1270 0014 002B     	 cmp r3,#0
 1271 0016 09D1     	 bne .L90
 1272              	.LBB130:
 1273              	.LBB131:
 1274              	 .loc 2 195 0 discriminator 1
 1275              	
 1276 0018 4FF0FC03 	 mov r3,#252
 1277 001c 83F31188 	 msr basepri,r3
 1278 0020 BFF36F8F 	 isb 
 1279 0024 BFF34F8F 	 dsb 
 1280              	
 1281              	
 1282              	 .thumb
 1283 0028 7B62     	 str r3,[r7,#36]
 1284              	.L91:
 1285              	.LBE131:
 1286              	.LBE130:
 1287              	 .loc 1 929 0 discriminator 1
 1288 002a FEE7     	 b .L91
 1289              	.L90:
 930:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 1290              	 .loc 1 930 0
 1291 002c BB68     	 ldr r3,[r7,#8]
 1292 002e 002B     	 cmp r3,#0
 1293 0030 03D1     	 bne .L92
 1294              	 .loc 1 930 0 is_stmt 0 discriminator 2
 1295 0032 3B6B     	 ldr r3,[r7,#48]
 1296 0034 1B6C     	 ldr r3,[r3,#64]
 1297 0036 002B     	 cmp r3,#0
 1298 0038 01D1     	 bne .L93
 1299              	.L92:
 1300              	 .loc 1 930 0 discriminator 3
 1301 003a 0123     	 movs r3,#1
 1302 003c 00E0     	 b .L94
 1303              	.L93:
 1304              	 .loc 1 930 0 discriminator 4
 1305 003e 0023     	 movs r3,#0
 1306              	.L94:
 1307              	 .loc 1 930 0 discriminator 6
 1308 0040 002B     	 cmp r3,#0
 1309 0042 09D1     	 bne .L95
 1310              	.LBB132:
 1311              	.LBB133:
 1312              	 .loc 2 195 0 is_stmt 1 discriminator 7
 1313              	
 1314 0044 4FF0FC03 	 mov r3,#252
 1315 0048 83F31188 	 msr basepri,r3
 1316 004c BFF36F8F 	 isb 
 1317 0050 BFF34F8F 	 dsb 
 1318              	
 1319              	
 1320              	 .thumb
 1321 0054 3B62     	 str r3,[r7,#32]
 1322              	.L96:
 1323              	.LBE133:
 1324              	.LBE132:
 1325              	 .loc 1 930 0 discriminator 2
 1326 0056 FEE7     	 b .L96
 1327              	.L95:
 931:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1328              	 .loc 1 931 0
 1329 0058 3B68     	 ldr r3,[r7]
 1330 005a 022B     	 cmp r3,#2
 1331 005c 03D1     	 bne .L97
 1332              	 .loc 1 931 0 is_stmt 0 discriminator 2
 1333 005e 3B6B     	 ldr r3,[r7,#48]
 1334 0060 DB6B     	 ldr r3,[r3,#60]
 1335 0062 012B     	 cmp r3,#1
 1336 0064 01D1     	 bne .L98
 1337              	.L97:
 1338              	 .loc 1 931 0 discriminator 3
 1339 0066 0123     	 movs r3,#1
 1340 0068 00E0     	 b .L99
 1341              	.L98:
 1342              	 .loc 1 931 0 discriminator 4
 1343 006a 0023     	 movs r3,#0
 1344              	.L99:
 1345              	 .loc 1 931 0 discriminator 6
 1346 006c 002B     	 cmp r3,#0
 1347 006e 09D1     	 bne .L100
 1348              	.LBB134:
 1349              	.LBB135:
 1350              	 .loc 2 195 0 is_stmt 1 discriminator 7
 1351              	
 1352 0070 4FF0FC03 	 mov r3,#252
 1353 0074 83F31188 	 msr basepri,r3
 1354 0078 BFF36F8F 	 isb 
 1355 007c BFF34F8F 	 dsb 
 1356              	
 1357              	
 1358              	 .thumb
 1359 0080 FB61     	 str r3,[r7,#28]
 1360              	.L101:
 1361              	.LBE135:
 1362              	.LBE134:
 1363              	 .loc 1 931 0 discriminator 3
 1364 0082 FEE7     	 b .L101
 1365              	.L100:
 932:../Dave/Generated/FREERTOS/queue.c **** 
 933:../Dave/Generated/FREERTOS/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
 934:../Dave/Generated/FREERTOS/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
 935:../Dave/Generated/FREERTOS/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
 936:../Dave/Generated/FREERTOS/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
 937:../Dave/Generated/FREERTOS/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
 938:../Dave/Generated/FREERTOS/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
 939:../Dave/Generated/FREERTOS/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
 940:../Dave/Generated/FREERTOS/queue.c **** 	assigned a priority above the configured maximum system call priority.
 941:../Dave/Generated/FREERTOS/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
 942:../Dave/Generated/FREERTOS/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
 943:../Dave/Generated/FREERTOS/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
 944:../Dave/Generated/FREERTOS/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
 945:../Dave/Generated/FREERTOS/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
 946:../Dave/Generated/FREERTOS/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
 947:../Dave/Generated/FREERTOS/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 1366              	 .loc 1 947 0
 1367 0084 FFF7FEFF 	 bl vPortValidateInterruptPriority
 1368              	.LBB136:
 1369              	.LBB137:
 196:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 197:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		"	mov %0, %1												\n"	\
 198:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		"	msr basepri, %0											\n" \
 199:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		"	isb														\n" \
 200:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		"	dsb														\n" \
 201:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		:"=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
 202:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	);
 203:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** }
 204:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 205:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*-----------------------------------------------------------*/
 206:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 207:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
 208:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** {
 209:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** uint32_t ulOriginalBASEPRI, ulNewBASEPRI;
 210:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 211:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	__asm volatile
 1370              	 .loc 2 211 0
 1371              	
 1372 0088 EFF31182 	 mrs r2,basepri
 1373 008c 4FF0FC03 	 mov r3,#252
 1374 0090 83F31188 	 msr basepri,r3
 1375 0094 BFF36F8F 	 isb 
 1376 0098 BFF34F8F 	 dsb 
 1377              	
 1378              	
 1379              	 .thumb
 1380 009c BA61     	 str r2,[r7,#24]
 1381 009e 7B61     	 str r3,[r7,#20]
 212:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 213:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		"	mrs %0, basepri											\n" \
 214:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		"	mov %1, %2												\n"	\
 215:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		"	msr basepri, %1											\n" \
 216:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		"	isb														\n" \
 217:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		"	dsb														\n" \
 218:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "
 219:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	);
 220:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 221:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	/* This return will not be reached but is necessary to prevent compiler
 222:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	warnings. */
 223:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	return ulOriginalBASEPRI;
 1382              	 .loc 2 223 0
 1383 00a0 BB69     	 ldr r3,[r7,#24]
 1384              	.LBE137:
 1385              	.LBE136:
 948:../Dave/Generated/FREERTOS/queue.c **** 
 949:../Dave/Generated/FREERTOS/queue.c **** 	/* Similar to xQueueGenericSend, except without blocking if there is no room
 950:../Dave/Generated/FREERTOS/queue.c **** 	in the queue.  Also don't directly wake a task that was blocked on a queue
 951:../Dave/Generated/FREERTOS/queue.c **** 	read, instead return a flag to say whether a context switch is required or
 952:../Dave/Generated/FREERTOS/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
 953:../Dave/Generated/FREERTOS/queue.c **** 	post). */
 954:../Dave/Generated/FREERTOS/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1386              	 .loc 1 954 0
 1387 00a2 FB62     	 str r3,[r7,#44]
 955:../Dave/Generated/FREERTOS/queue.c **** 	{
 956:../Dave/Generated/FREERTOS/queue.c **** 		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 1388              	 .loc 1 956 0
 1389 00a4 3B6B     	 ldr r3,[r7,#48]
 1390 00a6 9A6B     	 ldr r2,[r3,#56]
 1391 00a8 3B6B     	 ldr r3,[r7,#48]
 1392 00aa DB6B     	 ldr r3,[r3,#60]
 1393 00ac 9A42     	 cmp r2,r3
 1394 00ae 02D3     	 bcc .L103
 1395              	 .loc 1 956 0 is_stmt 0 discriminator 1
 1396 00b0 3B68     	 ldr r3,[r7]
 1397 00b2 022B     	 cmp r3,#2
 1398 00b4 3ED1     	 bne .L104
 1399              	.L103:
 1400              	.LBB138:
 957:../Dave/Generated/FREERTOS/queue.c **** 		{
 958:../Dave/Generated/FREERTOS/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 1401              	 .loc 1 958 0 is_stmt 1
 1402 00b6 3B6B     	 ldr r3,[r7,#48]
 1403 00b8 93F84530 	 ldrb r3,[r3,#69]
 1404 00bc 87F82B30 	 strb r3,[r7,#43]
 959:../Dave/Generated/FREERTOS/queue.c **** 
 960:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
 961:../Dave/Generated/FREERTOS/queue.c **** 
 962:../Dave/Generated/FREERTOS/queue.c **** 			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
 963:../Dave/Generated/FREERTOS/queue.c **** 			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
 964:../Dave/Generated/FREERTOS/queue.c **** 			in a task disinheriting a priority and prvCopyDataToQueue() can be
 965:../Dave/Generated/FREERTOS/queue.c **** 			called here even though the disinherit function does not check if
 966:../Dave/Generated/FREERTOS/queue.c **** 			the scheduler is suspended before accessing the ready lists. */
 967:../Dave/Generated/FREERTOS/queue.c **** 			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 1405              	 .loc 1 967 0
 1406 00c0 386B     	 ldr r0,[r7,#48]
 1407 00c2 B968     	 ldr r1,[r7,#8]
 1408 00c4 3A68     	 ldr r2,[r7]
 1409 00c6 FFF7FEFF 	 bl prvCopyDataToQueue
 968:../Dave/Generated/FREERTOS/queue.c **** 
 969:../Dave/Generated/FREERTOS/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
 970:../Dave/Generated/FREERTOS/queue.c **** 			be done when the queue is unlocked later. */
 971:../Dave/Generated/FREERTOS/queue.c **** 			if( cTxLock == queueUNLOCKED )
 1410              	 .loc 1 971 0
 1411 00ca 97F92B30 	 ldrsb r3,[r7,#43]
 1412 00ce B3F1FF3F 	 cmp r3,#-1
 1413 00d2 24D1     	 bne .L105
 972:../Dave/Generated/FREERTOS/queue.c **** 			{
 973:../Dave/Generated/FREERTOS/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 974:../Dave/Generated/FREERTOS/queue.c **** 				{
 975:../Dave/Generated/FREERTOS/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 1414              	 .loc 1 975 0
 1415 00d4 3B6B     	 ldr r3,[r7,#48]
 1416 00d6 9B6C     	 ldr r3,[r3,#72]
 1417 00d8 002B     	 cmp r3,#0
 1418 00da 0DD0     	 beq .L106
 976:../Dave/Generated/FREERTOS/queue.c **** 					{
 977:../Dave/Generated/FREERTOS/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
 1419              	 .loc 1 977 0
 1420 00dc 386B     	 ldr r0,[r7,#48]
 1421 00de 3968     	 ldr r1,[r7]
 1422 00e0 FFF7FEFF 	 bl prvNotifyQueueSetContainer
 1423 00e4 0346     	 mov r3,r0
 1424 00e6 002B     	 cmp r3,#0
 1425 00e8 21D0     	 beq .L107
 978:../Dave/Generated/FREERTOS/queue.c **** 						{
 979:../Dave/Generated/FREERTOS/queue.c **** 							/* The queue is a member of a queue set, and posting
 980:../Dave/Generated/FREERTOS/queue.c **** 							to the queue set caused a higher priority task to
 981:../Dave/Generated/FREERTOS/queue.c **** 							unblock.  A context switch is required. */
 982:../Dave/Generated/FREERTOS/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 1426              	 .loc 1 982 0
 1427 00ea 7B68     	 ldr r3,[r7,#4]
 1428 00ec 002B     	 cmp r3,#0
 1429 00ee 1ED0     	 beq .L107
 983:../Dave/Generated/FREERTOS/queue.c **** 							{
 984:../Dave/Generated/FREERTOS/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 1430              	 .loc 1 984 0
 1431 00f0 7B68     	 ldr r3,[r7,#4]
 1432 00f2 0122     	 movs r2,#1
 1433 00f4 1A60     	 str r2,[r3]
 1434 00f6 1AE0     	 b .L107
 1435              	.L106:
 985:../Dave/Generated/FREERTOS/queue.c **** 							}
 986:../Dave/Generated/FREERTOS/queue.c **** 							else
 987:../Dave/Generated/FREERTOS/queue.c **** 							{
 988:../Dave/Generated/FREERTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 989:../Dave/Generated/FREERTOS/queue.c **** 							}
 990:../Dave/Generated/FREERTOS/queue.c **** 						}
 991:../Dave/Generated/FREERTOS/queue.c **** 						else
 992:../Dave/Generated/FREERTOS/queue.c **** 						{
 993:../Dave/Generated/FREERTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 994:../Dave/Generated/FREERTOS/queue.c **** 						}
 995:../Dave/Generated/FREERTOS/queue.c **** 					}
 996:../Dave/Generated/FREERTOS/queue.c **** 					else
 997:../Dave/Generated/FREERTOS/queue.c **** 					{
 998:../Dave/Generated/FREERTOS/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1436              	 .loc 1 998 0
 1437 00f8 3B6B     	 ldr r3,[r7,#48]
 1438 00fa 5B6A     	 ldr r3,[r3,#36]
 1439 00fc 002B     	 cmp r3,#0
 1440 00fe 16D0     	 beq .L107
 999:../Dave/Generated/FREERTOS/queue.c **** 						{
1000:../Dave/Generated/FREERTOS/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1441              	 .loc 1 1000 0
 1442 0100 3B6B     	 ldr r3,[r7,#48]
 1443 0102 2433     	 adds r3,r3,#36
 1444 0104 1846     	 mov r0,r3
 1445 0106 FFF7FEFF 	 bl xTaskRemoveFromEventList
 1446 010a 0346     	 mov r3,r0
 1447 010c 002B     	 cmp r3,#0
 1448 010e 0ED0     	 beq .L107
1001:../Dave/Generated/FREERTOS/queue.c **** 							{
1002:../Dave/Generated/FREERTOS/queue.c **** 								/* The task waiting has a higher priority so
1003:../Dave/Generated/FREERTOS/queue.c **** 								record that a context switch is required. */
1004:../Dave/Generated/FREERTOS/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
 1449              	 .loc 1 1004 0
 1450 0110 7B68     	 ldr r3,[r7,#4]
 1451 0112 002B     	 cmp r3,#0
 1452 0114 0BD0     	 beq .L107
1005:../Dave/Generated/FREERTOS/queue.c **** 								{
1006:../Dave/Generated/FREERTOS/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
 1453              	 .loc 1 1006 0
 1454 0116 7B68     	 ldr r3,[r7,#4]
 1455 0118 0122     	 movs r2,#1
 1456 011a 1A60     	 str r2,[r3]
 1457 011c 07E0     	 b .L107
 1458              	.L105:
1007:../Dave/Generated/FREERTOS/queue.c **** 								}
1008:../Dave/Generated/FREERTOS/queue.c **** 								else
1009:../Dave/Generated/FREERTOS/queue.c **** 								{
1010:../Dave/Generated/FREERTOS/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1011:../Dave/Generated/FREERTOS/queue.c **** 								}
1012:../Dave/Generated/FREERTOS/queue.c **** 							}
1013:../Dave/Generated/FREERTOS/queue.c **** 							else
1014:../Dave/Generated/FREERTOS/queue.c **** 							{
1015:../Dave/Generated/FREERTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1016:../Dave/Generated/FREERTOS/queue.c **** 							}
1017:../Dave/Generated/FREERTOS/queue.c **** 						}
1018:../Dave/Generated/FREERTOS/queue.c **** 						else
1019:../Dave/Generated/FREERTOS/queue.c **** 						{
1020:../Dave/Generated/FREERTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1021:../Dave/Generated/FREERTOS/queue.c **** 						}
1022:../Dave/Generated/FREERTOS/queue.c **** 					}
1023:../Dave/Generated/FREERTOS/queue.c **** 				}
1024:../Dave/Generated/FREERTOS/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1025:../Dave/Generated/FREERTOS/queue.c **** 				{
1026:../Dave/Generated/FREERTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1027:../Dave/Generated/FREERTOS/queue.c **** 					{
1028:../Dave/Generated/FREERTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1029:../Dave/Generated/FREERTOS/queue.c **** 						{
1030:../Dave/Generated/FREERTOS/queue.c **** 							/* The task waiting has a higher priority so record that a
1031:../Dave/Generated/FREERTOS/queue.c **** 							context	switch is required. */
1032:../Dave/Generated/FREERTOS/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1033:../Dave/Generated/FREERTOS/queue.c **** 							{
1034:../Dave/Generated/FREERTOS/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1035:../Dave/Generated/FREERTOS/queue.c **** 							}
1036:../Dave/Generated/FREERTOS/queue.c **** 							else
1037:../Dave/Generated/FREERTOS/queue.c **** 							{
1038:../Dave/Generated/FREERTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1039:../Dave/Generated/FREERTOS/queue.c **** 							}
1040:../Dave/Generated/FREERTOS/queue.c **** 						}
1041:../Dave/Generated/FREERTOS/queue.c **** 						else
1042:../Dave/Generated/FREERTOS/queue.c **** 						{
1043:../Dave/Generated/FREERTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1044:../Dave/Generated/FREERTOS/queue.c **** 						}
1045:../Dave/Generated/FREERTOS/queue.c **** 					}
1046:../Dave/Generated/FREERTOS/queue.c **** 					else
1047:../Dave/Generated/FREERTOS/queue.c **** 					{
1048:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1049:../Dave/Generated/FREERTOS/queue.c **** 					}
1050:../Dave/Generated/FREERTOS/queue.c **** 				}
1051:../Dave/Generated/FREERTOS/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1052:../Dave/Generated/FREERTOS/queue.c **** 			}
1053:../Dave/Generated/FREERTOS/queue.c **** 			else
1054:../Dave/Generated/FREERTOS/queue.c **** 			{
1055:../Dave/Generated/FREERTOS/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1056:../Dave/Generated/FREERTOS/queue.c **** 				knows that data was posted while it was locked. */
1057:../Dave/Generated/FREERTOS/queue.c **** 				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 1459              	 .loc 1 1057 0
 1460 011e 97F82B30 	 ldrb r3,[r7,#43]
 1461 0122 0133     	 adds r3,r3,#1
 1462 0124 DBB2     	 uxtb r3,r3
 1463 0126 DAB2     	 uxtb r2,r3
 1464 0128 3B6B     	 ldr r3,[r7,#48]
 1465 012a 83F84520 	 strb r2,[r3,#69]
 1466              	.L107:
1058:../Dave/Generated/FREERTOS/queue.c **** 			}
1059:../Dave/Generated/FREERTOS/queue.c **** 
1060:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdPASS;
 1467              	 .loc 1 1060 0
 1468 012e 0123     	 movs r3,#1
 1469 0130 7B63     	 str r3,[r7,#52]
 1470              	.LBE138:
 957:../Dave/Generated/FREERTOS/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 1471              	 .loc 1 957 0
 1472 0132 01E0     	 b .L108
 1473              	.L104:
1061:../Dave/Generated/FREERTOS/queue.c **** 		}
1062:../Dave/Generated/FREERTOS/queue.c **** 		else
1063:../Dave/Generated/FREERTOS/queue.c **** 		{
1064:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1065:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = errQUEUE_FULL;
 1474              	 .loc 1 1065 0
 1475 0134 0023     	 movs r3,#0
 1476 0136 7B63     	 str r3,[r7,#52]
 1477              	.L108:
 1478 0138 FB6A     	 ldr r3,[r7,#44]
 1479 013a 3B61     	 str r3,[r7,#16]
 1480              	.LBB139:
 1481              	.LBB140:
 224:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** }
 225:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*-----------------------------------------------------------*/
 226:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 227:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
 228:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** {
 229:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	__asm volatile
 1482              	 .loc 2 229 0
 1483 013c 3B69     	 ldr r3,[r7,#16]
 1484              	
 1485 013e 83F31188 	 msr basepri,r3
 1486              	
 1487              	 .thumb
 1488              	.LBE140:
 1489              	.LBE139:
1066:../Dave/Generated/FREERTOS/queue.c **** 		}
1067:../Dave/Generated/FREERTOS/queue.c **** 	}
1068:../Dave/Generated/FREERTOS/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1069:../Dave/Generated/FREERTOS/queue.c **** 
1070:../Dave/Generated/FREERTOS/queue.c **** 	return xReturn;
 1490              	 .loc 1 1070 0
 1491 0142 7B6B     	 ldr r3,[r7,#52]
1071:../Dave/Generated/FREERTOS/queue.c **** }
 1492              	 .loc 1 1071 0
 1493 0144 1846     	 mov r0,r3
 1494 0146 3837     	 adds r7,r7,#56
 1495              	 .cfi_def_cfa_offset 8
 1496 0148 BD46     	 mov sp,r7
 1497              	 .cfi_def_cfa_register 13
 1498              	 
 1499 014a 80BD     	 pop {r7,pc}
 1500              	 .cfi_endproc
 1501              	.LFE148:
 1503              	 .section .text.xQueueGiveFromISR,"ax",%progbits
 1504              	 .align 2
 1505              	 .global xQueueGiveFromISR
 1506              	 .thumb
 1507              	 .thumb_func
 1509              	xQueueGiveFromISR:
 1510              	.LFB149:
1072:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
1073:../Dave/Generated/FREERTOS/queue.c **** 
1074:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
1075:../Dave/Generated/FREERTOS/queue.c **** {
 1511              	 .loc 1 1075 0
 1512              	 .cfi_startproc
 1513              	 
 1514              	 
 1515 0000 80B5     	 push {r7,lr}
 1516              	 .cfi_def_cfa_offset 8
 1517              	 .cfi_offset 7,-8
 1518              	 .cfi_offset 14,-4
 1519 0002 8EB0     	 sub sp,sp,#56
 1520              	 .cfi_def_cfa_offset 64
 1521 0004 00AF     	 add r7,sp,#0
 1522              	 .cfi_def_cfa_register 7
 1523 0006 7860     	 str r0,[r7,#4]
 1524 0008 3960     	 str r1,[r7]
1076:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xReturn;
1077:../Dave/Generated/FREERTOS/queue.c **** UBaseType_t uxSavedInterruptStatus;
1078:../Dave/Generated/FREERTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1525              	 .loc 1 1078 0
 1526 000a 7B68     	 ldr r3,[r7,#4]
 1527 000c 3B63     	 str r3,[r7,#48]
1079:../Dave/Generated/FREERTOS/queue.c **** 
1080:../Dave/Generated/FREERTOS/queue.c **** 	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
1081:../Dave/Generated/FREERTOS/queue.c **** 	item size is 0.  Don't directly wake a task that was blocked on a queue
1082:../Dave/Generated/FREERTOS/queue.c **** 	read, instead return a flag to say whether a context switch is required or
1083:../Dave/Generated/FREERTOS/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
1084:../Dave/Generated/FREERTOS/queue.c **** 	post). */
1085:../Dave/Generated/FREERTOS/queue.c **** 
1086:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue );
 1528              	 .loc 1 1086 0
 1529 000e 3B6B     	 ldr r3,[r7,#48]
 1530 0010 002B     	 cmp r3,#0
 1531 0012 09D1     	 bne .L111
 1532              	.LBB141:
 1533              	.LBB142:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 1534              	 .loc 2 195 0 discriminator 1
 1535              	
 1536 0014 4FF0FC03 	 mov r3,#252
 1537 0018 83F31188 	 msr basepri,r3
 1538 001c BFF36F8F 	 isb 
 1539 0020 BFF34F8F 	 dsb 
 1540              	
 1541              	
 1542              	 .thumb
 1543 0024 3B62     	 str r3,[r7,#32]
 1544              	.L112:
 1545              	.LBE142:
 1546              	.LBE141:
 1547              	 .loc 1 1086 0 discriminator 1
 1548 0026 FEE7     	 b .L112
 1549              	.L111:
1087:../Dave/Generated/FREERTOS/queue.c **** 
1088:../Dave/Generated/FREERTOS/queue.c **** 	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
1089:../Dave/Generated/FREERTOS/queue.c **** 	if the item size is not 0. */
1090:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue->uxItemSize == 0 );
 1550              	 .loc 1 1090 0
 1551 0028 3B6B     	 ldr r3,[r7,#48]
 1552 002a 1B6C     	 ldr r3,[r3,#64]
 1553 002c 002B     	 cmp r3,#0
 1554 002e 09D0     	 beq .L113
 1555              	.LBB143:
 1556              	.LBB144:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 1557              	 .loc 2 195 0 discriminator 1
 1558              	
 1559 0030 4FF0FC03 	 mov r3,#252
 1560 0034 83F31188 	 msr basepri,r3
 1561 0038 BFF36F8F 	 isb 
 1562 003c BFF34F8F 	 dsb 
 1563              	
 1564              	
 1565              	 .thumb
 1566 0040 FB61     	 str r3,[r7,#28]
 1567              	.L114:
 1568              	.LBE144:
 1569              	.LBE143:
 1570              	 .loc 1 1090 0 discriminator 2
 1571 0042 FEE7     	 b .L114
 1572              	.L113:
1091:../Dave/Generated/FREERTOS/queue.c **** 
1092:../Dave/Generated/FREERTOS/queue.c **** 	/* Normally a mutex would not be given from an interrupt, especially if
1093:../Dave/Generated/FREERTOS/queue.c **** 	there is a mutex holder, as priority inheritance makes no sense for an
1094:../Dave/Generated/FREERTOS/queue.c **** 	interrupts, only tasks. */
1095:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NU
 1573              	 .loc 1 1095 0
 1574 0044 3B6B     	 ldr r3,[r7,#48]
 1575 0046 1B68     	 ldr r3,[r3]
 1576 0048 002B     	 cmp r3,#0
 1577 004a 03D1     	 bne .L115
 1578              	 .loc 1 1095 0 is_stmt 0 discriminator 2
 1579 004c 3B6B     	 ldr r3,[r7,#48]
 1580 004e 5B68     	 ldr r3,[r3,#4]
 1581 0050 002B     	 cmp r3,#0
 1582 0052 01D1     	 bne .L116
 1583              	.L115:
 1584              	 .loc 1 1095 0 discriminator 3
 1585 0054 0123     	 movs r3,#1
 1586 0056 00E0     	 b .L117
 1587              	.L116:
 1588              	 .loc 1 1095 0 discriminator 4
 1589 0058 0023     	 movs r3,#0
 1590              	.L117:
 1591              	 .loc 1 1095 0 discriminator 6
 1592 005a 002B     	 cmp r3,#0
 1593 005c 09D1     	 bne .L118
 1594              	.LBB145:
 1595              	.LBB146:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 1596              	 .loc 2 195 0 is_stmt 1 discriminator 7
 1597              	
 1598 005e 4FF0FC03 	 mov r3,#252
 1599 0062 83F31188 	 msr basepri,r3
 1600 0066 BFF36F8F 	 isb 
 1601 006a BFF34F8F 	 dsb 
 1602              	
 1603              	
 1604              	 .thumb
 1605 006e BB61     	 str r3,[r7,#24]
 1606              	.L119:
 1607              	.LBE146:
 1608              	.LBE145:
 1609              	 .loc 1 1095 0 discriminator 3
 1610 0070 FEE7     	 b .L119
 1611              	.L118:
1096:../Dave/Generated/FREERTOS/queue.c **** 
1097:../Dave/Generated/FREERTOS/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1098:../Dave/Generated/FREERTOS/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1099:../Dave/Generated/FREERTOS/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1100:../Dave/Generated/FREERTOS/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1101:../Dave/Generated/FREERTOS/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1102:../Dave/Generated/FREERTOS/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1103:../Dave/Generated/FREERTOS/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1104:../Dave/Generated/FREERTOS/queue.c **** 	assigned a priority above the configured maximum system call priority.
1105:../Dave/Generated/FREERTOS/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1106:../Dave/Generated/FREERTOS/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1107:../Dave/Generated/FREERTOS/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1108:../Dave/Generated/FREERTOS/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1109:../Dave/Generated/FREERTOS/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1110:../Dave/Generated/FREERTOS/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1111:../Dave/Generated/FREERTOS/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 1612              	 .loc 1 1111 0
 1613 0072 FFF7FEFF 	 bl vPortValidateInterruptPriority
 1614              	.LBB147:
 1615              	.LBB148:
 211:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 1616              	 .loc 2 211 0
 1617              	
 1618 0076 EFF31182 	 mrs r2,basepri
 1619 007a 4FF0FC03 	 mov r3,#252
 1620 007e 83F31188 	 msr basepri,r3
 1621 0082 BFF36F8F 	 isb 
 1622 0086 BFF34F8F 	 dsb 
 1623              	
 1624              	
 1625              	 .thumb
 1626 008a 7A61     	 str r2,[r7,#20]
 1627 008c 3B61     	 str r3,[r7,#16]
 223:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** }
 1628              	 .loc 2 223 0
 1629 008e 7B69     	 ldr r3,[r7,#20]
 1630              	.LBE148:
 1631              	.LBE147:
1112:../Dave/Generated/FREERTOS/queue.c **** 
1113:../Dave/Generated/FREERTOS/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1632              	 .loc 1 1113 0
 1633 0090 FB62     	 str r3,[r7,#44]
 1634              	.LBB149:
1114:../Dave/Generated/FREERTOS/queue.c **** 	{
1115:../Dave/Generated/FREERTOS/queue.c **** 		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1635              	 .loc 1 1115 0
 1636 0092 3B6B     	 ldr r3,[r7,#48]
 1637 0094 9B6B     	 ldr r3,[r3,#56]
 1638 0096 BB62     	 str r3,[r7,#40]
1116:../Dave/Generated/FREERTOS/queue.c **** 
1117:../Dave/Generated/FREERTOS/queue.c **** 		/* When the queue is used to implement a semaphore no data is ever
1118:../Dave/Generated/FREERTOS/queue.c **** 		moved through the queue but it is still valid to see if the queue 'has
1119:../Dave/Generated/FREERTOS/queue.c **** 		space'. */
1120:../Dave/Generated/FREERTOS/queue.c **** 		if( uxMessagesWaiting < pxQueue->uxLength )
 1639              	 .loc 1 1120 0
 1640 0098 3B6B     	 ldr r3,[r7,#48]
 1641 009a DA6B     	 ldr r2,[r3,#60]
 1642 009c BB6A     	 ldr r3,[r7,#40]
 1643 009e 9A42     	 cmp r2,r3
 1644 00a0 3DD9     	 bls .L121
 1645              	.LBB150:
1121:../Dave/Generated/FREERTOS/queue.c **** 		{
1122:../Dave/Generated/FREERTOS/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 1646              	 .loc 1 1122 0
 1647 00a2 3B6B     	 ldr r3,[r7,#48]
 1648 00a4 93F84530 	 ldrb r3,[r3,#69]
 1649 00a8 87F82730 	 strb r3,[r7,#39]
1123:../Dave/Generated/FREERTOS/queue.c **** 
1124:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
1125:../Dave/Generated/FREERTOS/queue.c **** 
1126:../Dave/Generated/FREERTOS/queue.c **** 			/* A task can only have an inherited priority if it is a mutex
1127:../Dave/Generated/FREERTOS/queue.c **** 			holder - and if there is a mutex holder then the mutex cannot be
1128:../Dave/Generated/FREERTOS/queue.c **** 			given from an ISR.  As this is the ISR version of the function it
1129:../Dave/Generated/FREERTOS/queue.c **** 			can be assumed there is no mutex holder and no need to determine if
1130:../Dave/Generated/FREERTOS/queue.c **** 			priority disinheritance is needed.  Simply increase the count of
1131:../Dave/Generated/FREERTOS/queue.c **** 			messages (semaphores) available. */
1132:../Dave/Generated/FREERTOS/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 1650              	 .loc 1 1132 0
 1651 00ac BB6A     	 ldr r3,[r7,#40]
 1652 00ae 5A1C     	 adds r2,r3,#1
 1653 00b0 3B6B     	 ldr r3,[r7,#48]
 1654 00b2 9A63     	 str r2,[r3,#56]
1133:../Dave/Generated/FREERTOS/queue.c **** 
1134:../Dave/Generated/FREERTOS/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
1135:../Dave/Generated/FREERTOS/queue.c **** 			be done when the queue is unlocked later. */
1136:../Dave/Generated/FREERTOS/queue.c **** 			if( cTxLock == queueUNLOCKED )
 1655              	 .loc 1 1136 0
 1656 00b4 97F92730 	 ldrsb r3,[r7,#39]
 1657 00b8 B3F1FF3F 	 cmp r3,#-1
 1658 00bc 24D1     	 bne .L122
1137:../Dave/Generated/FREERTOS/queue.c **** 			{
1138:../Dave/Generated/FREERTOS/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
1139:../Dave/Generated/FREERTOS/queue.c **** 				{
1140:../Dave/Generated/FREERTOS/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 1659              	 .loc 1 1140 0
 1660 00be 3B6B     	 ldr r3,[r7,#48]
 1661 00c0 9B6C     	 ldr r3,[r3,#72]
 1662 00c2 002B     	 cmp r3,#0
 1663 00c4 0DD0     	 beq .L123
1141:../Dave/Generated/FREERTOS/queue.c **** 					{
1142:../Dave/Generated/FREERTOS/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
 1664              	 .loc 1 1142 0
 1665 00c6 386B     	 ldr r0,[r7,#48]
 1666 00c8 0021     	 movs r1,#0
 1667 00ca FFF7FEFF 	 bl prvNotifyQueueSetContainer
 1668 00ce 0346     	 mov r3,r0
 1669 00d0 002B     	 cmp r3,#0
 1670 00d2 21D0     	 beq .L124
1143:../Dave/Generated/FREERTOS/queue.c **** 						{
1144:../Dave/Generated/FREERTOS/queue.c **** 							/* The semaphore is a member of a queue set, and
1145:../Dave/Generated/FREERTOS/queue.c **** 							posting	to the queue set caused a higher priority
1146:../Dave/Generated/FREERTOS/queue.c **** 							task to	unblock.  A context switch is required. */
1147:../Dave/Generated/FREERTOS/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 1671              	 .loc 1 1147 0
 1672 00d4 3B68     	 ldr r3,[r7]
 1673 00d6 002B     	 cmp r3,#0
 1674 00d8 1ED0     	 beq .L124
1148:../Dave/Generated/FREERTOS/queue.c **** 							{
1149:../Dave/Generated/FREERTOS/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 1675              	 .loc 1 1149 0
 1676 00da 3B68     	 ldr r3,[r7]
 1677 00dc 0122     	 movs r2,#1
 1678 00de 1A60     	 str r2,[r3]
 1679 00e0 1AE0     	 b .L124
 1680              	.L123:
1150:../Dave/Generated/FREERTOS/queue.c **** 							}
1151:../Dave/Generated/FREERTOS/queue.c **** 							else
1152:../Dave/Generated/FREERTOS/queue.c **** 							{
1153:../Dave/Generated/FREERTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1154:../Dave/Generated/FREERTOS/queue.c **** 							}
1155:../Dave/Generated/FREERTOS/queue.c **** 						}
1156:../Dave/Generated/FREERTOS/queue.c **** 						else
1157:../Dave/Generated/FREERTOS/queue.c **** 						{
1158:../Dave/Generated/FREERTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1159:../Dave/Generated/FREERTOS/queue.c **** 						}
1160:../Dave/Generated/FREERTOS/queue.c **** 					}
1161:../Dave/Generated/FREERTOS/queue.c **** 					else
1162:../Dave/Generated/FREERTOS/queue.c **** 					{
1163:../Dave/Generated/FREERTOS/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1681              	 .loc 1 1163 0
 1682 00e2 3B6B     	 ldr r3,[r7,#48]
 1683 00e4 5B6A     	 ldr r3,[r3,#36]
 1684 00e6 002B     	 cmp r3,#0
 1685 00e8 16D0     	 beq .L124
1164:../Dave/Generated/FREERTOS/queue.c **** 						{
1165:../Dave/Generated/FREERTOS/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1686              	 .loc 1 1165 0
 1687 00ea 3B6B     	 ldr r3,[r7,#48]
 1688 00ec 2433     	 adds r3,r3,#36
 1689 00ee 1846     	 mov r0,r3
 1690 00f0 FFF7FEFF 	 bl xTaskRemoveFromEventList
 1691 00f4 0346     	 mov r3,r0
 1692 00f6 002B     	 cmp r3,#0
 1693 00f8 0ED0     	 beq .L124
1166:../Dave/Generated/FREERTOS/queue.c **** 							{
1167:../Dave/Generated/FREERTOS/queue.c **** 								/* The task waiting has a higher priority so
1168:../Dave/Generated/FREERTOS/queue.c **** 								record that a context switch is required. */
1169:../Dave/Generated/FREERTOS/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
 1694              	 .loc 1 1169 0
 1695 00fa 3B68     	 ldr r3,[r7]
 1696 00fc 002B     	 cmp r3,#0
 1697 00fe 0BD0     	 beq .L124
1170:../Dave/Generated/FREERTOS/queue.c **** 								{
1171:../Dave/Generated/FREERTOS/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
 1698              	 .loc 1 1171 0
 1699 0100 3B68     	 ldr r3,[r7]
 1700 0102 0122     	 movs r2,#1
 1701 0104 1A60     	 str r2,[r3]
 1702 0106 07E0     	 b .L124
 1703              	.L122:
1172:../Dave/Generated/FREERTOS/queue.c **** 								}
1173:../Dave/Generated/FREERTOS/queue.c **** 								else
1174:../Dave/Generated/FREERTOS/queue.c **** 								{
1175:../Dave/Generated/FREERTOS/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1176:../Dave/Generated/FREERTOS/queue.c **** 								}
1177:../Dave/Generated/FREERTOS/queue.c **** 							}
1178:../Dave/Generated/FREERTOS/queue.c **** 							else
1179:../Dave/Generated/FREERTOS/queue.c **** 							{
1180:../Dave/Generated/FREERTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1181:../Dave/Generated/FREERTOS/queue.c **** 							}
1182:../Dave/Generated/FREERTOS/queue.c **** 						}
1183:../Dave/Generated/FREERTOS/queue.c **** 						else
1184:../Dave/Generated/FREERTOS/queue.c **** 						{
1185:../Dave/Generated/FREERTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1186:../Dave/Generated/FREERTOS/queue.c **** 						}
1187:../Dave/Generated/FREERTOS/queue.c **** 					}
1188:../Dave/Generated/FREERTOS/queue.c **** 				}
1189:../Dave/Generated/FREERTOS/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1190:../Dave/Generated/FREERTOS/queue.c **** 				{
1191:../Dave/Generated/FREERTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1192:../Dave/Generated/FREERTOS/queue.c **** 					{
1193:../Dave/Generated/FREERTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1194:../Dave/Generated/FREERTOS/queue.c **** 						{
1195:../Dave/Generated/FREERTOS/queue.c **** 							/* The task waiting has a higher priority so record that a
1196:../Dave/Generated/FREERTOS/queue.c **** 							context	switch is required. */
1197:../Dave/Generated/FREERTOS/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1198:../Dave/Generated/FREERTOS/queue.c **** 							{
1199:../Dave/Generated/FREERTOS/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1200:../Dave/Generated/FREERTOS/queue.c **** 							}
1201:../Dave/Generated/FREERTOS/queue.c **** 							else
1202:../Dave/Generated/FREERTOS/queue.c **** 							{
1203:../Dave/Generated/FREERTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1204:../Dave/Generated/FREERTOS/queue.c **** 							}
1205:../Dave/Generated/FREERTOS/queue.c **** 						}
1206:../Dave/Generated/FREERTOS/queue.c **** 						else
1207:../Dave/Generated/FREERTOS/queue.c **** 						{
1208:../Dave/Generated/FREERTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1209:../Dave/Generated/FREERTOS/queue.c **** 						}
1210:../Dave/Generated/FREERTOS/queue.c **** 					}
1211:../Dave/Generated/FREERTOS/queue.c **** 					else
1212:../Dave/Generated/FREERTOS/queue.c **** 					{
1213:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1214:../Dave/Generated/FREERTOS/queue.c **** 					}
1215:../Dave/Generated/FREERTOS/queue.c **** 				}
1216:../Dave/Generated/FREERTOS/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1217:../Dave/Generated/FREERTOS/queue.c **** 			}
1218:../Dave/Generated/FREERTOS/queue.c **** 			else
1219:../Dave/Generated/FREERTOS/queue.c **** 			{
1220:../Dave/Generated/FREERTOS/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1221:../Dave/Generated/FREERTOS/queue.c **** 				knows that data was posted while it was locked. */
1222:../Dave/Generated/FREERTOS/queue.c **** 				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 1704              	 .loc 1 1222 0
 1705 0108 97F82730 	 ldrb r3,[r7,#39]
 1706 010c 0133     	 adds r3,r3,#1
 1707 010e DBB2     	 uxtb r3,r3
 1708 0110 DAB2     	 uxtb r2,r3
 1709 0112 3B6B     	 ldr r3,[r7,#48]
 1710 0114 83F84520 	 strb r2,[r3,#69]
 1711              	.L124:
1223:../Dave/Generated/FREERTOS/queue.c **** 			}
1224:../Dave/Generated/FREERTOS/queue.c **** 
1225:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdPASS;
 1712              	 .loc 1 1225 0
 1713 0118 0123     	 movs r3,#1
 1714 011a 7B63     	 str r3,[r7,#52]
 1715              	.LBE150:
 1716 011c 01E0     	 b .L125
 1717              	.L121:
1226:../Dave/Generated/FREERTOS/queue.c **** 		}
1227:../Dave/Generated/FREERTOS/queue.c **** 		else
1228:../Dave/Generated/FREERTOS/queue.c **** 		{
1229:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1230:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = errQUEUE_FULL;
 1718              	 .loc 1 1230 0
 1719 011e 0023     	 movs r3,#0
 1720 0120 7B63     	 str r3,[r7,#52]
 1721              	.L125:
 1722 0122 FB6A     	 ldr r3,[r7,#44]
 1723 0124 FB60     	 str r3,[r7,#12]
 1724              	.LBE149:
 1725              	.LBB151:
 1726              	.LBB152:
 1727              	 .loc 2 229 0
 1728 0126 FB68     	 ldr r3,[r7,#12]
 1729              	
 1730 0128 83F31188 	 msr basepri,r3
 1731              	
 1732              	 .thumb
 1733              	.LBE152:
 1734              	.LBE151:
1231:../Dave/Generated/FREERTOS/queue.c **** 		}
1232:../Dave/Generated/FREERTOS/queue.c **** 	}
1233:../Dave/Generated/FREERTOS/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1234:../Dave/Generated/FREERTOS/queue.c **** 
1235:../Dave/Generated/FREERTOS/queue.c **** 	return xReturn;
 1735              	 .loc 1 1235 0
 1736 012c 7B6B     	 ldr r3,[r7,#52]
1236:../Dave/Generated/FREERTOS/queue.c **** }
 1737              	 .loc 1 1236 0
 1738 012e 1846     	 mov r0,r3
 1739 0130 3837     	 adds r7,r7,#56
 1740              	 .cfi_def_cfa_offset 8
 1741 0132 BD46     	 mov sp,r7
 1742              	 .cfi_def_cfa_register 13
 1743              	 
 1744 0134 80BD     	 pop {r7,pc}
 1745              	 .cfi_endproc
 1746              	.LFE149:
 1748 0136 00BF     	 .section .text.xQueueReceive,"ax",%progbits
 1749              	 .align 2
 1750              	 .global xQueueReceive
 1751              	 .thumb
 1752              	 .thumb_func
 1754              	xQueueReceive:
 1755              	.LFB150:
1237:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
1238:../Dave/Generated/FREERTOS/queue.c **** 
1239:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
1240:../Dave/Generated/FREERTOS/queue.c **** {
 1756              	 .loc 1 1240 0
 1757              	 .cfi_startproc
 1758              	 
 1759              	 
 1760 0000 80B5     	 push {r7,lr}
 1761              	 .cfi_def_cfa_offset 8
 1762              	 .cfi_offset 7,-8
 1763              	 .cfi_offset 14,-4
 1764 0002 8CB0     	 sub sp,sp,#48
 1765              	 .cfi_def_cfa_offset 56
 1766 0004 00AF     	 add r7,sp,#0
 1767              	 .cfi_def_cfa_register 7
 1768 0006 F860     	 str r0,[r7,#12]
 1769 0008 B960     	 str r1,[r7,#8]
 1770 000a 7A60     	 str r2,[r7,#4]
1241:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1771              	 .loc 1 1241 0
 1772 000c 0023     	 movs r3,#0
 1773 000e FB62     	 str r3,[r7,#44]
1242:../Dave/Generated/FREERTOS/queue.c **** TimeOut_t xTimeOut;
1243:../Dave/Generated/FREERTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1774              	 .loc 1 1243 0
 1775 0010 FB68     	 ldr r3,[r7,#12]
 1776 0012 BB62     	 str r3,[r7,#40]
1244:../Dave/Generated/FREERTOS/queue.c **** 
1245:../Dave/Generated/FREERTOS/queue.c **** 	/* Check the pointer is not NULL. */
1246:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( ( pxQueue ) );
 1777              	 .loc 1 1246 0
 1778 0014 BB6A     	 ldr r3,[r7,#40]
 1779 0016 002B     	 cmp r3,#0
 1780 0018 09D1     	 bne .L128
 1781              	.LBB153:
 1782              	.LBB154:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 1783              	 .loc 2 195 0 discriminator 1
 1784              	
 1785 001a 4FF0FC03 	 mov r3,#252
 1786 001e 83F31188 	 msr basepri,r3
 1787 0022 BFF36F8F 	 isb 
 1788 0026 BFF34F8F 	 dsb 
 1789              	
 1790              	
 1791              	 .thumb
 1792 002a 3B62     	 str r3,[r7,#32]
 1793              	.L129:
 1794              	.LBE154:
 1795              	.LBE153:
 1796              	 .loc 1 1246 0 discriminator 1
 1797 002c FEE7     	 b .L129
 1798              	.L128:
1247:../Dave/Generated/FREERTOS/queue.c **** 
1248:../Dave/Generated/FREERTOS/queue.c **** 	/* The buffer into which data is received can only be NULL if the data size
1249:../Dave/Generated/FREERTOS/queue.c **** 	is zero (so no data is copied into the buffer. */
1250:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) )
 1799              	 .loc 1 1250 0
 1800 002e BB68     	 ldr r3,[r7,#8]
 1801 0030 002B     	 cmp r3,#0
 1802 0032 03D1     	 bne .L130
 1803              	 .loc 1 1250 0 is_stmt 0 discriminator 2
 1804 0034 BB6A     	 ldr r3,[r7,#40]
 1805 0036 1B6C     	 ldr r3,[r3,#64]
 1806 0038 002B     	 cmp r3,#0
 1807 003a 01D1     	 bne .L131
 1808              	.L130:
 1809              	 .loc 1 1250 0 discriminator 3
 1810 003c 0123     	 movs r3,#1
 1811 003e 00E0     	 b .L132
 1812              	.L131:
 1813              	 .loc 1 1250 0 discriminator 4
 1814 0040 0023     	 movs r3,#0
 1815              	.L132:
 1816              	 .loc 1 1250 0 discriminator 6
 1817 0042 002B     	 cmp r3,#0
 1818 0044 09D1     	 bne .L133
 1819              	.LBB155:
 1820              	.LBB156:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 1821              	 .loc 2 195 0 is_stmt 1 discriminator 7
 1822              	
 1823 0046 4FF0FC03 	 mov r3,#252
 1824 004a 83F31188 	 msr basepri,r3
 1825 004e BFF36F8F 	 isb 
 1826 0052 BFF34F8F 	 dsb 
 1827              	
 1828              	
 1829              	 .thumb
 1830 0056 FB61     	 str r3,[r7,#28]
 1831              	.L134:
 1832              	.LBE156:
 1833              	.LBE155:
 1834              	 .loc 1 1250 0 discriminator 2
 1835 0058 FEE7     	 b .L134
 1836              	.L133:
1251:../Dave/Generated/FREERTOS/queue.c **** 
1252:../Dave/Generated/FREERTOS/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1253:../Dave/Generated/FREERTOS/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1254:../Dave/Generated/FREERTOS/queue.c **** 	{
1255:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
 1837              	 .loc 1 1255 0
 1838 005a FFF7FEFF 	 bl xTaskGetSchedulerState
 1839 005e 0346     	 mov r3,r0
 1840 0060 002B     	 cmp r3,#0
 1841 0062 02D1     	 bne .L135
 1842              	 .loc 1 1255 0 is_stmt 0 discriminator 2
 1843 0064 7B68     	 ldr r3,[r7,#4]
 1844 0066 002B     	 cmp r3,#0
 1845 0068 01D1     	 bne .L136
 1846              	.L135:
 1847              	 .loc 1 1255 0 discriminator 3
 1848 006a 0123     	 movs r3,#1
 1849 006c 00E0     	 b .L137
 1850              	.L136:
 1851              	 .loc 1 1255 0 discriminator 4
 1852 006e 0023     	 movs r3,#0
 1853              	.L137:
 1854              	 .loc 1 1255 0 discriminator 6
 1855 0070 002B     	 cmp r3,#0
 1856 0072 09D1     	 bne .L138
 1857              	.LBB157:
 1858              	.LBB158:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 1859              	 .loc 2 195 0 is_stmt 1 discriminator 7
 1860              	
 1861 0074 4FF0FC03 	 mov r3,#252
 1862 0078 83F31188 	 msr basepri,r3
 1863 007c BFF36F8F 	 isb 
 1864 0080 BFF34F8F 	 dsb 
 1865              	
 1866              	
 1867              	 .thumb
 1868 0084 BB61     	 str r3,[r7,#24]
 1869              	.L139:
 1870              	.LBE158:
 1871              	.LBE157:
 1872              	 .loc 1 1255 0 discriminator 3
 1873 0086 FEE7     	 b .L139
 1874              	.L138:
1256:../Dave/Generated/FREERTOS/queue.c **** 	}
1257:../Dave/Generated/FREERTOS/queue.c **** 	#endif
1258:../Dave/Generated/FREERTOS/queue.c **** 
1259:../Dave/Generated/FREERTOS/queue.c **** 
1260:../Dave/Generated/FREERTOS/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
1261:../Dave/Generated/FREERTOS/queue.c **** 	statements within the function itself.  This is done in the interest
1262:../Dave/Generated/FREERTOS/queue.c **** 	of execution time efficiency. */
1263:../Dave/Generated/FREERTOS/queue.c **** 
1264:../Dave/Generated/FREERTOS/queue.c **** 	for( ;; )
1265:../Dave/Generated/FREERTOS/queue.c **** 	{
1266:../Dave/Generated/FREERTOS/queue.c **** 		taskENTER_CRITICAL();
 1875              	 .loc 1 1266 0
 1876 0088 FFF7FEFF 	 bl vPortEnterCritical
 1877              	.LBB159:
1267:../Dave/Generated/FREERTOS/queue.c **** 		{
1268:../Dave/Generated/FREERTOS/queue.c **** 			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1878              	 .loc 1 1268 0
 1879 008c BB6A     	 ldr r3,[r7,#40]
 1880 008e 9B6B     	 ldr r3,[r3,#56]
 1881 0090 7B62     	 str r3,[r7,#36]
1269:../Dave/Generated/FREERTOS/queue.c **** 
1270:../Dave/Generated/FREERTOS/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1271:../Dave/Generated/FREERTOS/queue.c **** 			must be the highest priority task wanting to access the queue. */
1272:../Dave/Generated/FREERTOS/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 1882              	 .loc 1 1272 0
 1883 0092 7B6A     	 ldr r3,[r7,#36]
 1884 0094 002B     	 cmp r3,#0
 1885 0096 1FD0     	 beq .L140
1273:../Dave/Generated/FREERTOS/queue.c **** 			{
1274:../Dave/Generated/FREERTOS/queue.c **** 				/* Data available, remove one item. */
1275:../Dave/Generated/FREERTOS/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 1886              	 .loc 1 1275 0
 1887 0098 B86A     	 ldr r0,[r7,#40]
 1888 009a B968     	 ldr r1,[r7,#8]
 1889 009c FFF7FEFF 	 bl prvCopyDataFromQueue
1276:../Dave/Generated/FREERTOS/queue.c **** 				traceQUEUE_RECEIVE( pxQueue );
1277:../Dave/Generated/FREERTOS/queue.c **** 				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 1890              	 .loc 1 1277 0
 1891 00a0 7B6A     	 ldr r3,[r7,#36]
 1892 00a2 5A1E     	 subs r2,r3,#1
 1893 00a4 BB6A     	 ldr r3,[r7,#40]
 1894 00a6 9A63     	 str r2,[r3,#56]
1278:../Dave/Generated/FREERTOS/queue.c **** 
1279:../Dave/Generated/FREERTOS/queue.c **** 				/* There is now space in the queue, were any tasks waiting to
1280:../Dave/Generated/FREERTOS/queue.c **** 				post to the queue?  If so, unblock the highest priority waiting
1281:../Dave/Generated/FREERTOS/queue.c **** 				task. */
1282:../Dave/Generated/FREERTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1895              	 .loc 1 1282 0
 1896 00a8 BB6A     	 ldr r3,[r7,#40]
 1897 00aa 1B69     	 ldr r3,[r3,#16]
 1898 00ac 002B     	 cmp r3,#0
 1899 00ae 0FD0     	 beq .L141
1283:../Dave/Generated/FREERTOS/queue.c **** 				{
1284:../Dave/Generated/FREERTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1900              	 .loc 1 1284 0
 1901 00b0 BB6A     	 ldr r3,[r7,#40]
 1902 00b2 1033     	 adds r3,r3,#16
 1903 00b4 1846     	 mov r0,r3
 1904 00b6 FFF7FEFF 	 bl xTaskRemoveFromEventList
 1905 00ba 0346     	 mov r3,r0
 1906 00bc 002B     	 cmp r3,#0
 1907 00be 07D0     	 beq .L141
1285:../Dave/Generated/FREERTOS/queue.c **** 					{
1286:../Dave/Generated/FREERTOS/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 1908              	 .loc 1 1286 0
 1909 00c0 3E4B     	 ldr r3,.L152
 1910 00c2 4FF08052 	 mov r2,#268435456
 1911 00c6 1A60     	 str r2,[r3]
 1912              	
 1913 00c8 BFF34F8F 	 dsb
 1914              	
 1915              	
 1916 00cc BFF36F8F 	 isb
 1917              	
 1918              	 .thumb
 1919              	.L141:
1287:../Dave/Generated/FREERTOS/queue.c **** 					}
1288:../Dave/Generated/FREERTOS/queue.c **** 					else
1289:../Dave/Generated/FREERTOS/queue.c **** 					{
1290:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1291:../Dave/Generated/FREERTOS/queue.c **** 					}
1292:../Dave/Generated/FREERTOS/queue.c **** 				}
1293:../Dave/Generated/FREERTOS/queue.c **** 				else
1294:../Dave/Generated/FREERTOS/queue.c **** 				{
1295:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1296:../Dave/Generated/FREERTOS/queue.c **** 				}
1297:../Dave/Generated/FREERTOS/queue.c **** 
1298:../Dave/Generated/FREERTOS/queue.c **** 				taskEXIT_CRITICAL();
 1920              	 .loc 1 1298 0
 1921 00d0 FFF7FEFF 	 bl vPortExitCritical
1299:../Dave/Generated/FREERTOS/queue.c **** 				return pdPASS;
 1922              	 .loc 1 1299 0
 1923 00d4 0123     	 movs r3,#1
 1924 00d6 6DE0     	 b .L151
 1925              	.L140:
1300:../Dave/Generated/FREERTOS/queue.c **** 			}
1301:../Dave/Generated/FREERTOS/queue.c **** 			else
1302:../Dave/Generated/FREERTOS/queue.c **** 			{
1303:../Dave/Generated/FREERTOS/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 1926              	 .loc 1 1303 0
 1927 00d8 7B68     	 ldr r3,[r7,#4]
 1928 00da 002B     	 cmp r3,#0
 1929 00dc 03D1     	 bne .L143
1304:../Dave/Generated/FREERTOS/queue.c **** 				{
1305:../Dave/Generated/FREERTOS/queue.c **** 					/* The queue was empty and no block time is specified (or
1306:../Dave/Generated/FREERTOS/queue.c **** 					the block time has expired) so leave now. */
1307:../Dave/Generated/FREERTOS/queue.c **** 					taskEXIT_CRITICAL();
 1930              	 .loc 1 1307 0
 1931 00de FFF7FEFF 	 bl vPortExitCritical
1308:../Dave/Generated/FREERTOS/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1309:../Dave/Generated/FREERTOS/queue.c **** 					return errQUEUE_EMPTY;
 1932              	 .loc 1 1309 0
 1933 00e2 0023     	 movs r3,#0
 1934 00e4 66E0     	 b .L151
 1935              	.L143:
1310:../Dave/Generated/FREERTOS/queue.c **** 				}
1311:../Dave/Generated/FREERTOS/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 1936              	 .loc 1 1311 0
 1937 00e6 FB6A     	 ldr r3,[r7,#44]
 1938 00e8 002B     	 cmp r3,#0
 1939 00ea 06D1     	 bne .L144
1312:../Dave/Generated/FREERTOS/queue.c **** 				{
1313:../Dave/Generated/FREERTOS/queue.c **** 					/* The queue was empty and a block time was specified so
1314:../Dave/Generated/FREERTOS/queue.c **** 					configure the timeout structure. */
1315:../Dave/Generated/FREERTOS/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
 1940              	 .loc 1 1315 0
 1941 00ec 07F11003 	 add r3,r7,#16
 1942 00f0 1846     	 mov r0,r3
 1943 00f2 FFF7FEFF 	 bl vTaskInternalSetTimeOutState
1316:../Dave/Generated/FREERTOS/queue.c **** 					xEntryTimeSet = pdTRUE;
 1944              	 .loc 1 1316 0
 1945 00f6 0123     	 movs r3,#1
 1946 00f8 FB62     	 str r3,[r7,#44]
 1947              	.L144:
 1948              	.LBE159:
1317:../Dave/Generated/FREERTOS/queue.c **** 				}
1318:../Dave/Generated/FREERTOS/queue.c **** 				else
1319:../Dave/Generated/FREERTOS/queue.c **** 				{
1320:../Dave/Generated/FREERTOS/queue.c **** 					/* Entry time was already set. */
1321:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1322:../Dave/Generated/FREERTOS/queue.c **** 				}
1323:../Dave/Generated/FREERTOS/queue.c **** 			}
1324:../Dave/Generated/FREERTOS/queue.c **** 		}
1325:../Dave/Generated/FREERTOS/queue.c **** 		taskEXIT_CRITICAL();
 1949              	 .loc 1 1325 0
 1950 00fa FFF7FEFF 	 bl vPortExitCritical
1326:../Dave/Generated/FREERTOS/queue.c **** 
1327:../Dave/Generated/FREERTOS/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1328:../Dave/Generated/FREERTOS/queue.c **** 		now the critical section has been exited. */
1329:../Dave/Generated/FREERTOS/queue.c **** 
1330:../Dave/Generated/FREERTOS/queue.c **** 		vTaskSuspendAll();
 1951              	 .loc 1 1330 0
 1952 00fe FFF7FEFF 	 bl vTaskSuspendAll
1331:../Dave/Generated/FREERTOS/queue.c **** 		prvLockQueue( pxQueue );
 1953              	 .loc 1 1331 0
 1954 0102 FFF7FEFF 	 bl vPortEnterCritical
 1955 0106 BB6A     	 ldr r3,[r7,#40]
 1956 0108 93F84430 	 ldrb r3,[r3,#68]
 1957 010c DBB2     	 uxtb r3,r3
 1958 010e 5BB2     	 sxtb r3,r3
 1959 0110 B3F1FF3F 	 cmp r3,#-1
 1960 0114 03D1     	 bne .L145
 1961              	 .loc 1 1331 0 is_stmt 0 discriminator 1
 1962 0116 BB6A     	 ldr r3,[r7,#40]
 1963 0118 0022     	 movs r2,#0
 1964 011a 83F84420 	 strb r2,[r3,#68]
 1965              	.L145:
 1966              	 .loc 1 1331 0 discriminator 3
 1967 011e BB6A     	 ldr r3,[r7,#40]
 1968 0120 93F84530 	 ldrb r3,[r3,#69]
 1969 0124 DBB2     	 uxtb r3,r3
 1970 0126 5BB2     	 sxtb r3,r3
 1971 0128 B3F1FF3F 	 cmp r3,#-1
 1972 012c 03D1     	 bne .L146
 1973              	 .loc 1 1331 0 discriminator 4
 1974 012e BB6A     	 ldr r3,[r7,#40]
 1975 0130 0022     	 movs r2,#0
 1976 0132 83F84520 	 strb r2,[r3,#69]
 1977              	.L146:
 1978              	 .loc 1 1331 0 discriminator 6
 1979 0136 FFF7FEFF 	 bl vPortExitCritical
1332:../Dave/Generated/FREERTOS/queue.c **** 
1333:../Dave/Generated/FREERTOS/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1334:../Dave/Generated/FREERTOS/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1980              	 .loc 1 1334 0 is_stmt 1 discriminator 6
 1981 013a 07F11002 	 add r2,r7,#16
 1982 013e 3B1D     	 adds r3,r7,#4
 1983 0140 1046     	 mov r0,r2
 1984 0142 1946     	 mov r1,r3
 1985 0144 FFF7FEFF 	 bl xTaskCheckForTimeOut
 1986 0148 0346     	 mov r3,r0
 1987 014a 002B     	 cmp r3,#0
 1988 014c 24D1     	 bne .L147
1335:../Dave/Generated/FREERTOS/queue.c **** 		{
1336:../Dave/Generated/FREERTOS/queue.c **** 			/* The timeout has not expired.  If the queue is still empty place
1337:../Dave/Generated/FREERTOS/queue.c **** 			the task on the list of tasks waiting to receive from the queue. */
1338:../Dave/Generated/FREERTOS/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1989              	 .loc 1 1338 0
 1990 014e B86A     	 ldr r0,[r7,#40]
 1991 0150 FFF7FEFF 	 bl prvIsQueueEmpty
 1992 0154 0346     	 mov r3,r0
 1993 0156 002B     	 cmp r3,#0
 1994 0158 18D0     	 beq .L148
1339:../Dave/Generated/FREERTOS/queue.c **** 			{
1340:../Dave/Generated/FREERTOS/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1341:../Dave/Generated/FREERTOS/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1995              	 .loc 1 1341 0
 1996 015a BB6A     	 ldr r3,[r7,#40]
 1997 015c 03F12402 	 add r2,r3,#36
 1998 0160 7B68     	 ldr r3,[r7,#4]
 1999 0162 1046     	 mov r0,r2
 2000 0164 1946     	 mov r1,r3
 2001 0166 FFF7FEFF 	 bl vTaskPlaceOnEventList
1342:../Dave/Generated/FREERTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 2002              	 .loc 1 1342 0
 2003 016a B86A     	 ldr r0,[r7,#40]
 2004 016c FFF7FEFF 	 bl prvUnlockQueue
1343:../Dave/Generated/FREERTOS/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 2005              	 .loc 1 1343 0
 2006 0170 FFF7FEFF 	 bl xTaskResumeAll
 2007 0174 0346     	 mov r3,r0
 2008 0176 002B     	 cmp r3,#0
 2009 0178 1BD1     	 bne .L150
1344:../Dave/Generated/FREERTOS/queue.c **** 				{
1345:../Dave/Generated/FREERTOS/queue.c **** 					portYIELD_WITHIN_API();
 2010              	 .loc 1 1345 0
 2011 017a 104B     	 ldr r3,.L152
 2012 017c 4FF08052 	 mov r2,#268435456
 2013 0180 1A60     	 str r2,[r3]
 2014              	
 2015 0182 BFF34F8F 	 dsb
 2016              	
 2017              	
 2018 0186 BFF36F8F 	 isb
 2019              	
 2020              	 .thumb
 2021 018a 12E0     	 b .L150
 2022              	.L148:
1346:../Dave/Generated/FREERTOS/queue.c **** 				}
1347:../Dave/Generated/FREERTOS/queue.c **** 				else
1348:../Dave/Generated/FREERTOS/queue.c **** 				{
1349:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1350:../Dave/Generated/FREERTOS/queue.c **** 				}
1351:../Dave/Generated/FREERTOS/queue.c **** 			}
1352:../Dave/Generated/FREERTOS/queue.c **** 			else
1353:../Dave/Generated/FREERTOS/queue.c **** 			{
1354:../Dave/Generated/FREERTOS/queue.c **** 				/* The queue contains data again.  Loop back to try and read the
1355:../Dave/Generated/FREERTOS/queue.c **** 				data. */
1356:../Dave/Generated/FREERTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 2023              	 .loc 1 1356 0
 2024 018c B86A     	 ldr r0,[r7,#40]
 2025 018e FFF7FEFF 	 bl prvUnlockQueue
1357:../Dave/Generated/FREERTOS/queue.c **** 				( void ) xTaskResumeAll();
 2026              	 .loc 1 1357 0
 2027 0192 FFF7FEFF 	 bl xTaskResumeAll
 2028 0196 77E7     	 b .L138
 2029              	.L147:
1358:../Dave/Generated/FREERTOS/queue.c **** 			}
1359:../Dave/Generated/FREERTOS/queue.c **** 		}
1360:../Dave/Generated/FREERTOS/queue.c **** 		else
1361:../Dave/Generated/FREERTOS/queue.c **** 		{
1362:../Dave/Generated/FREERTOS/queue.c **** 			/* Timed out.  If there is no data in the queue exit, otherwise loop
1363:../Dave/Generated/FREERTOS/queue.c **** 			back and attempt to read the data. */
1364:../Dave/Generated/FREERTOS/queue.c **** 			prvUnlockQueue( pxQueue );
 2030              	 .loc 1 1364 0
 2031 0198 B86A     	 ldr r0,[r7,#40]
 2032 019a FFF7FEFF 	 bl prvUnlockQueue
1365:../Dave/Generated/FREERTOS/queue.c **** 			( void ) xTaskResumeAll();
 2033              	 .loc 1 1365 0
 2034 019e FFF7FEFF 	 bl xTaskResumeAll
1366:../Dave/Generated/FREERTOS/queue.c **** 
1367:../Dave/Generated/FREERTOS/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 2035              	 .loc 1 1367 0
 2036 01a2 B86A     	 ldr r0,[r7,#40]
 2037 01a4 FFF7FEFF 	 bl prvIsQueueEmpty
 2038 01a8 0346     	 mov r3,r0
 2039 01aa 002B     	 cmp r3,#0
 2040 01ac 01D0     	 beq .L150
1368:../Dave/Generated/FREERTOS/queue.c **** 			{
1369:../Dave/Generated/FREERTOS/queue.c **** 				traceQUEUE_RECEIVE_FAILED( pxQueue );
1370:../Dave/Generated/FREERTOS/queue.c **** 				return errQUEUE_EMPTY;
 2041              	 .loc 1 1370 0
 2042 01ae 0023     	 movs r3,#0
 2043 01b0 00E0     	 b .L151
 2044              	.L150:
1371:../Dave/Generated/FREERTOS/queue.c **** 			}
1372:../Dave/Generated/FREERTOS/queue.c **** 			else
1373:../Dave/Generated/FREERTOS/queue.c **** 			{
1374:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1375:../Dave/Generated/FREERTOS/queue.c **** 			}
1376:../Dave/Generated/FREERTOS/queue.c **** 		}
1377:../Dave/Generated/FREERTOS/queue.c **** 	}
 2045              	 .loc 1 1377 0 discriminator 5
 2046 01b2 69E7     	 b .L138
 2047              	.L151:
1378:../Dave/Generated/FREERTOS/queue.c **** }
 2048              	 .loc 1 1378 0 discriminator 6
 2049 01b4 1846     	 mov r0,r3
 2050 01b6 3037     	 adds r7,r7,#48
 2051              	 .cfi_def_cfa_offset 8
 2052 01b8 BD46     	 mov sp,r7
 2053              	 .cfi_def_cfa_register 13
 2054              	 
 2055 01ba 80BD     	 pop {r7,pc}
 2056              	.L153:
 2057              	 .align 2
 2058              	.L152:
 2059 01bc 04ED00E0 	 .word -536810236
 2060              	 .cfi_endproc
 2061              	.LFE150:
 2063              	 .section .text.xQueueSemaphoreTake,"ax",%progbits
 2064              	 .align 2
 2065              	 .global xQueueSemaphoreTake
 2066              	 .thumb
 2067              	 .thumb_func
 2069              	xQueueSemaphoreTake:
 2070              	.LFB151:
1379:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
1380:../Dave/Generated/FREERTOS/queue.c **** 
1381:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
1382:../Dave/Generated/FREERTOS/queue.c **** {
 2071              	 .loc 1 1382 0
 2072              	 .cfi_startproc
 2073              	 
 2074              	 
 2075 0000 80B5     	 push {r7,lr}
 2076              	 .cfi_def_cfa_offset 8
 2077              	 .cfi_offset 7,-8
 2078              	 .cfi_offset 14,-4
 2079 0002 8EB0     	 sub sp,sp,#56
 2080              	 .cfi_def_cfa_offset 64
 2081 0004 00AF     	 add r7,sp,#0
 2082              	 .cfi_def_cfa_register 7
 2083 0006 7860     	 str r0,[r7,#4]
 2084 0008 3960     	 str r1,[r7]
1383:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 2085              	 .loc 1 1383 0
 2086 000a 0023     	 movs r3,#0
 2087 000c 7B63     	 str r3,[r7,#52]
1384:../Dave/Generated/FREERTOS/queue.c **** TimeOut_t xTimeOut;
1385:../Dave/Generated/FREERTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 2088              	 .loc 1 1385 0
 2089 000e 7B68     	 ldr r3,[r7,#4]
 2090 0010 FB62     	 str r3,[r7,#44]
1386:../Dave/Generated/FREERTOS/queue.c **** 
1387:../Dave/Generated/FREERTOS/queue.c **** #if( configUSE_MUTEXES == 1 )
1388:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xInheritanceOccurred = pdFALSE;
 2091              	 .loc 1 1388 0
 2092 0012 0023     	 movs r3,#0
 2093 0014 3B63     	 str r3,[r7,#48]
1389:../Dave/Generated/FREERTOS/queue.c **** #endif
1390:../Dave/Generated/FREERTOS/queue.c **** 
1391:../Dave/Generated/FREERTOS/queue.c **** 	/* Check the queue pointer is not NULL. */
1392:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( ( pxQueue ) );
 2094              	 .loc 1 1392 0
 2095 0016 FB6A     	 ldr r3,[r7,#44]
 2096 0018 002B     	 cmp r3,#0
 2097 001a 09D1     	 bne .L155
 2098              	.LBB160:
 2099              	.LBB161:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 2100              	 .loc 2 195 0 discriminator 1
 2101              	
 2102 001c 4FF0FC03 	 mov r3,#252
 2103 0020 83F31188 	 msr basepri,r3
 2104 0024 BFF36F8F 	 isb 
 2105 0028 BFF34F8F 	 dsb 
 2106              	
 2107              	
 2108              	 .thumb
 2109 002c 3B62     	 str r3,[r7,#32]
 2110              	.L156:
 2111              	.LBE161:
 2112              	.LBE160:
 2113              	 .loc 1 1392 0 discriminator 1
 2114 002e FEE7     	 b .L156
 2115              	.L155:
1393:../Dave/Generated/FREERTOS/queue.c **** 
1394:../Dave/Generated/FREERTOS/queue.c **** 	/* Check this really is a semaphore, in which case the item size will be
1395:../Dave/Generated/FREERTOS/queue.c **** 	0. */
1396:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue->uxItemSize == 0 );
 2116              	 .loc 1 1396 0
 2117 0030 FB6A     	 ldr r3,[r7,#44]
 2118 0032 1B6C     	 ldr r3,[r3,#64]
 2119 0034 002B     	 cmp r3,#0
 2120 0036 09D0     	 beq .L157
 2121              	.LBB162:
 2122              	.LBB163:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 2123              	 .loc 2 195 0 discriminator 1
 2124              	
 2125 0038 4FF0FC03 	 mov r3,#252
 2126 003c 83F31188 	 msr basepri,r3
 2127 0040 BFF36F8F 	 isb 
 2128 0044 BFF34F8F 	 dsb 
 2129              	
 2130              	
 2131              	 .thumb
 2132 0048 FB61     	 str r3,[r7,#28]
 2133              	.L158:
 2134              	.LBE163:
 2135              	.LBE162:
 2136              	 .loc 1 1396 0 discriminator 2
 2137 004a FEE7     	 b .L158
 2138              	.L157:
1397:../Dave/Generated/FREERTOS/queue.c **** 
1398:../Dave/Generated/FREERTOS/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1399:../Dave/Generated/FREERTOS/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1400:../Dave/Generated/FREERTOS/queue.c **** 	{
1401:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
 2139              	 .loc 1 1401 0
 2140 004c FFF7FEFF 	 bl xTaskGetSchedulerState
 2141 0050 0346     	 mov r3,r0
 2142 0052 002B     	 cmp r3,#0
 2143 0054 02D1     	 bne .L159
 2144              	 .loc 1 1401 0 is_stmt 0 discriminator 2
 2145 0056 3B68     	 ldr r3,[r7]
 2146 0058 002B     	 cmp r3,#0
 2147 005a 01D1     	 bne .L160
 2148              	.L159:
 2149              	 .loc 1 1401 0 discriminator 3
 2150 005c 0123     	 movs r3,#1
 2151 005e 00E0     	 b .L161
 2152              	.L160:
 2153              	 .loc 1 1401 0 discriminator 4
 2154 0060 0023     	 movs r3,#0
 2155              	.L161:
 2156              	 .loc 1 1401 0 discriminator 6
 2157 0062 002B     	 cmp r3,#0
 2158 0064 09D1     	 bne .L162
 2159              	.LBB164:
 2160              	.LBB165:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 2161              	 .loc 2 195 0 is_stmt 1 discriminator 7
 2162              	
 2163 0066 4FF0FC03 	 mov r3,#252
 2164 006a 83F31188 	 msr basepri,r3
 2165 006e BFF36F8F 	 isb 
 2166 0072 BFF34F8F 	 dsb 
 2167              	
 2168              	
 2169              	 .thumb
 2170 0076 BB61     	 str r3,[r7,#24]
 2171              	.L163:
 2172              	.LBE165:
 2173              	.LBE164:
 2174              	 .loc 1 1401 0 discriminator 3
 2175 0078 FEE7     	 b .L163
 2176              	.L162:
1402:../Dave/Generated/FREERTOS/queue.c **** 	}
1403:../Dave/Generated/FREERTOS/queue.c **** 	#endif
1404:../Dave/Generated/FREERTOS/queue.c **** 
1405:../Dave/Generated/FREERTOS/queue.c **** 
1406:../Dave/Generated/FREERTOS/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
1407:../Dave/Generated/FREERTOS/queue.c **** 	statements within the function itself.  This is done in the interest
1408:../Dave/Generated/FREERTOS/queue.c **** 	of execution time efficiency. */
1409:../Dave/Generated/FREERTOS/queue.c **** 
1410:../Dave/Generated/FREERTOS/queue.c **** 	for( ;; )
1411:../Dave/Generated/FREERTOS/queue.c **** 	{
1412:../Dave/Generated/FREERTOS/queue.c **** 		taskENTER_CRITICAL();
 2177              	 .loc 1 1412 0
 2178 007a FFF7FEFF 	 bl vPortEnterCritical
 2179              	.LBB166:
1413:../Dave/Generated/FREERTOS/queue.c **** 		{
1414:../Dave/Generated/FREERTOS/queue.c **** 			/* Semaphores are queues with an item size of 0, and where the
1415:../Dave/Generated/FREERTOS/queue.c **** 			number of messages in the queue is the semaphore's count value. */
1416:../Dave/Generated/FREERTOS/queue.c **** 			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 2180              	 .loc 1 1416 0
 2181 007e FB6A     	 ldr r3,[r7,#44]
 2182 0080 9B6B     	 ldr r3,[r3,#56]
 2183 0082 BB62     	 str r3,[r7,#40]
1417:../Dave/Generated/FREERTOS/queue.c **** 
1418:../Dave/Generated/FREERTOS/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1419:../Dave/Generated/FREERTOS/queue.c **** 			must be the highest priority task wanting to access the queue. */
1420:../Dave/Generated/FREERTOS/queue.c **** 			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 2184              	 .loc 1 1420 0
 2185 0084 BB6A     	 ldr r3,[r7,#40]
 2186 0086 002B     	 cmp r3,#0
 2187 0088 24D0     	 beq .L164
1421:../Dave/Generated/FREERTOS/queue.c **** 			{
1422:../Dave/Generated/FREERTOS/queue.c **** 				traceQUEUE_RECEIVE( pxQueue );
1423:../Dave/Generated/FREERTOS/queue.c **** 
1424:../Dave/Generated/FREERTOS/queue.c **** 				/* Semaphores are queues with a data size of zero and where the
1425:../Dave/Generated/FREERTOS/queue.c **** 				messages waiting is the semaphore's count.  Reduce the count. */
1426:../Dave/Generated/FREERTOS/queue.c **** 				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 2188              	 .loc 1 1426 0
 2189 008a BB6A     	 ldr r3,[r7,#40]
 2190 008c 5A1E     	 subs r2,r3,#1
 2191 008e FB6A     	 ldr r3,[r7,#44]
 2192 0090 9A63     	 str r2,[r3,#56]
1427:../Dave/Generated/FREERTOS/queue.c **** 
1428:../Dave/Generated/FREERTOS/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1429:../Dave/Generated/FREERTOS/queue.c **** 				{
1430:../Dave/Generated/FREERTOS/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 2193              	 .loc 1 1430 0
 2194 0092 FB6A     	 ldr r3,[r7,#44]
 2195 0094 1B68     	 ldr r3,[r3]
 2196 0096 002B     	 cmp r3,#0
 2197 0098 04D1     	 bne .L165
1431:../Dave/Generated/FREERTOS/queue.c **** 					{
1432:../Dave/Generated/FREERTOS/queue.c **** 						/* Record the information required to implement
1433:../Dave/Generated/FREERTOS/queue.c **** 						priority inheritance should it become necessary. */
1434:../Dave/Generated/FREERTOS/queue.c **** 						pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is n
 2198              	 .loc 1 1434 0
 2199 009a FFF7FEFF 	 bl pvTaskIncrementMutexHeldCount
 2200 009e 0246     	 mov r2,r0
 2201 00a0 FB6A     	 ldr r3,[r7,#44]
 2202 00a2 5A60     	 str r2,[r3,#4]
 2203              	.L165:
1435:../Dave/Generated/FREERTOS/queue.c **** 					}
1436:../Dave/Generated/FREERTOS/queue.c **** 					else
1437:../Dave/Generated/FREERTOS/queue.c **** 					{
1438:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1439:../Dave/Generated/FREERTOS/queue.c **** 					}
1440:../Dave/Generated/FREERTOS/queue.c **** 				}
1441:../Dave/Generated/FREERTOS/queue.c **** 				#endif /* configUSE_MUTEXES */
1442:../Dave/Generated/FREERTOS/queue.c **** 
1443:../Dave/Generated/FREERTOS/queue.c **** 				/* Check to see if other tasks are blocked waiting to give the
1444:../Dave/Generated/FREERTOS/queue.c **** 				semaphore, and if so, unblock the highest priority such task. */
1445:../Dave/Generated/FREERTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 2204              	 .loc 1 1445 0
 2205 00a4 FB6A     	 ldr r3,[r7,#44]
 2206 00a6 1B69     	 ldr r3,[r3,#16]
 2207 00a8 002B     	 cmp r3,#0
 2208 00aa 0FD0     	 beq .L166
1446:../Dave/Generated/FREERTOS/queue.c **** 				{
1447:../Dave/Generated/FREERTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 2209              	 .loc 1 1447 0
 2210 00ac FB6A     	 ldr r3,[r7,#44]
 2211 00ae 1033     	 adds r3,r3,#16
 2212 00b0 1846     	 mov r0,r3
 2213 00b2 FFF7FEFF 	 bl xTaskRemoveFromEventList
 2214 00b6 0346     	 mov r3,r0
 2215 00b8 002B     	 cmp r3,#0
 2216 00ba 07D0     	 beq .L166
1448:../Dave/Generated/FREERTOS/queue.c **** 					{
1449:../Dave/Generated/FREERTOS/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 2217              	 .loc 1 1449 0
 2218 00bc 544B     	 ldr r3,.L181
 2219 00be 4FF08052 	 mov r2,#268435456
 2220 00c2 1A60     	 str r2,[r3]
 2221              	
 2222 00c4 BFF34F8F 	 dsb
 2223              	
 2224              	
 2225 00c8 BFF36F8F 	 isb
 2226              	
 2227              	 .thumb
 2228              	.L166:
1450:../Dave/Generated/FREERTOS/queue.c **** 					}
1451:../Dave/Generated/FREERTOS/queue.c **** 					else
1452:../Dave/Generated/FREERTOS/queue.c **** 					{
1453:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1454:../Dave/Generated/FREERTOS/queue.c **** 					}
1455:../Dave/Generated/FREERTOS/queue.c **** 				}
1456:../Dave/Generated/FREERTOS/queue.c **** 				else
1457:../Dave/Generated/FREERTOS/queue.c **** 				{
1458:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1459:../Dave/Generated/FREERTOS/queue.c **** 				}
1460:../Dave/Generated/FREERTOS/queue.c **** 
1461:../Dave/Generated/FREERTOS/queue.c **** 				taskEXIT_CRITICAL();
 2229              	 .loc 1 1461 0
 2230 00cc FFF7FEFF 	 bl vPortExitCritical
1462:../Dave/Generated/FREERTOS/queue.c **** 				return pdPASS;
 2231              	 .loc 1 1462 0
 2232 00d0 0123     	 movs r3,#1
 2233 00d2 99E0     	 b .L180
 2234              	.L164:
1463:../Dave/Generated/FREERTOS/queue.c **** 			}
1464:../Dave/Generated/FREERTOS/queue.c **** 			else
1465:../Dave/Generated/FREERTOS/queue.c **** 			{
1466:../Dave/Generated/FREERTOS/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 2235              	 .loc 1 1466 0
 2236 00d4 3B68     	 ldr r3,[r7]
 2237 00d6 002B     	 cmp r3,#0
 2238 00d8 10D1     	 bne .L168
1467:../Dave/Generated/FREERTOS/queue.c **** 				{
1468:../Dave/Generated/FREERTOS/queue.c **** 					/* For inheritance to have occurred there must have been an
1469:../Dave/Generated/FREERTOS/queue.c **** 					initial timeout, and an adjusted timeout cannot become 0, as
1470:../Dave/Generated/FREERTOS/queue.c **** 					if it were 0 the function would have exited. */
1471:../Dave/Generated/FREERTOS/queue.c **** 					#if( configUSE_MUTEXES == 1 )
1472:../Dave/Generated/FREERTOS/queue.c **** 					{
1473:../Dave/Generated/FREERTOS/queue.c **** 						configASSERT( xInheritanceOccurred == pdFALSE );
 2239              	 .loc 1 1473 0
 2240 00da 3B6B     	 ldr r3,[r7,#48]
 2241 00dc 002B     	 cmp r3,#0
 2242 00de 09D0     	 beq .L169
 2243              	.LBB167:
 2244              	.LBB168:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 2245              	 .loc 2 195 0 discriminator 1
 2246              	
 2247 00e0 4FF0FC03 	 mov r3,#252
 2248 00e4 83F31188 	 msr basepri,r3
 2249 00e8 BFF36F8F 	 isb 
 2250 00ec BFF34F8F 	 dsb 
 2251              	
 2252              	
 2253              	 .thumb
 2254 00f0 7B61     	 str r3,[r7,#20]
 2255              	.L170:
 2256              	.LBE168:
 2257              	.LBE167:
 2258              	 .loc 1 1473 0 discriminator 4
 2259 00f2 FEE7     	 b .L170
 2260              	.L169:
1474:../Dave/Generated/FREERTOS/queue.c **** 					}
1475:../Dave/Generated/FREERTOS/queue.c **** 					#endif /* configUSE_MUTEXES */
1476:../Dave/Generated/FREERTOS/queue.c **** 
1477:../Dave/Generated/FREERTOS/queue.c **** 					/* The semaphore count was 0 and no block time is specified
1478:../Dave/Generated/FREERTOS/queue.c **** 					(or the block time has expired) so exit now. */
1479:../Dave/Generated/FREERTOS/queue.c **** 					taskEXIT_CRITICAL();
 2261              	 .loc 1 1479 0
 2262 00f4 FFF7FEFF 	 bl vPortExitCritical
1480:../Dave/Generated/FREERTOS/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1481:../Dave/Generated/FREERTOS/queue.c **** 					return errQUEUE_EMPTY;
 2263              	 .loc 1 1481 0
 2264 00f8 0023     	 movs r3,#0
 2265 00fa 85E0     	 b .L180
 2266              	.L168:
1482:../Dave/Generated/FREERTOS/queue.c **** 				}
1483:../Dave/Generated/FREERTOS/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 2267              	 .loc 1 1483 0
 2268 00fc 7B6B     	 ldr r3,[r7,#52]
 2269 00fe 002B     	 cmp r3,#0
 2270 0100 06D1     	 bne .L171
1484:../Dave/Generated/FREERTOS/queue.c **** 				{
1485:../Dave/Generated/FREERTOS/queue.c **** 					/* The semaphore count was 0 and a block time was specified
1486:../Dave/Generated/FREERTOS/queue.c **** 					so configure the timeout structure ready to block. */
1487:../Dave/Generated/FREERTOS/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
 2271              	 .loc 1 1487 0
 2272 0102 07F10C03 	 add r3,r7,#12
 2273 0106 1846     	 mov r0,r3
 2274 0108 FFF7FEFF 	 bl vTaskInternalSetTimeOutState
1488:../Dave/Generated/FREERTOS/queue.c **** 					xEntryTimeSet = pdTRUE;
 2275              	 .loc 1 1488 0
 2276 010c 0123     	 movs r3,#1
 2277 010e 7B63     	 str r3,[r7,#52]
 2278              	.L171:
 2279              	.LBE166:
1489:../Dave/Generated/FREERTOS/queue.c **** 				}
1490:../Dave/Generated/FREERTOS/queue.c **** 				else
1491:../Dave/Generated/FREERTOS/queue.c **** 				{
1492:../Dave/Generated/FREERTOS/queue.c **** 					/* Entry time was already set. */
1493:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1494:../Dave/Generated/FREERTOS/queue.c **** 				}
1495:../Dave/Generated/FREERTOS/queue.c **** 			}
1496:../Dave/Generated/FREERTOS/queue.c **** 		}
1497:../Dave/Generated/FREERTOS/queue.c **** 		taskEXIT_CRITICAL();
 2280              	 .loc 1 1497 0
 2281 0110 FFF7FEFF 	 bl vPortExitCritical
1498:../Dave/Generated/FREERTOS/queue.c **** 
1499:../Dave/Generated/FREERTOS/queue.c **** 		/* Interrupts and other tasks can give to and take from the semaphore
1500:../Dave/Generated/FREERTOS/queue.c **** 		now the critical section has been exited. */
1501:../Dave/Generated/FREERTOS/queue.c **** 
1502:../Dave/Generated/FREERTOS/queue.c **** 		vTaskSuspendAll();
 2282              	 .loc 1 1502 0
 2283 0114 FFF7FEFF 	 bl vTaskSuspendAll
1503:../Dave/Generated/FREERTOS/queue.c **** 		prvLockQueue( pxQueue );
 2284              	 .loc 1 1503 0
 2285 0118 FFF7FEFF 	 bl vPortEnterCritical
 2286 011c FB6A     	 ldr r3,[r7,#44]
 2287 011e 93F84430 	 ldrb r3,[r3,#68]
 2288 0122 DBB2     	 uxtb r3,r3
 2289 0124 5BB2     	 sxtb r3,r3
 2290 0126 B3F1FF3F 	 cmp r3,#-1
 2291 012a 03D1     	 bne .L172
 2292              	 .loc 1 1503 0 is_stmt 0 discriminator 1
 2293 012c FB6A     	 ldr r3,[r7,#44]
 2294 012e 0022     	 movs r2,#0
 2295 0130 83F84420 	 strb r2,[r3,#68]
 2296              	.L172:
 2297              	 .loc 1 1503 0 discriminator 3
 2298 0134 FB6A     	 ldr r3,[r7,#44]
 2299 0136 93F84530 	 ldrb r3,[r3,#69]
 2300 013a DBB2     	 uxtb r3,r3
 2301 013c 5BB2     	 sxtb r3,r3
 2302 013e B3F1FF3F 	 cmp r3,#-1
 2303 0142 03D1     	 bne .L173
 2304              	 .loc 1 1503 0 discriminator 4
 2305 0144 FB6A     	 ldr r3,[r7,#44]
 2306 0146 0022     	 movs r2,#0
 2307 0148 83F84520 	 strb r2,[r3,#69]
 2308              	.L173:
 2309              	 .loc 1 1503 0 discriminator 6
 2310 014c FFF7FEFF 	 bl vPortExitCritical
1504:../Dave/Generated/FREERTOS/queue.c **** 
1505:../Dave/Generated/FREERTOS/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1506:../Dave/Generated/FREERTOS/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 2311              	 .loc 1 1506 0 is_stmt 1 discriminator 6
 2312 0150 07F10C02 	 add r2,r7,#12
 2313 0154 3B46     	 mov r3,r7
 2314 0156 1046     	 mov r0,r2
 2315 0158 1946     	 mov r1,r3
 2316 015a FFF7FEFF 	 bl xTaskCheckForTimeOut
 2317 015e 0346     	 mov r3,r0
 2318 0160 002B     	 cmp r3,#0
 2319 0162 32D1     	 bne .L174
1507:../Dave/Generated/FREERTOS/queue.c **** 		{
1508:../Dave/Generated/FREERTOS/queue.c **** 			/* A block time is specified and not expired.  If the semaphore
1509:../Dave/Generated/FREERTOS/queue.c **** 			count is 0 then enter the Blocked state to wait for a semaphore to
1510:../Dave/Generated/FREERTOS/queue.c **** 			become available.  As semaphores are implemented with queues the
1511:../Dave/Generated/FREERTOS/queue.c **** 			queue being empty is equivalent to the semaphore count being 0. */
1512:../Dave/Generated/FREERTOS/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 2320              	 .loc 1 1512 0
 2321 0164 F86A     	 ldr r0,[r7,#44]
 2322 0166 FFF7FEFF 	 bl prvIsQueueEmpty
 2323 016a 0346     	 mov r3,r0
 2324 016c 002B     	 cmp r3,#0
 2325 016e 26D0     	 beq .L175
1513:../Dave/Generated/FREERTOS/queue.c **** 			{
1514:../Dave/Generated/FREERTOS/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1515:../Dave/Generated/FREERTOS/queue.c **** 
1516:../Dave/Generated/FREERTOS/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1517:../Dave/Generated/FREERTOS/queue.c **** 				{
1518:../Dave/Generated/FREERTOS/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 2326              	 .loc 1 1518 0
 2327 0170 FB6A     	 ldr r3,[r7,#44]
 2328 0172 1B68     	 ldr r3,[r3]
 2329 0174 002B     	 cmp r3,#0
 2330 0176 09D1     	 bne .L176
1519:../Dave/Generated/FREERTOS/queue.c **** 					{
1520:../Dave/Generated/FREERTOS/queue.c **** 						taskENTER_CRITICAL();
 2331              	 .loc 1 1520 0
 2332 0178 FFF7FEFF 	 bl vPortEnterCritical
1521:../Dave/Generated/FREERTOS/queue.c **** 						{
1522:../Dave/Generated/FREERTOS/queue.c **** 							xInheritanceOccurred = xTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 2333              	 .loc 1 1522 0
 2334 017c FB6A     	 ldr r3,[r7,#44]
 2335 017e 5B68     	 ldr r3,[r3,#4]
 2336 0180 1846     	 mov r0,r3
 2337 0182 FFF7FEFF 	 bl xTaskPriorityInherit
 2338 0186 3863     	 str r0,[r7,#48]
1523:../Dave/Generated/FREERTOS/queue.c **** 						}
1524:../Dave/Generated/FREERTOS/queue.c **** 						taskEXIT_CRITICAL();
 2339              	 .loc 1 1524 0
 2340 0188 FFF7FEFF 	 bl vPortExitCritical
 2341              	.L176:
1525:../Dave/Generated/FREERTOS/queue.c **** 					}
1526:../Dave/Generated/FREERTOS/queue.c **** 					else
1527:../Dave/Generated/FREERTOS/queue.c **** 					{
1528:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1529:../Dave/Generated/FREERTOS/queue.c **** 					}
1530:../Dave/Generated/FREERTOS/queue.c **** 				}
1531:../Dave/Generated/FREERTOS/queue.c **** 				#endif
1532:../Dave/Generated/FREERTOS/queue.c **** 
1533:../Dave/Generated/FREERTOS/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 2342              	 .loc 1 1533 0
 2343 018c FB6A     	 ldr r3,[r7,#44]
 2344 018e 03F12402 	 add r2,r3,#36
 2345 0192 3B68     	 ldr r3,[r7]
 2346 0194 1046     	 mov r0,r2
 2347 0196 1946     	 mov r1,r3
 2348 0198 FFF7FEFF 	 bl vTaskPlaceOnEventList
1534:../Dave/Generated/FREERTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 2349              	 .loc 1 1534 0
 2350 019c F86A     	 ldr r0,[r7,#44]
 2351 019e FFF7FEFF 	 bl prvUnlockQueue
1535:../Dave/Generated/FREERTOS/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 2352              	 .loc 1 1535 0
 2353 01a2 FFF7FEFF 	 bl xTaskResumeAll
 2354 01a6 0346     	 mov r3,r0
 2355 01a8 002B     	 cmp r3,#0
 2356 01aa 2CD1     	 bne .L178
1536:../Dave/Generated/FREERTOS/queue.c **** 				{
1537:../Dave/Generated/FREERTOS/queue.c **** 					portYIELD_WITHIN_API();
 2357              	 .loc 1 1537 0
 2358 01ac 184B     	 ldr r3,.L181
 2359 01ae 4FF08052 	 mov r2,#268435456
 2360 01b2 1A60     	 str r2,[r3]
 2361              	
 2362 01b4 BFF34F8F 	 dsb
 2363              	
 2364              	
 2365 01b8 BFF36F8F 	 isb
 2366              	
 2367              	 .thumb
 2368 01bc 23E0     	 b .L178
 2369              	.L175:
1538:../Dave/Generated/FREERTOS/queue.c **** 				}
1539:../Dave/Generated/FREERTOS/queue.c **** 				else
1540:../Dave/Generated/FREERTOS/queue.c **** 				{
1541:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1542:../Dave/Generated/FREERTOS/queue.c **** 				}
1543:../Dave/Generated/FREERTOS/queue.c **** 			}
1544:../Dave/Generated/FREERTOS/queue.c **** 			else
1545:../Dave/Generated/FREERTOS/queue.c **** 			{
1546:../Dave/Generated/FREERTOS/queue.c **** 				/* There was no timeout and the semaphore count was not 0, so
1547:../Dave/Generated/FREERTOS/queue.c **** 				attempt to take the semaphore again. */
1548:../Dave/Generated/FREERTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 2370              	 .loc 1 1548 0
 2371 01be F86A     	 ldr r0,[r7,#44]
 2372 01c0 FFF7FEFF 	 bl prvUnlockQueue
1549:../Dave/Generated/FREERTOS/queue.c **** 				( void ) xTaskResumeAll();
 2373              	 .loc 1 1549 0
 2374 01c4 FFF7FEFF 	 bl xTaskResumeAll
 2375 01c8 57E7     	 b .L162
 2376              	.L174:
1550:../Dave/Generated/FREERTOS/queue.c **** 			}
1551:../Dave/Generated/FREERTOS/queue.c **** 		}
1552:../Dave/Generated/FREERTOS/queue.c **** 		else
1553:../Dave/Generated/FREERTOS/queue.c **** 		{
1554:../Dave/Generated/FREERTOS/queue.c **** 			/* Timed out. */
1555:../Dave/Generated/FREERTOS/queue.c **** 			prvUnlockQueue( pxQueue );
 2377              	 .loc 1 1555 0
 2378 01ca F86A     	 ldr r0,[r7,#44]
 2379 01cc FFF7FEFF 	 bl prvUnlockQueue
1556:../Dave/Generated/FREERTOS/queue.c **** 			( void ) xTaskResumeAll();
 2380              	 .loc 1 1556 0
 2381 01d0 FFF7FEFF 	 bl xTaskResumeAll
1557:../Dave/Generated/FREERTOS/queue.c **** 
1558:../Dave/Generated/FREERTOS/queue.c **** 			/* If the semaphore count is 0 exit now as the timeout has
1559:../Dave/Generated/FREERTOS/queue.c **** 			expired.  Otherwise return to attempt to take the semaphore that is
1560:../Dave/Generated/FREERTOS/queue.c **** 			known to be available.  As semaphores are implemented by queues the
1561:../Dave/Generated/FREERTOS/queue.c **** 			queue being empty is equivalent to the semaphore count being 0. */
1562:../Dave/Generated/FREERTOS/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 2382              	 .loc 1 1562 0
 2383 01d4 F86A     	 ldr r0,[r7,#44]
 2384 01d6 FFF7FEFF 	 bl prvIsQueueEmpty
 2385 01da 0346     	 mov r3,r0
 2386 01dc 002B     	 cmp r3,#0
 2387 01de 12D0     	 beq .L178
1563:../Dave/Generated/FREERTOS/queue.c **** 			{
1564:../Dave/Generated/FREERTOS/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1565:../Dave/Generated/FREERTOS/queue.c **** 				{
1566:../Dave/Generated/FREERTOS/queue.c **** 					/* xInheritanceOccurred could only have be set if
1567:../Dave/Generated/FREERTOS/queue.c **** 					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
1568:../Dave/Generated/FREERTOS/queue.c **** 					test the mutex type again to check it is actually a mutex. */
1569:../Dave/Generated/FREERTOS/queue.c **** 					if( xInheritanceOccurred != pdFALSE )
 2388              	 .loc 1 1569 0
 2389 01e0 3B6B     	 ldr r3,[r7,#48]
 2390 01e2 002B     	 cmp r3,#0
 2391 01e4 0DD0     	 beq .L179
1570:../Dave/Generated/FREERTOS/queue.c **** 					{
1571:../Dave/Generated/FREERTOS/queue.c **** 						taskENTER_CRITICAL();
 2392              	 .loc 1 1571 0
 2393 01e6 FFF7FEFF 	 bl vPortEnterCritical
 2394              	.LBB169:
1572:../Dave/Generated/FREERTOS/queue.c **** 						{
1573:../Dave/Generated/FREERTOS/queue.c **** 							UBaseType_t uxHighestWaitingPriority;
1574:../Dave/Generated/FREERTOS/queue.c **** 
1575:../Dave/Generated/FREERTOS/queue.c **** 							/* This task blocking on the mutex caused another
1576:../Dave/Generated/FREERTOS/queue.c **** 							task to inherit this task's priority.  Now this task
1577:../Dave/Generated/FREERTOS/queue.c **** 							has timed out the priority should be disinherited
1578:../Dave/Generated/FREERTOS/queue.c **** 							again, but only as low as the next highest priority
1579:../Dave/Generated/FREERTOS/queue.c **** 							task that is waiting for the same mutex. */
1580:../Dave/Generated/FREERTOS/queue.c **** 							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
 2395              	 .loc 1 1580 0
 2396 01ea F86A     	 ldr r0,[r7,#44]
 2397 01ec FFF7FEFF 	 bl prvGetDisinheritPriorityAfterTimeout
 2398 01f0 7862     	 str r0,[r7,#36]
1581:../Dave/Generated/FREERTOS/queue.c **** 							vTaskPriorityDisinheritAfterTimeout( ( void * ) pxQueue->pxMutexHolder, uxHighestWaitingPrio
 2399              	 .loc 1 1581 0
 2400 01f2 FB6A     	 ldr r3,[r7,#44]
 2401 01f4 5B68     	 ldr r3,[r3,#4]
 2402 01f6 1846     	 mov r0,r3
 2403 01f8 796A     	 ldr r1,[r7,#36]
 2404 01fa FFF7FEFF 	 bl vTaskPriorityDisinheritAfterTimeout
 2405              	.LBE169:
1582:../Dave/Generated/FREERTOS/queue.c **** 						}
1583:../Dave/Generated/FREERTOS/queue.c **** 						taskEXIT_CRITICAL();
 2406              	 .loc 1 1583 0
 2407 01fe FFF7FEFF 	 bl vPortExitCritical
 2408              	.L179:
1584:../Dave/Generated/FREERTOS/queue.c **** 					}
1585:../Dave/Generated/FREERTOS/queue.c **** 				}
1586:../Dave/Generated/FREERTOS/queue.c **** 				#endif /* configUSE_MUTEXES */
1587:../Dave/Generated/FREERTOS/queue.c **** 
1588:../Dave/Generated/FREERTOS/queue.c **** 				traceQUEUE_RECEIVE_FAILED( pxQueue );
1589:../Dave/Generated/FREERTOS/queue.c **** 				return errQUEUE_EMPTY;
 2409              	 .loc 1 1589 0
 2410 0202 0023     	 movs r3,#0
 2411 0204 00E0     	 b .L180
 2412              	.L178:
1590:../Dave/Generated/FREERTOS/queue.c **** 			}
1591:../Dave/Generated/FREERTOS/queue.c **** 			else
1592:../Dave/Generated/FREERTOS/queue.c **** 			{
1593:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1594:../Dave/Generated/FREERTOS/queue.c **** 			}
1595:../Dave/Generated/FREERTOS/queue.c **** 		}
1596:../Dave/Generated/FREERTOS/queue.c **** 	}
 2413              	 .loc 1 1596 0 discriminator 6
 2414 0206 38E7     	 b .L162
 2415              	.L180:
1597:../Dave/Generated/FREERTOS/queue.c **** }
 2416              	 .loc 1 1597 0 discriminator 7
 2417 0208 1846     	 mov r0,r3
 2418 020a 3837     	 adds r7,r7,#56
 2419              	 .cfi_def_cfa_offset 8
 2420 020c BD46     	 mov sp,r7
 2421              	 .cfi_def_cfa_register 13
 2422              	 
 2423 020e 80BD     	 pop {r7,pc}
 2424              	.L182:
 2425              	 .align 2
 2426              	.L181:
 2427 0210 04ED00E0 	 .word -536810236
 2428              	 .cfi_endproc
 2429              	.LFE151:
 2431              	 .section .text.xQueuePeek,"ax",%progbits
 2432              	 .align 2
 2433              	 .global xQueuePeek
 2434              	 .thumb
 2435              	 .thumb_func
 2437              	xQueuePeek:
 2438              	.LFB152:
1598:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
1599:../Dave/Generated/FREERTOS/queue.c **** 
1600:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
1601:../Dave/Generated/FREERTOS/queue.c **** {
 2439              	 .loc 1 1601 0
 2440              	 .cfi_startproc
 2441              	 
 2442              	 
 2443 0000 80B5     	 push {r7,lr}
 2444              	 .cfi_def_cfa_offset 8
 2445              	 .cfi_offset 7,-8
 2446              	 .cfi_offset 14,-4
 2447 0002 8EB0     	 sub sp,sp,#56
 2448              	 .cfi_def_cfa_offset 64
 2449 0004 00AF     	 add r7,sp,#0
 2450              	 .cfi_def_cfa_register 7
 2451 0006 F860     	 str r0,[r7,#12]
 2452 0008 B960     	 str r1,[r7,#8]
 2453 000a 7A60     	 str r2,[r7,#4]
1602:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 2454              	 .loc 1 1602 0
 2455 000c 0023     	 movs r3,#0
 2456 000e 7B63     	 str r3,[r7,#52]
1603:../Dave/Generated/FREERTOS/queue.c **** TimeOut_t xTimeOut;
1604:../Dave/Generated/FREERTOS/queue.c **** int8_t *pcOriginalReadPosition;
1605:../Dave/Generated/FREERTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 2457              	 .loc 1 1605 0
 2458 0010 FB68     	 ldr r3,[r7,#12]
 2459 0012 3B63     	 str r3,[r7,#48]
1606:../Dave/Generated/FREERTOS/queue.c **** 
1607:../Dave/Generated/FREERTOS/queue.c **** 	/* Check the pointer is not NULL. */
1608:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( ( pxQueue ) );
 2460              	 .loc 1 1608 0
 2461 0014 3B6B     	 ldr r3,[r7,#48]
 2462 0016 002B     	 cmp r3,#0
 2463 0018 09D1     	 bne .L184
 2464              	.LBB170:
 2465              	.LBB171:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 2466              	 .loc 2 195 0 discriminator 1
 2467              	
 2468 001a 4FF0FC03 	 mov r3,#252
 2469 001e 83F31188 	 msr basepri,r3
 2470 0022 BFF36F8F 	 isb 
 2471 0026 BFF34F8F 	 dsb 
 2472              	
 2473              	
 2474              	 .thumb
 2475 002a 7B62     	 str r3,[r7,#36]
 2476              	.L185:
 2477              	.LBE171:
 2478              	.LBE170:
 2479              	 .loc 1 1608 0 discriminator 1
 2480 002c FEE7     	 b .L185
 2481              	.L184:
1609:../Dave/Generated/FREERTOS/queue.c **** 
1610:../Dave/Generated/FREERTOS/queue.c **** 	/* The buffer into which data is received can only be NULL if the data size
1611:../Dave/Generated/FREERTOS/queue.c **** 	is zero (so no data is copied into the buffer. */
1612:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) )
 2482              	 .loc 1 1612 0
 2483 002e BB68     	 ldr r3,[r7,#8]
 2484 0030 002B     	 cmp r3,#0
 2485 0032 03D1     	 bne .L186
 2486              	 .loc 1 1612 0 is_stmt 0 discriminator 2
 2487 0034 3B6B     	 ldr r3,[r7,#48]
 2488 0036 1B6C     	 ldr r3,[r3,#64]
 2489 0038 002B     	 cmp r3,#0
 2490 003a 01D1     	 bne .L187
 2491              	.L186:
 2492              	 .loc 1 1612 0 discriminator 3
 2493 003c 0123     	 movs r3,#1
 2494 003e 00E0     	 b .L188
 2495              	.L187:
 2496              	 .loc 1 1612 0 discriminator 4
 2497 0040 0023     	 movs r3,#0
 2498              	.L188:
 2499              	 .loc 1 1612 0 discriminator 6
 2500 0042 002B     	 cmp r3,#0
 2501 0044 09D1     	 bne .L189
 2502              	.LBB172:
 2503              	.LBB173:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 2504              	 .loc 2 195 0 is_stmt 1 discriminator 7
 2505              	
 2506 0046 4FF0FC03 	 mov r3,#252
 2507 004a 83F31188 	 msr basepri,r3
 2508 004e BFF36F8F 	 isb 
 2509 0052 BFF34F8F 	 dsb 
 2510              	
 2511              	
 2512              	 .thumb
 2513 0056 3B62     	 str r3,[r7,#32]
 2514              	.L190:
 2515              	.LBE173:
 2516              	.LBE172:
 2517              	 .loc 1 1612 0 discriminator 2
 2518 0058 FEE7     	 b .L190
 2519              	.L189:
1613:../Dave/Generated/FREERTOS/queue.c **** 
1614:../Dave/Generated/FREERTOS/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1615:../Dave/Generated/FREERTOS/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1616:../Dave/Generated/FREERTOS/queue.c **** 	{
1617:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
 2520              	 .loc 1 1617 0
 2521 005a FFF7FEFF 	 bl xTaskGetSchedulerState
 2522 005e 0346     	 mov r3,r0
 2523 0060 002B     	 cmp r3,#0
 2524 0062 02D1     	 bne .L191
 2525              	 .loc 1 1617 0 is_stmt 0 discriminator 2
 2526 0064 7B68     	 ldr r3,[r7,#4]
 2527 0066 002B     	 cmp r3,#0
 2528 0068 01D1     	 bne .L192
 2529              	.L191:
 2530              	 .loc 1 1617 0 discriminator 3
 2531 006a 0123     	 movs r3,#1
 2532 006c 00E0     	 b .L193
 2533              	.L192:
 2534              	 .loc 1 1617 0 discriminator 4
 2535 006e 0023     	 movs r3,#0
 2536              	.L193:
 2537              	 .loc 1 1617 0 discriminator 6
 2538 0070 002B     	 cmp r3,#0
 2539 0072 09D1     	 bne .L194
 2540              	.LBB174:
 2541              	.LBB175:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 2542              	 .loc 2 195 0 is_stmt 1 discriminator 7
 2543              	
 2544 0074 4FF0FC03 	 mov r3,#252
 2545 0078 83F31188 	 msr basepri,r3
 2546 007c BFF36F8F 	 isb 
 2547 0080 BFF34F8F 	 dsb 
 2548              	
 2549              	
 2550              	 .thumb
 2551 0084 FB61     	 str r3,[r7,#28]
 2552              	.L195:
 2553              	.LBE175:
 2554              	.LBE174:
 2555              	 .loc 1 1617 0 discriminator 3
 2556 0086 FEE7     	 b .L195
 2557              	.L194:
1618:../Dave/Generated/FREERTOS/queue.c **** 	}
1619:../Dave/Generated/FREERTOS/queue.c **** 	#endif
1620:../Dave/Generated/FREERTOS/queue.c **** 
1621:../Dave/Generated/FREERTOS/queue.c **** 
1622:../Dave/Generated/FREERTOS/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
1623:../Dave/Generated/FREERTOS/queue.c **** 	statements within the function itself.  This is done in the interest
1624:../Dave/Generated/FREERTOS/queue.c **** 	of execution time efficiency. */
1625:../Dave/Generated/FREERTOS/queue.c **** 
1626:../Dave/Generated/FREERTOS/queue.c **** 	for( ;; )
1627:../Dave/Generated/FREERTOS/queue.c **** 	{
1628:../Dave/Generated/FREERTOS/queue.c **** 		taskENTER_CRITICAL();
 2558              	 .loc 1 1628 0
 2559 0088 FFF7FEFF 	 bl vPortEnterCritical
 2560              	.LBB176:
1629:../Dave/Generated/FREERTOS/queue.c **** 		{
1630:../Dave/Generated/FREERTOS/queue.c **** 			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 2561              	 .loc 1 1630 0
 2562 008c 3B6B     	 ldr r3,[r7,#48]
 2563 008e 9B6B     	 ldr r3,[r3,#56]
 2564 0090 FB62     	 str r3,[r7,#44]
1631:../Dave/Generated/FREERTOS/queue.c **** 
1632:../Dave/Generated/FREERTOS/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1633:../Dave/Generated/FREERTOS/queue.c **** 			must be the highest priority task wanting to access the queue. */
1634:../Dave/Generated/FREERTOS/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 2565              	 .loc 1 1634 0
 2566 0092 FB6A     	 ldr r3,[r7,#44]
 2567 0094 002B     	 cmp r3,#0
 2568 0096 21D0     	 beq .L196
1635:../Dave/Generated/FREERTOS/queue.c **** 			{
1636:../Dave/Generated/FREERTOS/queue.c **** 				/* Remember the read position so it can be reset after the data
1637:../Dave/Generated/FREERTOS/queue.c **** 				is read from the queue as this function is only peeking the
1638:../Dave/Generated/FREERTOS/queue.c **** 				data, not removing it. */
1639:../Dave/Generated/FREERTOS/queue.c **** 				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 2569              	 .loc 1 1639 0
 2570 0098 3B6B     	 ldr r3,[r7,#48]
 2571 009a DB68     	 ldr r3,[r3,#12]
 2572 009c BB62     	 str r3,[r7,#40]
1640:../Dave/Generated/FREERTOS/queue.c **** 
1641:../Dave/Generated/FREERTOS/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 2573              	 .loc 1 1641 0
 2574 009e 386B     	 ldr r0,[r7,#48]
 2575 00a0 B968     	 ldr r1,[r7,#8]
 2576 00a2 FFF7FEFF 	 bl prvCopyDataFromQueue
1642:../Dave/Generated/FREERTOS/queue.c **** 				traceQUEUE_PEEK( pxQueue );
1643:../Dave/Generated/FREERTOS/queue.c **** 
1644:../Dave/Generated/FREERTOS/queue.c **** 				/* The data is not being removed, so reset the read pointer. */
1645:../Dave/Generated/FREERTOS/queue.c **** 				pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 2577              	 .loc 1 1645 0
 2578 00a6 3B6B     	 ldr r3,[r7,#48]
 2579 00a8 BA6A     	 ldr r2,[r7,#40]
 2580 00aa DA60     	 str r2,[r3,#12]
1646:../Dave/Generated/FREERTOS/queue.c **** 
1647:../Dave/Generated/FREERTOS/queue.c **** 				/* The data is being left in the queue, so see if there are
1648:../Dave/Generated/FREERTOS/queue.c **** 				any other tasks waiting for the data. */
1649:../Dave/Generated/FREERTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 2581              	 .loc 1 1649 0
 2582 00ac 3B6B     	 ldr r3,[r7,#48]
 2583 00ae 5B6A     	 ldr r3,[r3,#36]
 2584 00b0 002B     	 cmp r3,#0
 2585 00b2 0FD0     	 beq .L197
1650:../Dave/Generated/FREERTOS/queue.c **** 				{
1651:../Dave/Generated/FREERTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 2586              	 .loc 1 1651 0
 2587 00b4 3B6B     	 ldr r3,[r7,#48]
 2588 00b6 2433     	 adds r3,r3,#36
 2589 00b8 1846     	 mov r0,r3
 2590 00ba FFF7FEFF 	 bl xTaskRemoveFromEventList
 2591 00be 0346     	 mov r3,r0
 2592 00c0 002B     	 cmp r3,#0
 2593 00c2 07D0     	 beq .L197
1652:../Dave/Generated/FREERTOS/queue.c **** 					{
1653:../Dave/Generated/FREERTOS/queue.c **** 						/* The task waiting has a higher priority than this task. */
1654:../Dave/Generated/FREERTOS/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 2594              	 .loc 1 1654 0
 2595 00c4 3E4B     	 ldr r3,.L208
 2596 00c6 4FF08052 	 mov r2,#268435456
 2597 00ca 1A60     	 str r2,[r3]
 2598              	
 2599 00cc BFF34F8F 	 dsb
 2600              	
 2601              	
 2602 00d0 BFF36F8F 	 isb
 2603              	
 2604              	 .thumb
 2605              	.L197:
1655:../Dave/Generated/FREERTOS/queue.c **** 					}
1656:../Dave/Generated/FREERTOS/queue.c **** 					else
1657:../Dave/Generated/FREERTOS/queue.c **** 					{
1658:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1659:../Dave/Generated/FREERTOS/queue.c **** 					}
1660:../Dave/Generated/FREERTOS/queue.c **** 				}
1661:../Dave/Generated/FREERTOS/queue.c **** 				else
1662:../Dave/Generated/FREERTOS/queue.c **** 				{
1663:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1664:../Dave/Generated/FREERTOS/queue.c **** 				}
1665:../Dave/Generated/FREERTOS/queue.c **** 
1666:../Dave/Generated/FREERTOS/queue.c **** 				taskEXIT_CRITICAL();
 2606              	 .loc 1 1666 0
 2607 00d4 FFF7FEFF 	 bl vPortExitCritical
1667:../Dave/Generated/FREERTOS/queue.c **** 				return pdPASS;
 2608              	 .loc 1 1667 0
 2609 00d8 0123     	 movs r3,#1
 2610 00da 6DE0     	 b .L207
 2611              	.L196:
1668:../Dave/Generated/FREERTOS/queue.c **** 			}
1669:../Dave/Generated/FREERTOS/queue.c **** 			else
1670:../Dave/Generated/FREERTOS/queue.c **** 			{
1671:../Dave/Generated/FREERTOS/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 2612              	 .loc 1 1671 0
 2613 00dc 7B68     	 ldr r3,[r7,#4]
 2614 00de 002B     	 cmp r3,#0
 2615 00e0 03D1     	 bne .L199
1672:../Dave/Generated/FREERTOS/queue.c **** 				{
1673:../Dave/Generated/FREERTOS/queue.c **** 					/* The queue was empty and no block time is specified (or
1674:../Dave/Generated/FREERTOS/queue.c **** 					the block time has expired) so leave now. */
1675:../Dave/Generated/FREERTOS/queue.c **** 					taskEXIT_CRITICAL();
 2616              	 .loc 1 1675 0
 2617 00e2 FFF7FEFF 	 bl vPortExitCritical
1676:../Dave/Generated/FREERTOS/queue.c **** 					traceQUEUE_PEEK_FAILED( pxQueue );
1677:../Dave/Generated/FREERTOS/queue.c **** 					return errQUEUE_EMPTY;
 2618              	 .loc 1 1677 0
 2619 00e6 0023     	 movs r3,#0
 2620 00e8 66E0     	 b .L207
 2621              	.L199:
1678:../Dave/Generated/FREERTOS/queue.c **** 				}
1679:../Dave/Generated/FREERTOS/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 2622              	 .loc 1 1679 0
 2623 00ea 7B6B     	 ldr r3,[r7,#52]
 2624 00ec 002B     	 cmp r3,#0
 2625 00ee 06D1     	 bne .L200
1680:../Dave/Generated/FREERTOS/queue.c **** 				{
1681:../Dave/Generated/FREERTOS/queue.c **** 					/* The queue was empty and a block time was specified so
1682:../Dave/Generated/FREERTOS/queue.c **** 					configure the timeout structure ready to enter the blocked
1683:../Dave/Generated/FREERTOS/queue.c **** 					state. */
1684:../Dave/Generated/FREERTOS/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
 2626              	 .loc 1 1684 0
 2627 00f0 07F11403 	 add r3,r7,#20
 2628 00f4 1846     	 mov r0,r3
 2629 00f6 FFF7FEFF 	 bl vTaskInternalSetTimeOutState
1685:../Dave/Generated/FREERTOS/queue.c **** 					xEntryTimeSet = pdTRUE;
 2630              	 .loc 1 1685 0
 2631 00fa 0123     	 movs r3,#1
 2632 00fc 7B63     	 str r3,[r7,#52]
 2633              	.L200:
 2634              	.LBE176:
1686:../Dave/Generated/FREERTOS/queue.c **** 				}
1687:../Dave/Generated/FREERTOS/queue.c **** 				else
1688:../Dave/Generated/FREERTOS/queue.c **** 				{
1689:../Dave/Generated/FREERTOS/queue.c **** 					/* Entry time was already set. */
1690:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1691:../Dave/Generated/FREERTOS/queue.c **** 				}
1692:../Dave/Generated/FREERTOS/queue.c **** 			}
1693:../Dave/Generated/FREERTOS/queue.c **** 		}
1694:../Dave/Generated/FREERTOS/queue.c **** 		taskEXIT_CRITICAL();
 2635              	 .loc 1 1694 0
 2636 00fe FFF7FEFF 	 bl vPortExitCritical
1695:../Dave/Generated/FREERTOS/queue.c **** 
1696:../Dave/Generated/FREERTOS/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1697:../Dave/Generated/FREERTOS/queue.c **** 		now the critical section has been exited. */
1698:../Dave/Generated/FREERTOS/queue.c **** 
1699:../Dave/Generated/FREERTOS/queue.c **** 		vTaskSuspendAll();
 2637              	 .loc 1 1699 0
 2638 0102 FFF7FEFF 	 bl vTaskSuspendAll
1700:../Dave/Generated/FREERTOS/queue.c **** 		prvLockQueue( pxQueue );
 2639              	 .loc 1 1700 0
 2640 0106 FFF7FEFF 	 bl vPortEnterCritical
 2641 010a 3B6B     	 ldr r3,[r7,#48]
 2642 010c 93F84430 	 ldrb r3,[r3,#68]
 2643 0110 DBB2     	 uxtb r3,r3
 2644 0112 5BB2     	 sxtb r3,r3
 2645 0114 B3F1FF3F 	 cmp r3,#-1
 2646 0118 03D1     	 bne .L201
 2647              	 .loc 1 1700 0 is_stmt 0 discriminator 1
 2648 011a 3B6B     	 ldr r3,[r7,#48]
 2649 011c 0022     	 movs r2,#0
 2650 011e 83F84420 	 strb r2,[r3,#68]
 2651              	.L201:
 2652              	 .loc 1 1700 0 discriminator 3
 2653 0122 3B6B     	 ldr r3,[r7,#48]
 2654 0124 93F84530 	 ldrb r3,[r3,#69]
 2655 0128 DBB2     	 uxtb r3,r3
 2656 012a 5BB2     	 sxtb r3,r3
 2657 012c B3F1FF3F 	 cmp r3,#-1
 2658 0130 03D1     	 bne .L202
 2659              	 .loc 1 1700 0 discriminator 4
 2660 0132 3B6B     	 ldr r3,[r7,#48]
 2661 0134 0022     	 movs r2,#0
 2662 0136 83F84520 	 strb r2,[r3,#69]
 2663              	.L202:
 2664              	 .loc 1 1700 0 discriminator 6
 2665 013a FFF7FEFF 	 bl vPortExitCritical
1701:../Dave/Generated/FREERTOS/queue.c **** 
1702:../Dave/Generated/FREERTOS/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1703:../Dave/Generated/FREERTOS/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 2666              	 .loc 1 1703 0 is_stmt 1 discriminator 6
 2667 013e 07F11402 	 add r2,r7,#20
 2668 0142 3B1D     	 adds r3,r7,#4
 2669 0144 1046     	 mov r0,r2
 2670 0146 1946     	 mov r1,r3
 2671 0148 FFF7FEFF 	 bl xTaskCheckForTimeOut
 2672 014c 0346     	 mov r3,r0
 2673 014e 002B     	 cmp r3,#0
 2674 0150 24D1     	 bne .L203
1704:../Dave/Generated/FREERTOS/queue.c **** 		{
1705:../Dave/Generated/FREERTOS/queue.c **** 			/* Timeout has not expired yet, check to see if there is data in the
1706:../Dave/Generated/FREERTOS/queue.c **** 			queue now, and if not enter the Blocked state to wait for data. */
1707:../Dave/Generated/FREERTOS/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 2675              	 .loc 1 1707 0
 2676 0152 386B     	 ldr r0,[r7,#48]
 2677 0154 FFF7FEFF 	 bl prvIsQueueEmpty
 2678 0158 0346     	 mov r3,r0
 2679 015a 002B     	 cmp r3,#0
 2680 015c 18D0     	 beq .L204
1708:../Dave/Generated/FREERTOS/queue.c **** 			{
1709:../Dave/Generated/FREERTOS/queue.c **** 				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
1710:../Dave/Generated/FREERTOS/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 2681              	 .loc 1 1710 0
 2682 015e 3B6B     	 ldr r3,[r7,#48]
 2683 0160 03F12402 	 add r2,r3,#36
 2684 0164 7B68     	 ldr r3,[r7,#4]
 2685 0166 1046     	 mov r0,r2
 2686 0168 1946     	 mov r1,r3
 2687 016a FFF7FEFF 	 bl vTaskPlaceOnEventList
1711:../Dave/Generated/FREERTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 2688              	 .loc 1 1711 0
 2689 016e 386B     	 ldr r0,[r7,#48]
 2690 0170 FFF7FEFF 	 bl prvUnlockQueue
1712:../Dave/Generated/FREERTOS/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 2691              	 .loc 1 1712 0
 2692 0174 FFF7FEFF 	 bl xTaskResumeAll
 2693 0178 0346     	 mov r3,r0
 2694 017a 002B     	 cmp r3,#0
 2695 017c 1BD1     	 bne .L206
1713:../Dave/Generated/FREERTOS/queue.c **** 				{
1714:../Dave/Generated/FREERTOS/queue.c **** 					portYIELD_WITHIN_API();
 2696              	 .loc 1 1714 0
 2697 017e 104B     	 ldr r3,.L208
 2698 0180 4FF08052 	 mov r2,#268435456
 2699 0184 1A60     	 str r2,[r3]
 2700              	
 2701 0186 BFF34F8F 	 dsb
 2702              	
 2703              	
 2704 018a BFF36F8F 	 isb
 2705              	
 2706              	 .thumb
 2707 018e 12E0     	 b .L206
 2708              	.L204:
1715:../Dave/Generated/FREERTOS/queue.c **** 				}
1716:../Dave/Generated/FREERTOS/queue.c **** 				else
1717:../Dave/Generated/FREERTOS/queue.c **** 				{
1718:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1719:../Dave/Generated/FREERTOS/queue.c **** 				}
1720:../Dave/Generated/FREERTOS/queue.c **** 			}
1721:../Dave/Generated/FREERTOS/queue.c **** 			else
1722:../Dave/Generated/FREERTOS/queue.c **** 			{
1723:../Dave/Generated/FREERTOS/queue.c **** 				/* There is data in the queue now, so don't enter the blocked
1724:../Dave/Generated/FREERTOS/queue.c **** 				state, instead return to try and obtain the data. */
1725:../Dave/Generated/FREERTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 2709              	 .loc 1 1725 0
 2710 0190 386B     	 ldr r0,[r7,#48]
 2711 0192 FFF7FEFF 	 bl prvUnlockQueue
1726:../Dave/Generated/FREERTOS/queue.c **** 				( void ) xTaskResumeAll();
 2712              	 .loc 1 1726 0
 2713 0196 FFF7FEFF 	 bl xTaskResumeAll
 2714 019a 75E7     	 b .L194
 2715              	.L203:
1727:../Dave/Generated/FREERTOS/queue.c **** 			}
1728:../Dave/Generated/FREERTOS/queue.c **** 		}
1729:../Dave/Generated/FREERTOS/queue.c **** 		else
1730:../Dave/Generated/FREERTOS/queue.c **** 		{
1731:../Dave/Generated/FREERTOS/queue.c **** 			/* The timeout has expired.  If there is still no data in the queue
1732:../Dave/Generated/FREERTOS/queue.c **** 			exit, otherwise go back and try to read the data again. */
1733:../Dave/Generated/FREERTOS/queue.c **** 			prvUnlockQueue( pxQueue );
 2716              	 .loc 1 1733 0
 2717 019c 386B     	 ldr r0,[r7,#48]
 2718 019e FFF7FEFF 	 bl prvUnlockQueue
1734:../Dave/Generated/FREERTOS/queue.c **** 			( void ) xTaskResumeAll();
 2719              	 .loc 1 1734 0
 2720 01a2 FFF7FEFF 	 bl xTaskResumeAll
1735:../Dave/Generated/FREERTOS/queue.c **** 
1736:../Dave/Generated/FREERTOS/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 2721              	 .loc 1 1736 0
 2722 01a6 386B     	 ldr r0,[r7,#48]
 2723 01a8 FFF7FEFF 	 bl prvIsQueueEmpty
 2724 01ac 0346     	 mov r3,r0
 2725 01ae 002B     	 cmp r3,#0
 2726 01b0 01D0     	 beq .L206
1737:../Dave/Generated/FREERTOS/queue.c **** 			{
1738:../Dave/Generated/FREERTOS/queue.c **** 				traceQUEUE_PEEK_FAILED( pxQueue );
1739:../Dave/Generated/FREERTOS/queue.c **** 				return errQUEUE_EMPTY;
 2727              	 .loc 1 1739 0
 2728 01b2 0023     	 movs r3,#0
 2729 01b4 00E0     	 b .L207
 2730              	.L206:
1740:../Dave/Generated/FREERTOS/queue.c **** 			}
1741:../Dave/Generated/FREERTOS/queue.c **** 			else
1742:../Dave/Generated/FREERTOS/queue.c **** 			{
1743:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1744:../Dave/Generated/FREERTOS/queue.c **** 			}
1745:../Dave/Generated/FREERTOS/queue.c **** 		}
1746:../Dave/Generated/FREERTOS/queue.c **** 	}
 2731              	 .loc 1 1746 0 discriminator 5
 2732 01b6 67E7     	 b .L194
 2733              	.L207:
1747:../Dave/Generated/FREERTOS/queue.c **** }
 2734              	 .loc 1 1747 0 discriminator 6
 2735 01b8 1846     	 mov r0,r3
 2736 01ba 3837     	 adds r7,r7,#56
 2737              	 .cfi_def_cfa_offset 8
 2738 01bc BD46     	 mov sp,r7
 2739              	 .cfi_def_cfa_register 13
 2740              	 
 2741 01be 80BD     	 pop {r7,pc}
 2742              	.L209:
 2743              	 .align 2
 2744              	.L208:
 2745 01c0 04ED00E0 	 .word -536810236
 2746              	 .cfi_endproc
 2747              	.LFE152:
 2749              	 .section .text.xQueueReceiveFromISR,"ax",%progbits
 2750              	 .align 2
 2751              	 .global xQueueReceiveFromISR
 2752              	 .thumb
 2753              	 .thumb_func
 2755              	xQueueReceiveFromISR:
 2756              	.LFB153:
1748:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
1749:../Dave/Generated/FREERTOS/queue.c **** 
1750:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const px
1751:../Dave/Generated/FREERTOS/queue.c **** {
 2757              	 .loc 1 1751 0
 2758              	 .cfi_startproc
 2759              	 
 2760              	 
 2761 0000 80B5     	 push {r7,lr}
 2762              	 .cfi_def_cfa_offset 8
 2763              	 .cfi_offset 7,-8
 2764              	 .cfi_offset 14,-4
 2765 0002 8EB0     	 sub sp,sp,#56
 2766              	 .cfi_def_cfa_offset 64
 2767 0004 00AF     	 add r7,sp,#0
 2768              	 .cfi_def_cfa_register 7
 2769 0006 F860     	 str r0,[r7,#12]
 2770 0008 B960     	 str r1,[r7,#8]
 2771 000a 7A60     	 str r2,[r7,#4]
1752:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xReturn;
1753:../Dave/Generated/FREERTOS/queue.c **** UBaseType_t uxSavedInterruptStatus;
1754:../Dave/Generated/FREERTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 2772              	 .loc 1 1754 0
 2773 000c FB68     	 ldr r3,[r7,#12]
 2774 000e 3B63     	 str r3,[r7,#48]
1755:../Dave/Generated/FREERTOS/queue.c **** 
1756:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue );
 2775              	 .loc 1 1756 0
 2776 0010 3B6B     	 ldr r3,[r7,#48]
 2777 0012 002B     	 cmp r3,#0
 2778 0014 09D1     	 bne .L211
 2779              	.LBB177:
 2780              	.LBB178:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 2781              	 .loc 2 195 0 discriminator 1
 2782              	
 2783 0016 4FF0FC03 	 mov r3,#252
 2784 001a 83F31188 	 msr basepri,r3
 2785 001e BFF36F8F 	 isb 
 2786 0022 BFF34F8F 	 dsb 
 2787              	
 2788              	
 2789              	 .thumb
 2790 0026 3B62     	 str r3,[r7,#32]
 2791              	.L212:
 2792              	.LBE178:
 2793              	.LBE177:
 2794              	 .loc 1 1756 0 discriminator 1
 2795 0028 FEE7     	 b .L212
 2796              	.L211:
1757:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 2797              	 .loc 1 1757 0
 2798 002a BB68     	 ldr r3,[r7,#8]
 2799 002c 002B     	 cmp r3,#0
 2800 002e 03D1     	 bne .L213
 2801              	 .loc 1 1757 0 is_stmt 0 discriminator 2
 2802 0030 3B6B     	 ldr r3,[r7,#48]
 2803 0032 1B6C     	 ldr r3,[r3,#64]
 2804 0034 002B     	 cmp r3,#0
 2805 0036 01D1     	 bne .L214
 2806              	.L213:
 2807              	 .loc 1 1757 0 discriminator 3
 2808 0038 0123     	 movs r3,#1
 2809 003a 00E0     	 b .L215
 2810              	.L214:
 2811              	 .loc 1 1757 0 discriminator 4
 2812 003c 0023     	 movs r3,#0
 2813              	.L215:
 2814              	 .loc 1 1757 0 discriminator 6
 2815 003e 002B     	 cmp r3,#0
 2816 0040 09D1     	 bne .L216
 2817              	.LBB179:
 2818              	.LBB180:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 2819              	 .loc 2 195 0 is_stmt 1 discriminator 7
 2820              	
 2821 0042 4FF0FC03 	 mov r3,#252
 2822 0046 83F31188 	 msr basepri,r3
 2823 004a BFF36F8F 	 isb 
 2824 004e BFF34F8F 	 dsb 
 2825              	
 2826              	
 2827              	 .thumb
 2828 0052 FB61     	 str r3,[r7,#28]
 2829              	.L217:
 2830              	.LBE180:
 2831              	.LBE179:
 2832              	 .loc 1 1757 0 discriminator 2
 2833 0054 FEE7     	 b .L217
 2834              	.L216:
1758:../Dave/Generated/FREERTOS/queue.c **** 
1759:../Dave/Generated/FREERTOS/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1760:../Dave/Generated/FREERTOS/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1761:../Dave/Generated/FREERTOS/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1762:../Dave/Generated/FREERTOS/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1763:../Dave/Generated/FREERTOS/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1764:../Dave/Generated/FREERTOS/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1765:../Dave/Generated/FREERTOS/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1766:../Dave/Generated/FREERTOS/queue.c **** 	assigned a priority above the configured maximum system call priority.
1767:../Dave/Generated/FREERTOS/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1768:../Dave/Generated/FREERTOS/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1769:../Dave/Generated/FREERTOS/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1770:../Dave/Generated/FREERTOS/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1771:../Dave/Generated/FREERTOS/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1772:../Dave/Generated/FREERTOS/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1773:../Dave/Generated/FREERTOS/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 2835              	 .loc 1 1773 0
 2836 0056 FFF7FEFF 	 bl vPortValidateInterruptPriority
 2837              	.LBB181:
 2838              	.LBB182:
 211:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 2839              	 .loc 2 211 0
 2840              	
 2841 005a EFF31182 	 mrs r2,basepri
 2842 005e 4FF0FC03 	 mov r3,#252
 2843 0062 83F31188 	 msr basepri,r3
 2844 0066 BFF36F8F 	 isb 
 2845 006a BFF34F8F 	 dsb 
 2846              	
 2847              	
 2848              	 .thumb
 2849 006e BA61     	 str r2,[r7,#24]
 2850 0070 7B61     	 str r3,[r7,#20]
 223:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** }
 2851              	 .loc 2 223 0
 2852 0072 BB69     	 ldr r3,[r7,#24]
 2853              	.LBE182:
 2854              	.LBE181:
1774:../Dave/Generated/FREERTOS/queue.c **** 
1775:../Dave/Generated/FREERTOS/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 2855              	 .loc 1 1775 0
 2856 0074 FB62     	 str r3,[r7,#44]
 2857              	.LBB183:
1776:../Dave/Generated/FREERTOS/queue.c **** 	{
1777:../Dave/Generated/FREERTOS/queue.c **** 		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 2858              	 .loc 1 1777 0
 2859 0076 3B6B     	 ldr r3,[r7,#48]
 2860 0078 9B6B     	 ldr r3,[r3,#56]
 2861 007a BB62     	 str r3,[r7,#40]
1778:../Dave/Generated/FREERTOS/queue.c **** 
1779:../Dave/Generated/FREERTOS/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1780:../Dave/Generated/FREERTOS/queue.c **** 		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 2862              	 .loc 1 1780 0
 2863 007c BB6A     	 ldr r3,[r7,#40]
 2864 007e 002B     	 cmp r3,#0
 2865 0080 2FD0     	 beq .L219
 2866              	.LBB184:
1781:../Dave/Generated/FREERTOS/queue.c **** 		{
1782:../Dave/Generated/FREERTOS/queue.c **** 			const int8_t cRxLock = pxQueue->cRxLock;
 2867              	 .loc 1 1782 0
 2868 0082 3B6B     	 ldr r3,[r7,#48]
 2869 0084 93F84430 	 ldrb r3,[r3,#68]
 2870 0088 87F82730 	 strb r3,[r7,#39]
1783:../Dave/Generated/FREERTOS/queue.c **** 
1784:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1785:../Dave/Generated/FREERTOS/queue.c **** 
1786:../Dave/Generated/FREERTOS/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 2871              	 .loc 1 1786 0
 2872 008c 386B     	 ldr r0,[r7,#48]
 2873 008e B968     	 ldr r1,[r7,#8]
 2874 0090 FFF7FEFF 	 bl prvCopyDataFromQueue
1787:../Dave/Generated/FREERTOS/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 2875              	 .loc 1 1787 0
 2876 0094 BB6A     	 ldr r3,[r7,#40]
 2877 0096 5A1E     	 subs r2,r3,#1
 2878 0098 3B6B     	 ldr r3,[r7,#48]
 2879 009a 9A63     	 str r2,[r3,#56]
1788:../Dave/Generated/FREERTOS/queue.c **** 
1789:../Dave/Generated/FREERTOS/queue.c **** 			/* If the queue is locked the event list will not be modified.
1790:../Dave/Generated/FREERTOS/queue.c **** 			Instead update the lock count so the task that unlocks the queue
1791:../Dave/Generated/FREERTOS/queue.c **** 			will know that an ISR has removed data while the queue was
1792:../Dave/Generated/FREERTOS/queue.c **** 			locked. */
1793:../Dave/Generated/FREERTOS/queue.c **** 			if( cRxLock == queueUNLOCKED )
 2880              	 .loc 1 1793 0
 2881 009c 97F92730 	 ldrsb r3,[r7,#39]
 2882 00a0 B3F1FF3F 	 cmp r3,#-1
 2883 00a4 12D1     	 bne .L220
1794:../Dave/Generated/FREERTOS/queue.c **** 			{
1795:../Dave/Generated/FREERTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 2884              	 .loc 1 1795 0
 2885 00a6 3B6B     	 ldr r3,[r7,#48]
 2886 00a8 1B69     	 ldr r3,[r3,#16]
 2887 00aa 002B     	 cmp r3,#0
 2888 00ac 16D0     	 beq .L221
1796:../Dave/Generated/FREERTOS/queue.c **** 				{
1797:../Dave/Generated/FREERTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 2889              	 .loc 1 1797 0
 2890 00ae 3B6B     	 ldr r3,[r7,#48]
 2891 00b0 1033     	 adds r3,r3,#16
 2892 00b2 1846     	 mov r0,r3
 2893 00b4 FFF7FEFF 	 bl xTaskRemoveFromEventList
 2894 00b8 0346     	 mov r3,r0
 2895 00ba 002B     	 cmp r3,#0
 2896 00bc 0ED0     	 beq .L221
1798:../Dave/Generated/FREERTOS/queue.c **** 					{
1799:../Dave/Generated/FREERTOS/queue.c **** 						/* The task waiting has a higher priority than us so
1800:../Dave/Generated/FREERTOS/queue.c **** 						force a context switch. */
1801:../Dave/Generated/FREERTOS/queue.c **** 						if( pxHigherPriorityTaskWoken != NULL )
 2897              	 .loc 1 1801 0
 2898 00be 7B68     	 ldr r3,[r7,#4]
 2899 00c0 002B     	 cmp r3,#0
 2900 00c2 0BD0     	 beq .L221
1802:../Dave/Generated/FREERTOS/queue.c **** 						{
1803:../Dave/Generated/FREERTOS/queue.c **** 							*pxHigherPriorityTaskWoken = pdTRUE;
 2901              	 .loc 1 1803 0
 2902 00c4 7B68     	 ldr r3,[r7,#4]
 2903 00c6 0122     	 movs r2,#1
 2904 00c8 1A60     	 str r2,[r3]
 2905 00ca 07E0     	 b .L221
 2906              	.L220:
1804:../Dave/Generated/FREERTOS/queue.c **** 						}
1805:../Dave/Generated/FREERTOS/queue.c **** 						else
1806:../Dave/Generated/FREERTOS/queue.c **** 						{
1807:../Dave/Generated/FREERTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1808:../Dave/Generated/FREERTOS/queue.c **** 						}
1809:../Dave/Generated/FREERTOS/queue.c **** 					}
1810:../Dave/Generated/FREERTOS/queue.c **** 					else
1811:../Dave/Generated/FREERTOS/queue.c **** 					{
1812:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1813:../Dave/Generated/FREERTOS/queue.c **** 					}
1814:../Dave/Generated/FREERTOS/queue.c **** 				}
1815:../Dave/Generated/FREERTOS/queue.c **** 				else
1816:../Dave/Generated/FREERTOS/queue.c **** 				{
1817:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1818:../Dave/Generated/FREERTOS/queue.c **** 				}
1819:../Dave/Generated/FREERTOS/queue.c **** 			}
1820:../Dave/Generated/FREERTOS/queue.c **** 			else
1821:../Dave/Generated/FREERTOS/queue.c **** 			{
1822:../Dave/Generated/FREERTOS/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1823:../Dave/Generated/FREERTOS/queue.c **** 				knows that data was removed while it was locked. */
1824:../Dave/Generated/FREERTOS/queue.c **** 				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 2907              	 .loc 1 1824 0
 2908 00cc 97F82730 	 ldrb r3,[r7,#39]
 2909 00d0 0133     	 adds r3,r3,#1
 2910 00d2 DBB2     	 uxtb r3,r3
 2911 00d4 DAB2     	 uxtb r2,r3
 2912 00d6 3B6B     	 ldr r3,[r7,#48]
 2913 00d8 83F84420 	 strb r2,[r3,#68]
 2914              	.L221:
1825:../Dave/Generated/FREERTOS/queue.c **** 			}
1826:../Dave/Generated/FREERTOS/queue.c **** 
1827:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdPASS;
 2915              	 .loc 1 1827 0
 2916 00dc 0123     	 movs r3,#1
 2917 00de 7B63     	 str r3,[r7,#52]
 2918              	.LBE184:
 2919 00e0 01E0     	 b .L222
 2920              	.L219:
1828:../Dave/Generated/FREERTOS/queue.c **** 		}
1829:../Dave/Generated/FREERTOS/queue.c **** 		else
1830:../Dave/Generated/FREERTOS/queue.c **** 		{
1831:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdFAIL;
 2921              	 .loc 1 1831 0
 2922 00e2 0023     	 movs r3,#0
 2923 00e4 7B63     	 str r3,[r7,#52]
 2924              	.L222:
 2925 00e6 FB6A     	 ldr r3,[r7,#44]
 2926 00e8 3B61     	 str r3,[r7,#16]
 2927              	.LBE183:
 2928              	.LBB185:
 2929              	.LBB186:
 2930              	 .loc 2 229 0
 2931 00ea 3B69     	 ldr r3,[r7,#16]
 2932              	
 2933 00ec 83F31188 	 msr basepri,r3
 2934              	
 2935              	 .thumb
 2936              	.LBE186:
 2937              	.LBE185:
1832:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1833:../Dave/Generated/FREERTOS/queue.c **** 		}
1834:../Dave/Generated/FREERTOS/queue.c **** 	}
1835:../Dave/Generated/FREERTOS/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1836:../Dave/Generated/FREERTOS/queue.c **** 
1837:../Dave/Generated/FREERTOS/queue.c **** 	return xReturn;
 2938              	 .loc 1 1837 0
 2939 00f0 7B6B     	 ldr r3,[r7,#52]
1838:../Dave/Generated/FREERTOS/queue.c **** }
 2940              	 .loc 1 1838 0
 2941 00f2 1846     	 mov r0,r3
 2942 00f4 3837     	 adds r7,r7,#56
 2943              	 .cfi_def_cfa_offset 8
 2944 00f6 BD46     	 mov sp,r7
 2945              	 .cfi_def_cfa_register 13
 2946              	 
 2947 00f8 80BD     	 pop {r7,pc}
 2948              	 .cfi_endproc
 2949              	.LFE153:
 2951 00fa 00BF     	 .section .text.xQueuePeekFromISR,"ax",%progbits
 2952              	 .align 2
 2953              	 .global xQueuePeekFromISR
 2954              	 .thumb
 2955              	 .thumb_func
 2957              	xQueuePeekFromISR:
 2958              	.LFB154:
1839:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
1840:../Dave/Generated/FREERTOS/queue.c **** 
1841:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
1842:../Dave/Generated/FREERTOS/queue.c **** {
 2959              	 .loc 1 1842 0
 2960              	 .cfi_startproc
 2961              	 
 2962              	 
 2963 0000 80B5     	 push {r7,lr}
 2964              	 .cfi_def_cfa_offset 8
 2965              	 .cfi_offset 7,-8
 2966              	 .cfi_offset 14,-4
 2967 0002 8CB0     	 sub sp,sp,#48
 2968              	 .cfi_def_cfa_offset 56
 2969 0004 00AF     	 add r7,sp,#0
 2970              	 .cfi_def_cfa_register 7
 2971 0006 7860     	 str r0,[r7,#4]
 2972 0008 3960     	 str r1,[r7]
1843:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xReturn;
1844:../Dave/Generated/FREERTOS/queue.c **** UBaseType_t uxSavedInterruptStatus;
1845:../Dave/Generated/FREERTOS/queue.c **** int8_t *pcOriginalReadPosition;
1846:../Dave/Generated/FREERTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 2973              	 .loc 1 1846 0
 2974 000a 7B68     	 ldr r3,[r7,#4]
 2975 000c BB62     	 str r3,[r7,#40]
1847:../Dave/Generated/FREERTOS/queue.c **** 
1848:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue );
 2976              	 .loc 1 1848 0
 2977 000e BB6A     	 ldr r3,[r7,#40]
 2978 0010 002B     	 cmp r3,#0
 2979 0012 09D1     	 bne .L225
 2980              	.LBB187:
 2981              	.LBB188:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 2982              	 .loc 2 195 0 discriminator 1
 2983              	
 2984 0014 4FF0FC03 	 mov r3,#252
 2985 0018 83F31188 	 msr basepri,r3
 2986 001c BFF36F8F 	 isb 
 2987 0020 BFF34F8F 	 dsb 
 2988              	
 2989              	
 2990              	 .thumb
 2991 0024 FB61     	 str r3,[r7,#28]
 2992              	.L226:
 2993              	.LBE188:
 2994              	.LBE187:
 2995              	 .loc 1 1848 0 discriminator 1
 2996 0026 FEE7     	 b .L226
 2997              	.L225:
1849:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 2998              	 .loc 1 1849 0
 2999 0028 3B68     	 ldr r3,[r7]
 3000 002a 002B     	 cmp r3,#0
 3001 002c 03D1     	 bne .L227
 3002              	 .loc 1 1849 0 is_stmt 0 discriminator 2
 3003 002e BB6A     	 ldr r3,[r7,#40]
 3004 0030 1B6C     	 ldr r3,[r3,#64]
 3005 0032 002B     	 cmp r3,#0
 3006 0034 01D1     	 bne .L228
 3007              	.L227:
 3008              	 .loc 1 1849 0 discriminator 3
 3009 0036 0123     	 movs r3,#1
 3010 0038 00E0     	 b .L229
 3011              	.L228:
 3012              	 .loc 1 1849 0 discriminator 4
 3013 003a 0023     	 movs r3,#0
 3014              	.L229:
 3015              	 .loc 1 1849 0 discriminator 6
 3016 003c 002B     	 cmp r3,#0
 3017 003e 09D1     	 bne .L230
 3018              	.LBB189:
 3019              	.LBB190:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 3020              	 .loc 2 195 0 is_stmt 1 discriminator 7
 3021              	
 3022 0040 4FF0FC03 	 mov r3,#252
 3023 0044 83F31188 	 msr basepri,r3
 3024 0048 BFF36F8F 	 isb 
 3025 004c BFF34F8F 	 dsb 
 3026              	
 3027              	
 3028              	 .thumb
 3029 0050 BB61     	 str r3,[r7,#24]
 3030              	.L231:
 3031              	.LBE190:
 3032              	.LBE189:
 3033              	 .loc 1 1849 0 discriminator 2
 3034 0052 FEE7     	 b .L231
 3035              	.L230:
1850:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
 3036              	 .loc 1 1850 0
 3037 0054 BB6A     	 ldr r3,[r7,#40]
 3038 0056 1B6C     	 ldr r3,[r3,#64]
 3039 0058 002B     	 cmp r3,#0
 3040 005a 09D1     	 bne .L232
 3041              	.LBB191:
 3042              	.LBB192:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 3043              	 .loc 2 195 0 discriminator 1
 3044              	
 3045 005c 4FF0FC03 	 mov r3,#252
 3046 0060 83F31188 	 msr basepri,r3
 3047 0064 BFF36F8F 	 isb 
 3048 0068 BFF34F8F 	 dsb 
 3049              	
 3050              	
 3051              	 .thumb
 3052 006c 7B61     	 str r3,[r7,#20]
 3053              	.L233:
 3054              	.LBE192:
 3055              	.LBE191:
 3056              	 .loc 1 1850 0 discriminator 3
 3057 006e FEE7     	 b .L233
 3058              	.L232:
1851:../Dave/Generated/FREERTOS/queue.c **** 
1852:../Dave/Generated/FREERTOS/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1853:../Dave/Generated/FREERTOS/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1854:../Dave/Generated/FREERTOS/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1855:../Dave/Generated/FREERTOS/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1856:../Dave/Generated/FREERTOS/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1857:../Dave/Generated/FREERTOS/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1858:../Dave/Generated/FREERTOS/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1859:../Dave/Generated/FREERTOS/queue.c **** 	assigned a priority above the configured maximum system call priority.
1860:../Dave/Generated/FREERTOS/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1861:../Dave/Generated/FREERTOS/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1862:../Dave/Generated/FREERTOS/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1863:../Dave/Generated/FREERTOS/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1864:../Dave/Generated/FREERTOS/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1865:../Dave/Generated/FREERTOS/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1866:../Dave/Generated/FREERTOS/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 3059              	 .loc 1 1866 0
 3060 0070 FFF7FEFF 	 bl vPortValidateInterruptPriority
 3061              	.LBB193:
 3062              	.LBB194:
 211:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 3063              	 .loc 2 211 0
 3064              	
 3065 0074 EFF31182 	 mrs r2,basepri
 3066 0078 4FF0FC03 	 mov r3,#252
 3067 007c 83F31188 	 msr basepri,r3
 3068 0080 BFF36F8F 	 isb 
 3069 0084 BFF34F8F 	 dsb 
 3070              	
 3071              	
 3072              	 .thumb
 3073 0088 3A61     	 str r2,[r7,#16]
 3074 008a FB60     	 str r3,[r7,#12]
 223:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** }
 3075              	 .loc 2 223 0
 3076 008c 3B69     	 ldr r3,[r7,#16]
 3077              	.LBE194:
 3078              	.LBE193:
1867:../Dave/Generated/FREERTOS/queue.c **** 
1868:../Dave/Generated/FREERTOS/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 3079              	 .loc 1 1868 0
 3080 008e 7B62     	 str r3,[r7,#36]
1869:../Dave/Generated/FREERTOS/queue.c **** 	{
1870:../Dave/Generated/FREERTOS/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1871:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 3081              	 .loc 1 1871 0
 3082 0090 BB6A     	 ldr r3,[r7,#40]
 3083 0092 9B6B     	 ldr r3,[r3,#56]
 3084 0094 002B     	 cmp r3,#0
 3085 0096 0CD0     	 beq .L235
1872:../Dave/Generated/FREERTOS/queue.c **** 		{
1873:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_PEEK_FROM_ISR( pxQueue );
1874:../Dave/Generated/FREERTOS/queue.c **** 
1875:../Dave/Generated/FREERTOS/queue.c **** 			/* Remember the read position so it can be reset as nothing is
1876:../Dave/Generated/FREERTOS/queue.c **** 			actually being removed from the queue. */
1877:../Dave/Generated/FREERTOS/queue.c **** 			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 3086              	 .loc 1 1877 0
 3087 0098 BB6A     	 ldr r3,[r7,#40]
 3088 009a DB68     	 ldr r3,[r3,#12]
 3089 009c 3B62     	 str r3,[r7,#32]
1878:../Dave/Generated/FREERTOS/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 3090              	 .loc 1 1878 0
 3091 009e B86A     	 ldr r0,[r7,#40]
 3092 00a0 3968     	 ldr r1,[r7]
 3093 00a2 FFF7FEFF 	 bl prvCopyDataFromQueue
1879:../Dave/Generated/FREERTOS/queue.c **** 			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 3094              	 .loc 1 1879 0
 3095 00a6 BB6A     	 ldr r3,[r7,#40]
 3096 00a8 3A6A     	 ldr r2,[r7,#32]
 3097 00aa DA60     	 str r2,[r3,#12]
1880:../Dave/Generated/FREERTOS/queue.c **** 
1881:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdPASS;
 3098              	 .loc 1 1881 0
 3099 00ac 0123     	 movs r3,#1
 3100 00ae FB62     	 str r3,[r7,#44]
 3101 00b0 01E0     	 b .L236
 3102              	.L235:
1882:../Dave/Generated/FREERTOS/queue.c **** 		}
1883:../Dave/Generated/FREERTOS/queue.c **** 		else
1884:../Dave/Generated/FREERTOS/queue.c **** 		{
1885:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdFAIL;
 3103              	 .loc 1 1885 0
 3104 00b2 0023     	 movs r3,#0
 3105 00b4 FB62     	 str r3,[r7,#44]
 3106              	.L236:
 3107 00b6 7B6A     	 ldr r3,[r7,#36]
 3108 00b8 BB60     	 str r3,[r7,#8]
 3109              	.LBB195:
 3110              	.LBB196:
 3111              	 .loc 2 229 0
 3112 00ba BB68     	 ldr r3,[r7,#8]
 3113              	
 3114 00bc 83F31188 	 msr basepri,r3
 3115              	
 3116              	 .thumb
 3117              	.LBE196:
 3118              	.LBE195:
1886:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1887:../Dave/Generated/FREERTOS/queue.c **** 		}
1888:../Dave/Generated/FREERTOS/queue.c **** 	}
1889:../Dave/Generated/FREERTOS/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1890:../Dave/Generated/FREERTOS/queue.c **** 
1891:../Dave/Generated/FREERTOS/queue.c **** 	return xReturn;
 3119              	 .loc 1 1891 0
 3120 00c0 FB6A     	 ldr r3,[r7,#44]
1892:../Dave/Generated/FREERTOS/queue.c **** }
 3121              	 .loc 1 1892 0
 3122 00c2 1846     	 mov r0,r3
 3123 00c4 3037     	 adds r7,r7,#48
 3124              	 .cfi_def_cfa_offset 8
 3125 00c6 BD46     	 mov sp,r7
 3126              	 .cfi_def_cfa_register 13
 3127              	 
 3128 00c8 80BD     	 pop {r7,pc}
 3129              	 .cfi_endproc
 3130              	.LFE154:
 3132 00ca 00BF     	 .section .text.uxQueueMessagesWaiting,"ax",%progbits
 3133              	 .align 2
 3134              	 .global uxQueueMessagesWaiting
 3135              	 .thumb
 3136              	 .thumb_func
 3138              	uxQueueMessagesWaiting:
 3139              	.LFB155:
1893:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
1894:../Dave/Generated/FREERTOS/queue.c **** 
1895:../Dave/Generated/FREERTOS/queue.c **** UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
1896:../Dave/Generated/FREERTOS/queue.c **** {
 3140              	 .loc 1 1896 0
 3141              	 .cfi_startproc
 3142              	 
 3143              	 
 3144 0000 80B5     	 push {r7,lr}
 3145              	 .cfi_def_cfa_offset 8
 3146              	 .cfi_offset 7,-8
 3147              	 .cfi_offset 14,-4
 3148 0002 84B0     	 sub sp,sp,#16
 3149              	 .cfi_def_cfa_offset 24
 3150 0004 00AF     	 add r7,sp,#0
 3151              	 .cfi_def_cfa_register 7
 3152 0006 7860     	 str r0,[r7,#4]
1897:../Dave/Generated/FREERTOS/queue.c **** UBaseType_t uxReturn;
1898:../Dave/Generated/FREERTOS/queue.c **** 
1899:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( xQueue );
 3153              	 .loc 1 1899 0
 3154 0008 7B68     	 ldr r3,[r7,#4]
 3155 000a 002B     	 cmp r3,#0
 3156 000c 09D1     	 bne .L239
 3157              	.LBB197:
 3158              	.LBB198:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 3159              	 .loc 2 195 0 discriminator 1
 3160              	
 3161 000e 4FF0FC03 	 mov r3,#252
 3162 0012 83F31188 	 msr basepri,r3
 3163 0016 BFF36F8F 	 isb 
 3164 001a BFF34F8F 	 dsb 
 3165              	
 3166              	
 3167              	 .thumb
 3168 001e BB60     	 str r3,[r7,#8]
 3169              	.L240:
 3170              	.LBE198:
 3171              	.LBE197:
 3172              	 .loc 1 1899 0 discriminator 1
 3173 0020 FEE7     	 b .L240
 3174              	.L239:
1900:../Dave/Generated/FREERTOS/queue.c **** 
1901:../Dave/Generated/FREERTOS/queue.c **** 	taskENTER_CRITICAL();
 3175              	 .loc 1 1901 0
 3176 0022 FFF7FEFF 	 bl vPortEnterCritical
1902:../Dave/Generated/FREERTOS/queue.c **** 	{
1903:../Dave/Generated/FREERTOS/queue.c **** 		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 3177              	 .loc 1 1903 0
 3178 0026 7B68     	 ldr r3,[r7,#4]
 3179 0028 9B6B     	 ldr r3,[r3,#56]
 3180 002a FB60     	 str r3,[r7,#12]
1904:../Dave/Generated/FREERTOS/queue.c **** 	}
1905:../Dave/Generated/FREERTOS/queue.c **** 	taskEXIT_CRITICAL();
 3181              	 .loc 1 1905 0
 3182 002c FFF7FEFF 	 bl vPortExitCritical
1906:../Dave/Generated/FREERTOS/queue.c **** 
1907:../Dave/Generated/FREERTOS/queue.c **** 	return uxReturn;
 3183              	 .loc 1 1907 0
 3184 0030 FB68     	 ldr r3,[r7,#12]
1908:../Dave/Generated/FREERTOS/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 3185              	 .loc 1 1908 0
 3186 0032 1846     	 mov r0,r3
 3187 0034 1037     	 adds r7,r7,#16
 3188              	 .cfi_def_cfa_offset 8
 3189 0036 BD46     	 mov sp,r7
 3190              	 .cfi_def_cfa_register 13
 3191              	 
 3192 0038 80BD     	 pop {r7,pc}
 3193              	 .cfi_endproc
 3194              	.LFE155:
 3196 003a 00BF     	 .section .text.uxQueueSpacesAvailable,"ax",%progbits
 3197              	 .align 2
 3198              	 .global uxQueueSpacesAvailable
 3199              	 .thumb
 3200              	 .thumb_func
 3202              	uxQueueSpacesAvailable:
 3203              	.LFB156:
1909:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
1910:../Dave/Generated/FREERTOS/queue.c **** 
1911:../Dave/Generated/FREERTOS/queue.c **** UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
1912:../Dave/Generated/FREERTOS/queue.c **** {
 3204              	 .loc 1 1912 0
 3205              	 .cfi_startproc
 3206              	 
 3207              	 
 3208 0000 80B5     	 push {r7,lr}
 3209              	 .cfi_def_cfa_offset 8
 3210              	 .cfi_offset 7,-8
 3211              	 .cfi_offset 14,-4
 3212 0002 86B0     	 sub sp,sp,#24
 3213              	 .cfi_def_cfa_offset 32
 3214 0004 00AF     	 add r7,sp,#0
 3215              	 .cfi_def_cfa_register 7
 3216 0006 7860     	 str r0,[r7,#4]
1913:../Dave/Generated/FREERTOS/queue.c **** UBaseType_t uxReturn;
1914:../Dave/Generated/FREERTOS/queue.c **** Queue_t *pxQueue;
1915:../Dave/Generated/FREERTOS/queue.c **** 
1916:../Dave/Generated/FREERTOS/queue.c **** 	pxQueue = ( Queue_t * ) xQueue;
 3217              	 .loc 1 1916 0
 3218 0008 7B68     	 ldr r3,[r7,#4]
 3219 000a 7B61     	 str r3,[r7,#20]
1917:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue );
 3220              	 .loc 1 1917 0
 3221 000c 7B69     	 ldr r3,[r7,#20]
 3222 000e 002B     	 cmp r3,#0
 3223 0010 09D1     	 bne .L243
 3224              	.LBB199:
 3225              	.LBB200:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 3226              	 .loc 2 195 0 discriminator 1
 3227              	
 3228 0012 4FF0FC03 	 mov r3,#252
 3229 0016 83F31188 	 msr basepri,r3
 3230 001a BFF36F8F 	 isb 
 3231 001e BFF34F8F 	 dsb 
 3232              	
 3233              	
 3234              	 .thumb
 3235 0022 FB60     	 str r3,[r7,#12]
 3236              	.L244:
 3237              	.LBE200:
 3238              	.LBE199:
 3239              	 .loc 1 1917 0 discriminator 1
 3240 0024 FEE7     	 b .L244
 3241              	.L243:
1918:../Dave/Generated/FREERTOS/queue.c **** 
1919:../Dave/Generated/FREERTOS/queue.c **** 	taskENTER_CRITICAL();
 3242              	 .loc 1 1919 0
 3243 0026 FFF7FEFF 	 bl vPortEnterCritical
1920:../Dave/Generated/FREERTOS/queue.c **** 	{
1921:../Dave/Generated/FREERTOS/queue.c **** 		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 3244              	 .loc 1 1921 0
 3245 002a 7B69     	 ldr r3,[r7,#20]
 3246 002c DA6B     	 ldr r2,[r3,#60]
 3247 002e 7B69     	 ldr r3,[r7,#20]
 3248 0030 9B6B     	 ldr r3,[r3,#56]
 3249 0032 D31A     	 subs r3,r2,r3
 3250 0034 3B61     	 str r3,[r7,#16]
1922:../Dave/Generated/FREERTOS/queue.c **** 	}
1923:../Dave/Generated/FREERTOS/queue.c **** 	taskEXIT_CRITICAL();
 3251              	 .loc 1 1923 0
 3252 0036 FFF7FEFF 	 bl vPortExitCritical
1924:../Dave/Generated/FREERTOS/queue.c **** 
1925:../Dave/Generated/FREERTOS/queue.c **** 	return uxReturn;
 3253              	 .loc 1 1925 0
 3254 003a 3B69     	 ldr r3,[r7,#16]
1926:../Dave/Generated/FREERTOS/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 3255              	 .loc 1 1926 0
 3256 003c 1846     	 mov r0,r3
 3257 003e 1837     	 adds r7,r7,#24
 3258              	 .cfi_def_cfa_offset 8
 3259 0040 BD46     	 mov sp,r7
 3260              	 .cfi_def_cfa_register 13
 3261              	 
 3262 0042 80BD     	 pop {r7,pc}
 3263              	 .cfi_endproc
 3264              	.LFE156:
 3266              	 .section .text.uxQueueMessagesWaitingFromISR,"ax",%progbits
 3267              	 .align 2
 3268              	 .global uxQueueMessagesWaitingFromISR
 3269              	 .thumb
 3270              	 .thumb_func
 3272              	uxQueueMessagesWaitingFromISR:
 3273              	.LFB157:
1927:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
1928:../Dave/Generated/FREERTOS/queue.c **** 
1929:../Dave/Generated/FREERTOS/queue.c **** UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
1930:../Dave/Generated/FREERTOS/queue.c **** {
 3274              	 .loc 1 1930 0
 3275              	 .cfi_startproc
 3276              	 
 3277              	 
 3278              	 
 3279 0000 80B4     	 push {r7}
 3280              	 .cfi_def_cfa_offset 4
 3281              	 .cfi_offset 7,-4
 3282 0002 85B0     	 sub sp,sp,#20
 3283              	 .cfi_def_cfa_offset 24
 3284 0004 00AF     	 add r7,sp,#0
 3285              	 .cfi_def_cfa_register 7
 3286 0006 7860     	 str r0,[r7,#4]
1931:../Dave/Generated/FREERTOS/queue.c **** UBaseType_t uxReturn;
1932:../Dave/Generated/FREERTOS/queue.c **** 
1933:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( xQueue );
 3287              	 .loc 1 1933 0
 3288 0008 7B68     	 ldr r3,[r7,#4]
 3289 000a 002B     	 cmp r3,#0
 3290 000c 09D1     	 bne .L247
 3291              	.LBB201:
 3292              	.LBB202:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 3293              	 .loc 2 195 0 discriminator 1
 3294              	
 3295 000e 4FF0FC03 	 mov r3,#252
 3296 0012 83F31188 	 msr basepri,r3
 3297 0016 BFF36F8F 	 isb 
 3298 001a BFF34F8F 	 dsb 
 3299              	
 3300              	
 3301              	 .thumb
 3302 001e BB60     	 str r3,[r7,#8]
 3303              	.L248:
 3304              	.LBE202:
 3305              	.LBE201:
 3306              	 .loc 1 1933 0 discriminator 1
 3307 0020 FEE7     	 b .L248
 3308              	.L247:
1934:../Dave/Generated/FREERTOS/queue.c **** 
1935:../Dave/Generated/FREERTOS/queue.c **** 	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 3309              	 .loc 1 1935 0
 3310 0022 7B68     	 ldr r3,[r7,#4]
 3311 0024 9B6B     	 ldr r3,[r3,#56]
 3312 0026 FB60     	 str r3,[r7,#12]
1936:../Dave/Generated/FREERTOS/queue.c **** 
1937:../Dave/Generated/FREERTOS/queue.c **** 	return uxReturn;
 3313              	 .loc 1 1937 0
 3314 0028 FB68     	 ldr r3,[r7,#12]
1938:../Dave/Generated/FREERTOS/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 3315              	 .loc 1 1938 0
 3316 002a 1846     	 mov r0,r3
 3317 002c 1437     	 adds r7,r7,#20
 3318              	 .cfi_def_cfa_offset 4
 3319 002e BD46     	 mov sp,r7
 3320              	 .cfi_def_cfa_register 13
 3321              	 
 3322 0030 5DF8047B 	 ldr r7,[sp],#4
 3323              	 .cfi_restore 7
 3324              	 .cfi_def_cfa_offset 0
 3325 0034 7047     	 bx lr
 3326              	 .cfi_endproc
 3327              	.LFE157:
 3329 0036 00BF     	 .section .text.vQueueDelete,"ax",%progbits
 3330              	 .align 2
 3331              	 .global vQueueDelete
 3332              	 .thumb
 3333              	 .thumb_func
 3335              	vQueueDelete:
 3336              	.LFB158:
1939:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
1940:../Dave/Generated/FREERTOS/queue.c **** 
1941:../Dave/Generated/FREERTOS/queue.c **** void vQueueDelete( QueueHandle_t xQueue )
1942:../Dave/Generated/FREERTOS/queue.c **** {
 3337              	 .loc 1 1942 0
 3338              	 .cfi_startproc
 3339              	 
 3340              	 
 3341 0000 80B5     	 push {r7,lr}
 3342              	 .cfi_def_cfa_offset 8
 3343              	 .cfi_offset 7,-8
 3344              	 .cfi_offset 14,-4
 3345 0002 84B0     	 sub sp,sp,#16
 3346              	 .cfi_def_cfa_offset 24
 3347 0004 00AF     	 add r7,sp,#0
 3348              	 .cfi_def_cfa_register 7
 3349 0006 7860     	 str r0,[r7,#4]
1943:../Dave/Generated/FREERTOS/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 3350              	 .loc 1 1943 0
 3351 0008 7B68     	 ldr r3,[r7,#4]
 3352 000a FB60     	 str r3,[r7,#12]
1944:../Dave/Generated/FREERTOS/queue.c **** 
1945:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue );
 3353              	 .loc 1 1945 0
 3354 000c FB68     	 ldr r3,[r7,#12]
 3355 000e 002B     	 cmp r3,#0
 3356 0010 09D1     	 bne .L251
 3357              	.LBB203:
 3358              	.LBB204:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 3359              	 .loc 2 195 0 discriminator 1
 3360              	
 3361 0012 4FF0FC03 	 mov r3,#252
 3362 0016 83F31188 	 msr basepri,r3
 3363 001a BFF36F8F 	 isb 
 3364 001e BFF34F8F 	 dsb 
 3365              	
 3366              	
 3367              	 .thumb
 3368 0022 BB60     	 str r3,[r7,#8]
 3369              	.L252:
 3370              	.LBE204:
 3371              	.LBE203:
 3372              	 .loc 1 1945 0 discriminator 1
 3373 0024 FEE7     	 b .L252
 3374              	.L251:
1946:../Dave/Generated/FREERTOS/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1947:../Dave/Generated/FREERTOS/queue.c **** 
1948:../Dave/Generated/FREERTOS/queue.c **** 	#if ( configQUEUE_REGISTRY_SIZE > 0 )
1949:../Dave/Generated/FREERTOS/queue.c **** 	{
1950:../Dave/Generated/FREERTOS/queue.c **** 		vQueueUnregisterQueue( pxQueue );
 3375              	 .loc 1 1950 0
 3376 0026 F868     	 ldr r0,[r7,#12]
 3377 0028 FFF7FEFF 	 bl vQueueUnregisterQueue
1951:../Dave/Generated/FREERTOS/queue.c **** 	}
1952:../Dave/Generated/FREERTOS/queue.c **** 	#endif
1953:../Dave/Generated/FREERTOS/queue.c **** 
1954:../Dave/Generated/FREERTOS/queue.c **** 	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
1955:../Dave/Generated/FREERTOS/queue.c **** 	{
1956:../Dave/Generated/FREERTOS/queue.c **** 		/* The queue can only have been allocated dynamically - free it
1957:../Dave/Generated/FREERTOS/queue.c **** 		again. */
1958:../Dave/Generated/FREERTOS/queue.c **** 		vPortFree( pxQueue );
 3378              	 .loc 1 1958 0
 3379 002c F868     	 ldr r0,[r7,#12]
 3380 002e FFF7FEFF 	 bl vPortFree
1959:../Dave/Generated/FREERTOS/queue.c **** 	}
1960:../Dave/Generated/FREERTOS/queue.c **** 	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
1961:../Dave/Generated/FREERTOS/queue.c **** 	{
1962:../Dave/Generated/FREERTOS/queue.c **** 		/* The queue could have been allocated statically or dynamically, so
1963:../Dave/Generated/FREERTOS/queue.c **** 		check before attempting to free the memory. */
1964:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
1965:../Dave/Generated/FREERTOS/queue.c **** 		{
1966:../Dave/Generated/FREERTOS/queue.c **** 			vPortFree( pxQueue );
1967:../Dave/Generated/FREERTOS/queue.c **** 		}
1968:../Dave/Generated/FREERTOS/queue.c **** 		else
1969:../Dave/Generated/FREERTOS/queue.c **** 		{
1970:../Dave/Generated/FREERTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1971:../Dave/Generated/FREERTOS/queue.c **** 		}
1972:../Dave/Generated/FREERTOS/queue.c **** 	}
1973:../Dave/Generated/FREERTOS/queue.c **** 	#else
1974:../Dave/Generated/FREERTOS/queue.c **** 	{
1975:../Dave/Generated/FREERTOS/queue.c **** 		/* The queue must have been statically allocated, so is not going to be
1976:../Dave/Generated/FREERTOS/queue.c **** 		deleted.  Avoid compiler warnings about the unused parameter. */
1977:../Dave/Generated/FREERTOS/queue.c **** 		( void ) pxQueue;
1978:../Dave/Generated/FREERTOS/queue.c **** 	}
1979:../Dave/Generated/FREERTOS/queue.c **** 	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
1980:../Dave/Generated/FREERTOS/queue.c **** }
 3381              	 .loc 1 1980 0
 3382 0032 1037     	 adds r7,r7,#16
 3383              	 .cfi_def_cfa_offset 8
 3384 0034 BD46     	 mov sp,r7
 3385              	 .cfi_def_cfa_register 13
 3386              	 
 3387 0036 80BD     	 pop {r7,pc}
 3388              	 .cfi_endproc
 3389              	.LFE158:
 3391              	 .section .text.uxQueueGetQueueNumber,"ax",%progbits
 3392              	 .align 2
 3393              	 .global uxQueueGetQueueNumber
 3394              	 .thumb
 3395              	 .thumb_func
 3397              	uxQueueGetQueueNumber:
 3398              	.LFB159:
1981:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
1982:../Dave/Generated/FREERTOS/queue.c **** 
1983:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1984:../Dave/Generated/FREERTOS/queue.c **** 
1985:../Dave/Generated/FREERTOS/queue.c **** 	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
1986:../Dave/Generated/FREERTOS/queue.c **** 	{
 3399              	 .loc 1 1986 0
 3400              	 .cfi_startproc
 3401              	 
 3402              	 
 3403              	 
 3404 0000 80B4     	 push {r7}
 3405              	 .cfi_def_cfa_offset 4
 3406              	 .cfi_offset 7,-4
 3407 0002 83B0     	 sub sp,sp,#12
 3408              	 .cfi_def_cfa_offset 16
 3409 0004 00AF     	 add r7,sp,#0
 3410              	 .cfi_def_cfa_register 7
 3411 0006 7860     	 str r0,[r7,#4]
1987:../Dave/Generated/FREERTOS/queue.c **** 		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
 3412              	 .loc 1 1987 0
 3413 0008 7B68     	 ldr r3,[r7,#4]
 3414 000a DB6C     	 ldr r3,[r3,#76]
1988:../Dave/Generated/FREERTOS/queue.c **** 	}
 3415              	 .loc 1 1988 0
 3416 000c 1846     	 mov r0,r3
 3417 000e 0C37     	 adds r7,r7,#12
 3418              	 .cfi_def_cfa_offset 4
 3419 0010 BD46     	 mov sp,r7
 3420              	 .cfi_def_cfa_register 13
 3421              	 
 3422 0012 5DF8047B 	 ldr r7,[sp],#4
 3423              	 .cfi_restore 7
 3424              	 .cfi_def_cfa_offset 0
 3425 0016 7047     	 bx lr
 3426              	 .cfi_endproc
 3427              	.LFE159:
 3429              	 .section .text.vQueueSetQueueNumber,"ax",%progbits
 3430              	 .align 2
 3431              	 .global vQueueSetQueueNumber
 3432              	 .thumb
 3433              	 .thumb_func
 3435              	vQueueSetQueueNumber:
 3436              	.LFB160:
1989:../Dave/Generated/FREERTOS/queue.c **** 
1990:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1991:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
1992:../Dave/Generated/FREERTOS/queue.c **** 
1993:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1994:../Dave/Generated/FREERTOS/queue.c **** 
1995:../Dave/Generated/FREERTOS/queue.c **** 	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
1996:../Dave/Generated/FREERTOS/queue.c **** 	{
 3437              	 .loc 1 1996 0
 3438              	 .cfi_startproc
 3439              	 
 3440              	 
 3441              	 
 3442 0000 80B4     	 push {r7}
 3443              	 .cfi_def_cfa_offset 4
 3444              	 .cfi_offset 7,-4
 3445 0002 83B0     	 sub sp,sp,#12
 3446              	 .cfi_def_cfa_offset 16
 3447 0004 00AF     	 add r7,sp,#0
 3448              	 .cfi_def_cfa_register 7
 3449 0006 7860     	 str r0,[r7,#4]
 3450 0008 3960     	 str r1,[r7]
1997:../Dave/Generated/FREERTOS/queue.c **** 		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
 3451              	 .loc 1 1997 0
 3452 000a 7B68     	 ldr r3,[r7,#4]
 3453 000c 3A68     	 ldr r2,[r7]
 3454 000e DA64     	 str r2,[r3,#76]
1998:../Dave/Generated/FREERTOS/queue.c **** 	}
 3455              	 .loc 1 1998 0
 3456 0010 0C37     	 adds r7,r7,#12
 3457              	 .cfi_def_cfa_offset 4
 3458 0012 BD46     	 mov sp,r7
 3459              	 .cfi_def_cfa_register 13
 3460              	 
 3461 0014 5DF8047B 	 ldr r7,[sp],#4
 3462              	 .cfi_restore 7
 3463              	 .cfi_def_cfa_offset 0
 3464 0018 7047     	 bx lr
 3465              	 .cfi_endproc
 3466              	.LFE160:
 3468 001a 00BF     	 .section .text.ucQueueGetQueueType,"ax",%progbits
 3469              	 .align 2
 3470              	 .global ucQueueGetQueueType
 3471              	 .thumb
 3472              	 .thumb_func
 3474              	ucQueueGetQueueType:
 3475              	.LFB161:
1999:../Dave/Generated/FREERTOS/queue.c **** 
2000:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2001:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2002:../Dave/Generated/FREERTOS/queue.c **** 
2003:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2004:../Dave/Generated/FREERTOS/queue.c **** 
2005:../Dave/Generated/FREERTOS/queue.c **** 	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
2006:../Dave/Generated/FREERTOS/queue.c **** 	{
 3476              	 .loc 1 2006 0
 3477              	 .cfi_startproc
 3478              	 
 3479              	 
 3480              	 
 3481 0000 80B4     	 push {r7}
 3482              	 .cfi_def_cfa_offset 4
 3483              	 .cfi_offset 7,-4
 3484 0002 83B0     	 sub sp,sp,#12
 3485              	 .cfi_def_cfa_offset 16
 3486 0004 00AF     	 add r7,sp,#0
 3487              	 .cfi_def_cfa_register 7
 3488 0006 7860     	 str r0,[r7,#4]
2007:../Dave/Generated/FREERTOS/queue.c **** 		return ( ( Queue_t * ) xQueue )->ucQueueType;
 3489              	 .loc 1 2007 0
 3490 0008 7B68     	 ldr r3,[r7,#4]
 3491 000a 93F85030 	 ldrb r3,[r3,#80]
2008:../Dave/Generated/FREERTOS/queue.c **** 	}
 3492              	 .loc 1 2008 0
 3493 000e 1846     	 mov r0,r3
 3494 0010 0C37     	 adds r7,r7,#12
 3495              	 .cfi_def_cfa_offset 4
 3496 0012 BD46     	 mov sp,r7
 3497              	 .cfi_def_cfa_register 13
 3498              	 
 3499 0014 5DF8047B 	 ldr r7,[sp],#4
 3500              	 .cfi_restore 7
 3501              	 .cfi_def_cfa_offset 0
 3502 0018 7047     	 bx lr
 3503              	 .cfi_endproc
 3504              	.LFE161:
 3506 001a 00BF     	 .section .text.prvGetDisinheritPriorityAfterTimeout,"ax",%progbits
 3507              	 .align 2
 3508              	 .thumb
 3509              	 .thumb_func
 3511              	prvGetDisinheritPriorityAfterTimeout:
 3512              	.LFB162:
2009:../Dave/Generated/FREERTOS/queue.c **** 
2010:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2011:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2012:../Dave/Generated/FREERTOS/queue.c **** 
2013:../Dave/Generated/FREERTOS/queue.c **** #if( configUSE_MUTEXES == 1 )
2014:../Dave/Generated/FREERTOS/queue.c **** 
2015:../Dave/Generated/FREERTOS/queue.c **** 	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
2016:../Dave/Generated/FREERTOS/queue.c **** 	{
 3513              	 .loc 1 2016 0
 3514              	 .cfi_startproc
 3515              	 
 3516              	 
 3517              	 
 3518 0000 80B4     	 push {r7}
 3519              	 .cfi_def_cfa_offset 4
 3520              	 .cfi_offset 7,-4
 3521 0002 85B0     	 sub sp,sp,#20
 3522              	 .cfi_def_cfa_offset 24
 3523 0004 00AF     	 add r7,sp,#0
 3524              	 .cfi_def_cfa_register 7
 3525 0006 7860     	 str r0,[r7,#4]
2017:../Dave/Generated/FREERTOS/queue.c **** 	UBaseType_t uxHighestPriorityOfWaitingTasks;
2018:../Dave/Generated/FREERTOS/queue.c **** 
2019:../Dave/Generated/FREERTOS/queue.c **** 		/* If a task waiting for a mutex causes the mutex holder to inherit a
2020:../Dave/Generated/FREERTOS/queue.c **** 		priority, but the waiting task times out, then the holder should
2021:../Dave/Generated/FREERTOS/queue.c **** 		disinherit the priority - but only down to the highest priority of any
2022:../Dave/Generated/FREERTOS/queue.c **** 		other tasks that are waiting for the same mutex.  For this purpose,
2023:../Dave/Generated/FREERTOS/queue.c **** 		return the priority of the highest priority task that is waiting for the
2024:../Dave/Generated/FREERTOS/queue.c **** 		mutex. */
2025:../Dave/Generated/FREERTOS/queue.c **** 		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0 )
 3526              	 .loc 1 2025 0
 3527 0008 7B68     	 ldr r3,[r7,#4]
 3528 000a 5B6A     	 ldr r3,[r3,#36]
 3529 000c 002B     	 cmp r3,#0
 3530 000e 06D0     	 beq .L259
2026:../Dave/Generated/FREERTOS/queue.c **** 		{
2027:../Dave/Generated/FREERTOS/queue.c **** 			uxHighestPriorityOfWaitingTasks = configMAX_PRIORITIES - listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( px
 3531              	 .loc 1 2027 0
 3532 0010 7B68     	 ldr r3,[r7,#4]
 3533 0012 1B6B     	 ldr r3,[r3,#48]
 3534 0014 1B68     	 ldr r3,[r3]
 3535 0016 C3F10503 	 rsb r3,r3,#5
 3536 001a FB60     	 str r3,[r7,#12]
 3537 001c 01E0     	 b .L260
 3538              	.L259:
2028:../Dave/Generated/FREERTOS/queue.c **** 		}
2029:../Dave/Generated/FREERTOS/queue.c **** 		else
2030:../Dave/Generated/FREERTOS/queue.c **** 		{
2031:../Dave/Generated/FREERTOS/queue.c **** 			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
 3539              	 .loc 1 2031 0
 3540 001e 0023     	 movs r3,#0
 3541 0020 FB60     	 str r3,[r7,#12]
 3542              	.L260:
2032:../Dave/Generated/FREERTOS/queue.c **** 		}
2033:../Dave/Generated/FREERTOS/queue.c **** 
2034:../Dave/Generated/FREERTOS/queue.c **** 		return uxHighestPriorityOfWaitingTasks;
 3543              	 .loc 1 2034 0
 3544 0022 FB68     	 ldr r3,[r7,#12]
2035:../Dave/Generated/FREERTOS/queue.c **** 	}
 3545              	 .loc 1 2035 0
 3546 0024 1846     	 mov r0,r3
 3547 0026 1437     	 adds r7,r7,#20
 3548              	 .cfi_def_cfa_offset 4
 3549 0028 BD46     	 mov sp,r7
 3550              	 .cfi_def_cfa_register 13
 3551              	 
 3552 002a 5DF8047B 	 ldr r7,[sp],#4
 3553              	 .cfi_restore 7
 3554              	 .cfi_def_cfa_offset 0
 3555 002e 7047     	 bx lr
 3556              	 .cfi_endproc
 3557              	.LFE162:
 3559              	 .section .text.prvCopyDataToQueue,"ax",%progbits
 3560              	 .align 2
 3561              	 .thumb
 3562              	 .thumb_func
 3564              	prvCopyDataToQueue:
 3565              	.LFB163:
2036:../Dave/Generated/FREERTOS/queue.c **** 
2037:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_MUTEXES */
2038:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2039:../Dave/Generated/FREERTOS/queue.c **** 
2040:../Dave/Generated/FREERTOS/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
2041:../Dave/Generated/FREERTOS/queue.c **** {
 3566              	 .loc 1 2041 0
 3567              	 .cfi_startproc
 3568              	 
 3569              	 
 3570 0000 80B5     	 push {r7,lr}
 3571              	 .cfi_def_cfa_offset 8
 3572              	 .cfi_offset 7,-8
 3573              	 .cfi_offset 14,-4
 3574 0002 86B0     	 sub sp,sp,#24
 3575              	 .cfi_def_cfa_offset 32
 3576 0004 00AF     	 add r7,sp,#0
 3577              	 .cfi_def_cfa_register 7
 3578 0006 F860     	 str r0,[r7,#12]
 3579 0008 B960     	 str r1,[r7,#8]
 3580 000a 7A60     	 str r2,[r7,#4]
2042:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xReturn = pdFALSE;
 3581              	 .loc 1 2042 0
 3582 000c 0023     	 movs r3,#0
 3583 000e 7B61     	 str r3,[r7,#20]
2043:../Dave/Generated/FREERTOS/queue.c **** UBaseType_t uxMessagesWaiting;
2044:../Dave/Generated/FREERTOS/queue.c **** 
2045:../Dave/Generated/FREERTOS/queue.c **** 	/* This function is called from a critical section. */
2046:../Dave/Generated/FREERTOS/queue.c **** 
2047:../Dave/Generated/FREERTOS/queue.c **** 	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 3584              	 .loc 1 2047 0
 3585 0010 FB68     	 ldr r3,[r7,#12]
 3586 0012 9B6B     	 ldr r3,[r3,#56]
 3587 0014 3B61     	 str r3,[r7,#16]
2048:../Dave/Generated/FREERTOS/queue.c **** 
2049:../Dave/Generated/FREERTOS/queue.c **** 	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 3588              	 .loc 1 2049 0
 3589 0016 FB68     	 ldr r3,[r7,#12]
 3590 0018 1B6C     	 ldr r3,[r3,#64]
 3591 001a 002B     	 cmp r3,#0
 3592 001c 0DD1     	 bne .L263
2050:../Dave/Generated/FREERTOS/queue.c **** 	{
2051:../Dave/Generated/FREERTOS/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
2052:../Dave/Generated/FREERTOS/queue.c **** 		{
2053:../Dave/Generated/FREERTOS/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 3593              	 .loc 1 2053 0
 3594 001e FB68     	 ldr r3,[r7,#12]
 3595 0020 1B68     	 ldr r3,[r3]
 3596 0022 002B     	 cmp r3,#0
 3597 0024 4FD1     	 bne .L264
2054:../Dave/Generated/FREERTOS/queue.c **** 			{
2055:../Dave/Generated/FREERTOS/queue.c **** 				/* The mutex is no longer being held. */
2056:../Dave/Generated/FREERTOS/queue.c **** 				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 3598              	 .loc 1 2056 0
 3599 0026 FB68     	 ldr r3,[r7,#12]
 3600 0028 5B68     	 ldr r3,[r3,#4]
 3601 002a 1846     	 mov r0,r3
 3602 002c FFF7FEFF 	 bl xTaskPriorityDisinherit
 3603 0030 7861     	 str r0,[r7,#20]
2057:../Dave/Generated/FREERTOS/queue.c **** 				pxQueue->pxMutexHolder = NULL;
 3604              	 .loc 1 2057 0
 3605 0032 FB68     	 ldr r3,[r7,#12]
 3606 0034 0022     	 movs r2,#0
 3607 0036 5A60     	 str r2,[r3,#4]
 3608 0038 45E0     	 b .L264
 3609              	.L263:
2058:../Dave/Generated/FREERTOS/queue.c **** 			}
2059:../Dave/Generated/FREERTOS/queue.c **** 			else
2060:../Dave/Generated/FREERTOS/queue.c **** 			{
2061:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2062:../Dave/Generated/FREERTOS/queue.c **** 			}
2063:../Dave/Generated/FREERTOS/queue.c **** 		}
2064:../Dave/Generated/FREERTOS/queue.c **** 		#endif /* configUSE_MUTEXES */
2065:../Dave/Generated/FREERTOS/queue.c **** 	}
2066:../Dave/Generated/FREERTOS/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
 3610              	 .loc 1 2066 0
 3611 003a 7B68     	 ldr r3,[r7,#4]
 3612 003c 002B     	 cmp r3,#0
 3613 003e 1AD1     	 bne .L265
2067:../Dave/Generated/FREERTOS/queue.c **** 	{
2068:../Dave/Generated/FREERTOS/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); 
 3614              	 .loc 1 2068 0
 3615 0040 FB68     	 ldr r3,[r7,#12]
 3616 0042 9A68     	 ldr r2,[r3,#8]
 3617 0044 FB68     	 ldr r3,[r7,#12]
 3618 0046 1B6C     	 ldr r3,[r3,#64]
 3619 0048 1046     	 mov r0,r2
 3620 004a B968     	 ldr r1,[r7,#8]
 3621 004c 1A46     	 mov r2,r3
 3622 004e FFF7FEFF 	 bl memcpy
2069:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 3623              	 .loc 1 2069 0
 3624 0052 FB68     	 ldr r3,[r7,#12]
 3625 0054 9A68     	 ldr r2,[r3,#8]
 3626 0056 FB68     	 ldr r3,[r7,#12]
 3627 0058 1B6C     	 ldr r3,[r3,#64]
 3628 005a 1A44     	 add r2,r2,r3
 3629 005c FB68     	 ldr r3,[r7,#12]
 3630 005e 9A60     	 str r2,[r3,#8]
2070:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison 
 3631              	 .loc 1 2070 0
 3632 0060 FB68     	 ldr r3,[r7,#12]
 3633 0062 9A68     	 ldr r2,[r3,#8]
 3634 0064 FB68     	 ldr r3,[r7,#12]
 3635 0066 5B68     	 ldr r3,[r3,#4]
 3636 0068 9A42     	 cmp r2,r3
 3637 006a 2CD3     	 bcc .L264
2071:../Dave/Generated/FREERTOS/queue.c **** 		{
2072:../Dave/Generated/FREERTOS/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
 3638              	 .loc 1 2072 0
 3639 006c FB68     	 ldr r3,[r7,#12]
 3640 006e 1A68     	 ldr r2,[r3]
 3641 0070 FB68     	 ldr r3,[r7,#12]
 3642 0072 9A60     	 str r2,[r3,#8]
 3643 0074 27E0     	 b .L264
 3644              	.L265:
2073:../Dave/Generated/FREERTOS/queue.c **** 		}
2074:../Dave/Generated/FREERTOS/queue.c **** 		else
2075:../Dave/Generated/FREERTOS/queue.c **** 		{
2076:../Dave/Generated/FREERTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2077:../Dave/Generated/FREERTOS/queue.c **** 		}
2078:../Dave/Generated/FREERTOS/queue.c **** 	}
2079:../Dave/Generated/FREERTOS/queue.c **** 	else
2080:../Dave/Generated/FREERTOS/queue.c **** 	{
2081:../Dave/Generated/FREERTOS/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize 
 3645              	 .loc 1 2081 0
 3646 0076 FB68     	 ldr r3,[r7,#12]
 3647 0078 DA68     	 ldr r2,[r3,#12]
 3648 007a FB68     	 ldr r3,[r7,#12]
 3649 007c 1B6C     	 ldr r3,[r3,#64]
 3650 007e 1046     	 mov r0,r2
 3651 0080 B968     	 ldr r1,[r7,#8]
 3652 0082 1A46     	 mov r2,r3
 3653 0084 FFF7FEFF 	 bl memcpy
2082:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 3654              	 .loc 1 2082 0
 3655 0088 FB68     	 ldr r3,[r7,#12]
 3656 008a DA68     	 ldr r2,[r3,#12]
 3657 008c FB68     	 ldr r3,[r7,#12]
 3658 008e 1B6C     	 ldr r3,[r3,#64]
 3659 0090 5B42     	 negs r3,r3
 3660 0092 1A44     	 add r2,r2,r3
 3661 0094 FB68     	 ldr r3,[r7,#12]
 3662 0096 DA60     	 str r2,[r3,#12]
2083:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as compariso
 3663              	 .loc 1 2083 0
 3664 0098 FB68     	 ldr r3,[r7,#12]
 3665 009a DA68     	 ldr r2,[r3,#12]
 3666 009c FB68     	 ldr r3,[r7,#12]
 3667 009e 1B68     	 ldr r3,[r3]
 3668 00a0 9A42     	 cmp r2,r3
 3669 00a2 07D2     	 bcs .L266
2084:../Dave/Generated/FREERTOS/queue.c **** 		{
2085:../Dave/Generated/FREERTOS/queue.c **** 			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 3670              	 .loc 1 2085 0
 3671 00a4 FB68     	 ldr r3,[r7,#12]
 3672 00a6 5A68     	 ldr r2,[r3,#4]
 3673 00a8 FB68     	 ldr r3,[r7,#12]
 3674 00aa 1B6C     	 ldr r3,[r3,#64]
 3675 00ac 5B42     	 negs r3,r3
 3676 00ae 1A44     	 add r2,r2,r3
 3677 00b0 FB68     	 ldr r3,[r7,#12]
 3678 00b2 DA60     	 str r2,[r3,#12]
 3679              	.L266:
2086:../Dave/Generated/FREERTOS/queue.c **** 		}
2087:../Dave/Generated/FREERTOS/queue.c **** 		else
2088:../Dave/Generated/FREERTOS/queue.c **** 		{
2089:../Dave/Generated/FREERTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2090:../Dave/Generated/FREERTOS/queue.c **** 		}
2091:../Dave/Generated/FREERTOS/queue.c **** 
2092:../Dave/Generated/FREERTOS/queue.c **** 		if( xPosition == queueOVERWRITE )
 3680              	 .loc 1 2092 0
 3681 00b4 7B68     	 ldr r3,[r7,#4]
 3682 00b6 022B     	 cmp r3,#2
 3683 00b8 05D1     	 bne .L264
2093:../Dave/Generated/FREERTOS/queue.c **** 		{
2094:../Dave/Generated/FREERTOS/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 3684              	 .loc 1 2094 0
 3685 00ba 3B69     	 ldr r3,[r7,#16]
 3686 00bc 002B     	 cmp r3,#0
 3687 00be 02D0     	 beq .L264
2095:../Dave/Generated/FREERTOS/queue.c **** 			{
2096:../Dave/Generated/FREERTOS/queue.c **** 				/* An item is not being added but overwritten, so subtract
2097:../Dave/Generated/FREERTOS/queue.c **** 				one from the recorded number of items in the queue so when
2098:../Dave/Generated/FREERTOS/queue.c **** 				one is added again below the number of recorded items remains
2099:../Dave/Generated/FREERTOS/queue.c **** 				correct. */
2100:../Dave/Generated/FREERTOS/queue.c **** 				--uxMessagesWaiting;
 3688              	 .loc 1 2100 0
 3689 00c0 3B69     	 ldr r3,[r7,#16]
 3690 00c2 013B     	 subs r3,r3,#1
 3691 00c4 3B61     	 str r3,[r7,#16]
 3692              	.L264:
2101:../Dave/Generated/FREERTOS/queue.c **** 			}
2102:../Dave/Generated/FREERTOS/queue.c **** 			else
2103:../Dave/Generated/FREERTOS/queue.c **** 			{
2104:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2105:../Dave/Generated/FREERTOS/queue.c **** 			}
2106:../Dave/Generated/FREERTOS/queue.c **** 		}
2107:../Dave/Generated/FREERTOS/queue.c **** 		else
2108:../Dave/Generated/FREERTOS/queue.c **** 		{
2109:../Dave/Generated/FREERTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2110:../Dave/Generated/FREERTOS/queue.c **** 		}
2111:../Dave/Generated/FREERTOS/queue.c **** 	}
2112:../Dave/Generated/FREERTOS/queue.c **** 
2113:../Dave/Generated/FREERTOS/queue.c **** 	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 3693              	 .loc 1 2113 0
 3694 00c6 3B69     	 ldr r3,[r7,#16]
 3695 00c8 5A1C     	 adds r2,r3,#1
 3696 00ca FB68     	 ldr r3,[r7,#12]
 3697 00cc 9A63     	 str r2,[r3,#56]
2114:../Dave/Generated/FREERTOS/queue.c **** 
2115:../Dave/Generated/FREERTOS/queue.c **** 	return xReturn;
 3698              	 .loc 1 2115 0
 3699 00ce 7B69     	 ldr r3,[r7,#20]
2116:../Dave/Generated/FREERTOS/queue.c **** }
 3700              	 .loc 1 2116 0
 3701 00d0 1846     	 mov r0,r3
 3702 00d2 1837     	 adds r7,r7,#24
 3703              	 .cfi_def_cfa_offset 8
 3704 00d4 BD46     	 mov sp,r7
 3705              	 .cfi_def_cfa_register 13
 3706              	 
 3707 00d6 80BD     	 pop {r7,pc}
 3708              	 .cfi_endproc
 3709              	.LFE163:
 3711              	 .section .text.prvCopyDataFromQueue,"ax",%progbits
 3712              	 .align 2
 3713              	 .thumb
 3714              	 .thumb_func
 3716              	prvCopyDataFromQueue:
 3717              	.LFB164:
2117:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2118:../Dave/Generated/FREERTOS/queue.c **** 
2119:../Dave/Generated/FREERTOS/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
2120:../Dave/Generated/FREERTOS/queue.c **** {
 3718              	 .loc 1 2120 0
 3719              	 .cfi_startproc
 3720              	 
 3721              	 
 3722 0000 80B5     	 push {r7,lr}
 3723              	 .cfi_def_cfa_offset 8
 3724              	 .cfi_offset 7,-8
 3725              	 .cfi_offset 14,-4
 3726 0002 82B0     	 sub sp,sp,#8
 3727              	 .cfi_def_cfa_offset 16
 3728 0004 00AF     	 add r7,sp,#0
 3729              	 .cfi_def_cfa_register 7
 3730 0006 7860     	 str r0,[r7,#4]
 3731 0008 3960     	 str r1,[r7]
2121:../Dave/Generated/FREERTOS/queue.c **** 	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 3732              	 .loc 1 2121 0
 3733 000a 7B68     	 ldr r3,[r7,#4]
 3734 000c 1B6C     	 ldr r3,[r3,#64]
 3735 000e 002B     	 cmp r3,#0
 3736 0010 19D0     	 beq .L268
2122:../Dave/Generated/FREERTOS/queue.c **** 	{
2123:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 3737              	 .loc 1 2123 0
 3738 0012 7B68     	 ldr r3,[r7,#4]
 3739 0014 DA68     	 ldr r2,[r3,#12]
 3740 0016 7B68     	 ldr r3,[r7,#4]
 3741 0018 1B6C     	 ldr r3,[r3,#64]
 3742 001a 1A44     	 add r2,r2,r3
 3743 001c 7B68     	 ldr r3,[r7,#4]
 3744 001e DA60     	 str r2,[r3,#12]
2124:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of t
 3745              	 .loc 1 2124 0
 3746 0020 7B68     	 ldr r3,[r7,#4]
 3747 0022 DA68     	 ldr r2,[r3,#12]
 3748 0024 7B68     	 ldr r3,[r7,#4]
 3749 0026 5B68     	 ldr r3,[r3,#4]
 3750 0028 9A42     	 cmp r2,r3
 3751 002a 03D3     	 bcc .L270
2125:../Dave/Generated/FREERTOS/queue.c **** 		{
2126:../Dave/Generated/FREERTOS/queue.c **** 			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 3752              	 .loc 1 2126 0
 3753 002c 7B68     	 ldr r3,[r7,#4]
 3754 002e 1A68     	 ldr r2,[r3]
 3755 0030 7B68     	 ldr r3,[r7,#4]
 3756 0032 DA60     	 str r2,[r3,#12]
 3757              	.L270:
2127:../Dave/Generated/FREERTOS/queue.c **** 		}
2128:../Dave/Generated/FREERTOS/queue.c **** 		else
2129:../Dave/Generated/FREERTOS/queue.c **** 		{
2130:../Dave/Generated/FREERTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2131:../Dave/Generated/FREERTOS/queue.c **** 		}
2132:../Dave/Generated/FREERTOS/queue.c **** 		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxIte
 3758              	 .loc 1 2132 0
 3759 0034 7B68     	 ldr r3,[r7,#4]
 3760 0036 DA68     	 ldr r2,[r3,#12]
 3761 0038 7B68     	 ldr r3,[r7,#4]
 3762 003a 1B6C     	 ldr r3,[r3,#64]
 3763 003c 3868     	 ldr r0,[r7]
 3764 003e 1146     	 mov r1,r2
 3765 0040 1A46     	 mov r2,r3
 3766 0042 FFF7FEFF 	 bl memcpy
 3767              	.L268:
2133:../Dave/Generated/FREERTOS/queue.c **** 	}
2134:../Dave/Generated/FREERTOS/queue.c **** }
 3768              	 .loc 1 2134 0
 3769 0046 0837     	 adds r7,r7,#8
 3770              	 .cfi_def_cfa_offset 8
 3771 0048 BD46     	 mov sp,r7
 3772              	 .cfi_def_cfa_register 13
 3773              	 
 3774 004a 80BD     	 pop {r7,pc}
 3775              	 .cfi_endproc
 3776              	.LFE164:
 3778              	 .section .text.prvUnlockQueue,"ax",%progbits
 3779              	 .align 2
 3780              	 .thumb
 3781              	 .thumb_func
 3783              	prvUnlockQueue:
 3784              	.LFB165:
2135:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2136:../Dave/Generated/FREERTOS/queue.c **** 
2137:../Dave/Generated/FREERTOS/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue )
2138:../Dave/Generated/FREERTOS/queue.c **** {
 3785              	 .loc 1 2138 0
 3786              	 .cfi_startproc
 3787              	 
 3788              	 
 3789 0000 80B5     	 push {r7,lr}
 3790              	 .cfi_def_cfa_offset 8
 3791              	 .cfi_offset 7,-8
 3792              	 .cfi_offset 14,-4
 3793 0002 84B0     	 sub sp,sp,#16
 3794              	 .cfi_def_cfa_offset 24
 3795 0004 00AF     	 add r7,sp,#0
 3796              	 .cfi_def_cfa_register 7
 3797 0006 7860     	 str r0,[r7,#4]
2139:../Dave/Generated/FREERTOS/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
2140:../Dave/Generated/FREERTOS/queue.c **** 
2141:../Dave/Generated/FREERTOS/queue.c **** 	/* The lock counts contains the number of extra data items placed or
2142:../Dave/Generated/FREERTOS/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
2143:../Dave/Generated/FREERTOS/queue.c **** 	locked items can be added or removed, but the event lists cannot be
2144:../Dave/Generated/FREERTOS/queue.c **** 	updated. */
2145:../Dave/Generated/FREERTOS/queue.c **** 	taskENTER_CRITICAL();
 3798              	 .loc 1 2145 0
 3799 0008 FFF7FEFF 	 bl vPortEnterCritical
 3800              	.LBB205:
2146:../Dave/Generated/FREERTOS/queue.c **** 	{
2147:../Dave/Generated/FREERTOS/queue.c **** 		int8_t cTxLock = pxQueue->cTxLock;
 3801              	 .loc 1 2147 0
 3802 000c 7B68     	 ldr r3,[r7,#4]
 3803 000e 93F84530 	 ldrb r3,[r3,#69]
 3804 0012 FB73     	 strb r3,[r7,#15]
2148:../Dave/Generated/FREERTOS/queue.c **** 
2149:../Dave/Generated/FREERTOS/queue.c **** 		/* See if data was added to the queue while it was locked. */
2150:../Dave/Generated/FREERTOS/queue.c **** 		while( cTxLock > queueLOCKED_UNMODIFIED )
 3805              	 .loc 1 2150 0
 3806 0014 21E0     	 b .L272
 3807              	.L277:
2151:../Dave/Generated/FREERTOS/queue.c **** 		{
2152:../Dave/Generated/FREERTOS/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
2153:../Dave/Generated/FREERTOS/queue.c **** 			blocked waiting for data to become available? */
2154:../Dave/Generated/FREERTOS/queue.c **** 			#if ( configUSE_QUEUE_SETS == 1 )
2155:../Dave/Generated/FREERTOS/queue.c **** 			{
2156:../Dave/Generated/FREERTOS/queue.c **** 				if( pxQueue->pxQueueSetContainer != NULL )
 3808              	 .loc 1 2156 0
 3809 0016 7B68     	 ldr r3,[r7,#4]
 3810 0018 9B6C     	 ldr r3,[r3,#72]
 3811 001a 002B     	 cmp r3,#0
 3812 001c 09D0     	 beq .L273
2157:../Dave/Generated/FREERTOS/queue.c **** 				{
2158:../Dave/Generated/FREERTOS/queue.c **** 					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
 3813              	 .loc 1 2158 0
 3814 001e 7868     	 ldr r0,[r7,#4]
 3815 0020 0021     	 movs r1,#0
 3816 0022 FFF7FEFF 	 bl prvNotifyQueueSetContainer
 3817 0026 0346     	 mov r3,r0
 3818 0028 002B     	 cmp r3,#0
 3819 002a 12D0     	 beq .L274
2159:../Dave/Generated/FREERTOS/queue.c **** 					{
2160:../Dave/Generated/FREERTOS/queue.c **** 						/* The queue is a member of a queue set, and posting to
2161:../Dave/Generated/FREERTOS/queue.c **** 						the queue set caused a higher priority task to unblock.
2162:../Dave/Generated/FREERTOS/queue.c **** 						A context switch is required. */
2163:../Dave/Generated/FREERTOS/queue.c **** 						vTaskMissedYield();
 3820              	 .loc 1 2163 0
 3821 002c FFF7FEFF 	 bl vTaskMissedYield
 3822 0030 0FE0     	 b .L274
 3823              	.L273:
2164:../Dave/Generated/FREERTOS/queue.c **** 					}
2165:../Dave/Generated/FREERTOS/queue.c **** 					else
2166:../Dave/Generated/FREERTOS/queue.c **** 					{
2167:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2168:../Dave/Generated/FREERTOS/queue.c **** 					}
2169:../Dave/Generated/FREERTOS/queue.c **** 				}
2170:../Dave/Generated/FREERTOS/queue.c **** 				else
2171:../Dave/Generated/FREERTOS/queue.c **** 				{
2172:../Dave/Generated/FREERTOS/queue.c **** 					/* Tasks that are removed from the event list will get
2173:../Dave/Generated/FREERTOS/queue.c **** 					added to the pending ready list as the scheduler is still
2174:../Dave/Generated/FREERTOS/queue.c **** 					suspended. */
2175:../Dave/Generated/FREERTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 3824              	 .loc 1 2175 0
 3825 0032 7B68     	 ldr r3,[r7,#4]
 3826 0034 5B6A     	 ldr r3,[r3,#36]
 3827 0036 002B     	 cmp r3,#0
 3828 0038 0AD0     	 beq .L275
2176:../Dave/Generated/FREERTOS/queue.c **** 					{
2177:../Dave/Generated/FREERTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 3829              	 .loc 1 2177 0
 3830 003a 7B68     	 ldr r3,[r7,#4]
 3831 003c 2433     	 adds r3,r3,#36
 3832 003e 1846     	 mov r0,r3
 3833 0040 FFF7FEFF 	 bl xTaskRemoveFromEventList
 3834 0044 0346     	 mov r3,r0
 3835 0046 002B     	 cmp r3,#0
 3836 0048 03D0     	 beq .L274
2178:../Dave/Generated/FREERTOS/queue.c **** 						{
2179:../Dave/Generated/FREERTOS/queue.c **** 							/* The task waiting has a higher priority so record that a
2180:../Dave/Generated/FREERTOS/queue.c **** 							context	switch is required. */
2181:../Dave/Generated/FREERTOS/queue.c **** 							vTaskMissedYield();
 3837              	 .loc 1 2181 0
 3838 004a FFF7FEFF 	 bl vTaskMissedYield
 3839 004e 00E0     	 b .L274
 3840              	.L275:
2182:../Dave/Generated/FREERTOS/queue.c **** 						}
2183:../Dave/Generated/FREERTOS/queue.c **** 						else
2184:../Dave/Generated/FREERTOS/queue.c **** 						{
2185:../Dave/Generated/FREERTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
2186:../Dave/Generated/FREERTOS/queue.c **** 						}
2187:../Dave/Generated/FREERTOS/queue.c **** 					}
2188:../Dave/Generated/FREERTOS/queue.c **** 					else
2189:../Dave/Generated/FREERTOS/queue.c **** 					{
2190:../Dave/Generated/FREERTOS/queue.c **** 						break;
 3841              	 .loc 1 2190 0
 3842 0050 07E0     	 b .L276
 3843              	.L274:
2191:../Dave/Generated/FREERTOS/queue.c **** 					}
2192:../Dave/Generated/FREERTOS/queue.c **** 				}
2193:../Dave/Generated/FREERTOS/queue.c **** 			}
2194:../Dave/Generated/FREERTOS/queue.c **** 			#else /* configUSE_QUEUE_SETS */
2195:../Dave/Generated/FREERTOS/queue.c **** 			{
2196:../Dave/Generated/FREERTOS/queue.c **** 				/* Tasks that are removed from the event list will get added to
2197:../Dave/Generated/FREERTOS/queue.c **** 				the pending ready list as the scheduler is still suspended. */
2198:../Dave/Generated/FREERTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2199:../Dave/Generated/FREERTOS/queue.c **** 				{
2200:../Dave/Generated/FREERTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2201:../Dave/Generated/FREERTOS/queue.c **** 					{
2202:../Dave/Generated/FREERTOS/queue.c **** 						/* The task waiting has a higher priority so record that
2203:../Dave/Generated/FREERTOS/queue.c **** 						a context switch is required. */
2204:../Dave/Generated/FREERTOS/queue.c **** 						vTaskMissedYield();
2205:../Dave/Generated/FREERTOS/queue.c **** 					}
2206:../Dave/Generated/FREERTOS/queue.c **** 					else
2207:../Dave/Generated/FREERTOS/queue.c **** 					{
2208:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2209:../Dave/Generated/FREERTOS/queue.c **** 					}
2210:../Dave/Generated/FREERTOS/queue.c **** 				}
2211:../Dave/Generated/FREERTOS/queue.c **** 				else
2212:../Dave/Generated/FREERTOS/queue.c **** 				{
2213:../Dave/Generated/FREERTOS/queue.c **** 					break;
2214:../Dave/Generated/FREERTOS/queue.c **** 				}
2215:../Dave/Generated/FREERTOS/queue.c **** 			}
2216:../Dave/Generated/FREERTOS/queue.c **** 			#endif /* configUSE_QUEUE_SETS */
2217:../Dave/Generated/FREERTOS/queue.c **** 
2218:../Dave/Generated/FREERTOS/queue.c **** 			--cTxLock;
 3844              	 .loc 1 2218 0
 3845 0052 FB7B     	 ldrb r3,[r7,#15]
 3846 0054 013B     	 subs r3,r3,#1
 3847 0056 DBB2     	 uxtb r3,r3
 3848 0058 FB73     	 strb r3,[r7,#15]
 3849              	.L272:
2150:../Dave/Generated/FREERTOS/queue.c **** 		{
 3850              	 .loc 1 2150 0
 3851 005a 97F90F30 	 ldrsb r3,[r7,#15]
 3852 005e 002B     	 cmp r3,#0
 3853 0060 D9DC     	 bgt .L277
 3854              	.L276:
2219:../Dave/Generated/FREERTOS/queue.c **** 		}
2220:../Dave/Generated/FREERTOS/queue.c **** 
2221:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
 3855              	 .loc 1 2221 0
 3856 0062 7B68     	 ldr r3,[r7,#4]
 3857 0064 FF22     	 movs r2,#255
 3858 0066 83F84520 	 strb r2,[r3,#69]
 3859              	.LBE205:
2222:../Dave/Generated/FREERTOS/queue.c **** 	}
2223:../Dave/Generated/FREERTOS/queue.c **** 	taskEXIT_CRITICAL();
 3860              	 .loc 1 2223 0
 3861 006a FFF7FEFF 	 bl vPortExitCritical
2224:../Dave/Generated/FREERTOS/queue.c **** 
2225:../Dave/Generated/FREERTOS/queue.c **** 	/* Do the same for the Rx lock. */
2226:../Dave/Generated/FREERTOS/queue.c **** 	taskENTER_CRITICAL();
 3862              	 .loc 1 2226 0
 3863 006e FFF7FEFF 	 bl vPortEnterCritical
 3864              	.LBB206:
2227:../Dave/Generated/FREERTOS/queue.c **** 	{
2228:../Dave/Generated/FREERTOS/queue.c **** 		int8_t cRxLock = pxQueue->cRxLock;
 3865              	 .loc 1 2228 0
 3866 0072 7B68     	 ldr r3,[r7,#4]
 3867 0074 93F84430 	 ldrb r3,[r3,#68]
 3868 0078 BB73     	 strb r3,[r7,#14]
2229:../Dave/Generated/FREERTOS/queue.c **** 
2230:../Dave/Generated/FREERTOS/queue.c **** 		while( cRxLock > queueLOCKED_UNMODIFIED )
 3869              	 .loc 1 2230 0
 3870 007a 13E0     	 b .L278
 3871              	.L282:
2231:../Dave/Generated/FREERTOS/queue.c **** 		{
2232:../Dave/Generated/FREERTOS/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 3872              	 .loc 1 2232 0
 3873 007c 7B68     	 ldr r3,[r7,#4]
 3874 007e 1B69     	 ldr r3,[r3,#16]
 3875 0080 002B     	 cmp r3,#0
 3876 0082 0ED0     	 beq .L279
2233:../Dave/Generated/FREERTOS/queue.c **** 			{
2234:../Dave/Generated/FREERTOS/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 3877              	 .loc 1 2234 0
 3878 0084 7B68     	 ldr r3,[r7,#4]
 3879 0086 1033     	 adds r3,r3,#16
 3880 0088 1846     	 mov r0,r3
 3881 008a FFF7FEFF 	 bl xTaskRemoveFromEventList
 3882 008e 0346     	 mov r3,r0
 3883 0090 002B     	 cmp r3,#0
 3884 0092 01D0     	 beq .L280
2235:../Dave/Generated/FREERTOS/queue.c **** 				{
2236:../Dave/Generated/FREERTOS/queue.c **** 					vTaskMissedYield();
 3885              	 .loc 1 2236 0
 3886 0094 FFF7FEFF 	 bl vTaskMissedYield
 3887              	.L280:
2237:../Dave/Generated/FREERTOS/queue.c **** 				}
2238:../Dave/Generated/FREERTOS/queue.c **** 				else
2239:../Dave/Generated/FREERTOS/queue.c **** 				{
2240:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2241:../Dave/Generated/FREERTOS/queue.c **** 				}
2242:../Dave/Generated/FREERTOS/queue.c **** 
2243:../Dave/Generated/FREERTOS/queue.c **** 				--cRxLock;
 3888              	 .loc 1 2243 0
 3889 0098 BB7B     	 ldrb r3,[r7,#14]
 3890 009a 013B     	 subs r3,r3,#1
 3891 009c DBB2     	 uxtb r3,r3
 3892 009e BB73     	 strb r3,[r7,#14]
 3893 00a0 00E0     	 b .L278
 3894              	.L279:
2244:../Dave/Generated/FREERTOS/queue.c **** 			}
2245:../Dave/Generated/FREERTOS/queue.c **** 			else
2246:../Dave/Generated/FREERTOS/queue.c **** 			{
2247:../Dave/Generated/FREERTOS/queue.c **** 				break;
 3895              	 .loc 1 2247 0
 3896 00a2 03E0     	 b .L281
 3897              	.L278:
2230:../Dave/Generated/FREERTOS/queue.c **** 		{
 3898              	 .loc 1 2230 0
 3899 00a4 97F90E30 	 ldrsb r3,[r7,#14]
 3900 00a8 002B     	 cmp r3,#0
 3901 00aa E7DC     	 bgt .L282
 3902              	.L281:
2248:../Dave/Generated/FREERTOS/queue.c **** 			}
2249:../Dave/Generated/FREERTOS/queue.c **** 		}
2250:../Dave/Generated/FREERTOS/queue.c **** 
2251:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
 3903              	 .loc 1 2251 0
 3904 00ac 7B68     	 ldr r3,[r7,#4]
 3905 00ae FF22     	 movs r2,#255
 3906 00b0 83F84420 	 strb r2,[r3,#68]
 3907              	.LBE206:
2252:../Dave/Generated/FREERTOS/queue.c **** 	}
2253:../Dave/Generated/FREERTOS/queue.c **** 	taskEXIT_CRITICAL();
 3908              	 .loc 1 2253 0
 3909 00b4 FFF7FEFF 	 bl vPortExitCritical
2254:../Dave/Generated/FREERTOS/queue.c **** }
 3910              	 .loc 1 2254 0
 3911 00b8 1037     	 adds r7,r7,#16
 3912              	 .cfi_def_cfa_offset 8
 3913 00ba BD46     	 mov sp,r7
 3914              	 .cfi_def_cfa_register 13
 3915              	 
 3916 00bc 80BD     	 pop {r7,pc}
 3917              	 .cfi_endproc
 3918              	.LFE165:
 3920 00be 00BF     	 .section .text.prvIsQueueEmpty,"ax",%progbits
 3921              	 .align 2
 3922              	 .thumb
 3923              	 .thumb_func
 3925              	prvIsQueueEmpty:
 3926              	.LFB166:
2255:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2256:../Dave/Generated/FREERTOS/queue.c **** 
2257:../Dave/Generated/FREERTOS/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
2258:../Dave/Generated/FREERTOS/queue.c **** {
 3927              	 .loc 1 2258 0
 3928              	 .cfi_startproc
 3929              	 
 3930              	 
 3931 0000 80B5     	 push {r7,lr}
 3932              	 .cfi_def_cfa_offset 8
 3933              	 .cfi_offset 7,-8
 3934              	 .cfi_offset 14,-4
 3935 0002 84B0     	 sub sp,sp,#16
 3936              	 .cfi_def_cfa_offset 24
 3937 0004 00AF     	 add r7,sp,#0
 3938              	 .cfi_def_cfa_register 7
 3939 0006 7860     	 str r0,[r7,#4]
2259:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xReturn;
2260:../Dave/Generated/FREERTOS/queue.c **** 
2261:../Dave/Generated/FREERTOS/queue.c **** 	taskENTER_CRITICAL();
 3940              	 .loc 1 2261 0
 3941 0008 FFF7FEFF 	 bl vPortEnterCritical
2262:../Dave/Generated/FREERTOS/queue.c **** 	{
2263:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 3942              	 .loc 1 2263 0
 3943 000c 7B68     	 ldr r3,[r7,#4]
 3944 000e 9B6B     	 ldr r3,[r3,#56]
 3945 0010 002B     	 cmp r3,#0
 3946 0012 02D1     	 bne .L284
2264:../Dave/Generated/FREERTOS/queue.c **** 		{
2265:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdTRUE;
 3947              	 .loc 1 2265 0
 3948 0014 0123     	 movs r3,#1
 3949 0016 FB60     	 str r3,[r7,#12]
 3950 0018 01E0     	 b .L285
 3951              	.L284:
2266:../Dave/Generated/FREERTOS/queue.c **** 		}
2267:../Dave/Generated/FREERTOS/queue.c **** 		else
2268:../Dave/Generated/FREERTOS/queue.c **** 		{
2269:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdFALSE;
 3952              	 .loc 1 2269 0
 3953 001a 0023     	 movs r3,#0
 3954 001c FB60     	 str r3,[r7,#12]
 3955              	.L285:
2270:../Dave/Generated/FREERTOS/queue.c **** 		}
2271:../Dave/Generated/FREERTOS/queue.c **** 	}
2272:../Dave/Generated/FREERTOS/queue.c **** 	taskEXIT_CRITICAL();
 3956              	 .loc 1 2272 0
 3957 001e FFF7FEFF 	 bl vPortExitCritical
2273:../Dave/Generated/FREERTOS/queue.c **** 
2274:../Dave/Generated/FREERTOS/queue.c **** 	return xReturn;
 3958              	 .loc 1 2274 0
 3959 0022 FB68     	 ldr r3,[r7,#12]
2275:../Dave/Generated/FREERTOS/queue.c **** }
 3960              	 .loc 1 2275 0
 3961 0024 1846     	 mov r0,r3
 3962 0026 1037     	 adds r7,r7,#16
 3963              	 .cfi_def_cfa_offset 8
 3964 0028 BD46     	 mov sp,r7
 3965              	 .cfi_def_cfa_register 13
 3966              	 
 3967 002a 80BD     	 pop {r7,pc}
 3968              	 .cfi_endproc
 3969              	.LFE166:
 3971              	 .section .text.xQueueIsQueueEmptyFromISR,"ax",%progbits
 3972              	 .align 2
 3973              	 .global xQueueIsQueueEmptyFromISR
 3974              	 .thumb
 3975              	 .thumb_func
 3977              	xQueueIsQueueEmptyFromISR:
 3978              	.LFB167:
2276:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2277:../Dave/Generated/FREERTOS/queue.c **** 
2278:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
2279:../Dave/Generated/FREERTOS/queue.c **** {
 3979              	 .loc 1 2279 0
 3980              	 .cfi_startproc
 3981              	 
 3982              	 
 3983              	 
 3984 0000 80B4     	 push {r7}
 3985              	 .cfi_def_cfa_offset 4
 3986              	 .cfi_offset 7,-4
 3987 0002 85B0     	 sub sp,sp,#20
 3988              	 .cfi_def_cfa_offset 24
 3989 0004 00AF     	 add r7,sp,#0
 3990              	 .cfi_def_cfa_register 7
 3991 0006 7860     	 str r0,[r7,#4]
2280:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xReturn;
2281:../Dave/Generated/FREERTOS/queue.c **** 
2282:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( xQueue );
 3992              	 .loc 1 2282 0
 3993 0008 7B68     	 ldr r3,[r7,#4]
 3994 000a 002B     	 cmp r3,#0
 3995 000c 09D1     	 bne .L288
 3996              	.LBB207:
 3997              	.LBB208:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 3998              	 .loc 2 195 0 discriminator 1
 3999              	
 4000 000e 4FF0FC03 	 mov r3,#252
 4001 0012 83F31188 	 msr basepri,r3
 4002 0016 BFF36F8F 	 isb 
 4003 001a BFF34F8F 	 dsb 
 4004              	
 4005              	
 4006              	 .thumb
 4007 001e BB60     	 str r3,[r7,#8]
 4008              	.L289:
 4009              	.LBE208:
 4010              	.LBE207:
 4011              	 .loc 1 2282 0 discriminator 1
 4012 0020 FEE7     	 b .L289
 4013              	.L288:
2283:../Dave/Generated/FREERTOS/queue.c **** 	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
 4014              	 .loc 1 2283 0
 4015 0022 7B68     	 ldr r3,[r7,#4]
 4016 0024 9B6B     	 ldr r3,[r3,#56]
 4017 0026 002B     	 cmp r3,#0
 4018 0028 02D1     	 bne .L290
2284:../Dave/Generated/FREERTOS/queue.c **** 	{
2285:../Dave/Generated/FREERTOS/queue.c **** 		xReturn = pdTRUE;
 4019              	 .loc 1 2285 0
 4020 002a 0123     	 movs r3,#1
 4021 002c FB60     	 str r3,[r7,#12]
 4022 002e 01E0     	 b .L291
 4023              	.L290:
2286:../Dave/Generated/FREERTOS/queue.c **** 	}
2287:../Dave/Generated/FREERTOS/queue.c **** 	else
2288:../Dave/Generated/FREERTOS/queue.c **** 	{
2289:../Dave/Generated/FREERTOS/queue.c **** 		xReturn = pdFALSE;
 4024              	 .loc 1 2289 0
 4025 0030 0023     	 movs r3,#0
 4026 0032 FB60     	 str r3,[r7,#12]
 4027              	.L291:
2290:../Dave/Generated/FREERTOS/queue.c **** 	}
2291:../Dave/Generated/FREERTOS/queue.c **** 
2292:../Dave/Generated/FREERTOS/queue.c **** 	return xReturn;
 4028              	 .loc 1 2292 0
 4029 0034 FB68     	 ldr r3,[r7,#12]
2293:../Dave/Generated/FREERTOS/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 4030              	 .loc 1 2293 0
 4031 0036 1846     	 mov r0,r3
 4032 0038 1437     	 adds r7,r7,#20
 4033              	 .cfi_def_cfa_offset 4
 4034 003a BD46     	 mov sp,r7
 4035              	 .cfi_def_cfa_register 13
 4036              	 
 4037 003c 5DF8047B 	 ldr r7,[sp],#4
 4038              	 .cfi_restore 7
 4039              	 .cfi_def_cfa_offset 0
 4040 0040 7047     	 bx lr
 4041              	 .cfi_endproc
 4042              	.LFE167:
 4044 0042 00BF     	 .section .text.prvIsQueueFull,"ax",%progbits
 4045              	 .align 2
 4046              	 .thumb
 4047              	 .thumb_func
 4049              	prvIsQueueFull:
 4050              	.LFB168:
2294:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2295:../Dave/Generated/FREERTOS/queue.c **** 
2296:../Dave/Generated/FREERTOS/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
2297:../Dave/Generated/FREERTOS/queue.c **** {
 4051              	 .loc 1 2297 0
 4052              	 .cfi_startproc
 4053              	 
 4054              	 
 4055 0000 80B5     	 push {r7,lr}
 4056              	 .cfi_def_cfa_offset 8
 4057              	 .cfi_offset 7,-8
 4058              	 .cfi_offset 14,-4
 4059 0002 84B0     	 sub sp,sp,#16
 4060              	 .cfi_def_cfa_offset 24
 4061 0004 00AF     	 add r7,sp,#0
 4062              	 .cfi_def_cfa_register 7
 4063 0006 7860     	 str r0,[r7,#4]
2298:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xReturn;
2299:../Dave/Generated/FREERTOS/queue.c **** 
2300:../Dave/Generated/FREERTOS/queue.c **** 	taskENTER_CRITICAL();
 4064              	 .loc 1 2300 0
 4065 0008 FFF7FEFF 	 bl vPortEnterCritical
2301:../Dave/Generated/FREERTOS/queue.c **** 	{
2302:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 4066              	 .loc 1 2302 0
 4067 000c 7B68     	 ldr r3,[r7,#4]
 4068 000e 9A6B     	 ldr r2,[r3,#56]
 4069 0010 7B68     	 ldr r3,[r7,#4]
 4070 0012 DB6B     	 ldr r3,[r3,#60]
 4071 0014 9A42     	 cmp r2,r3
 4072 0016 02D1     	 bne .L294
2303:../Dave/Generated/FREERTOS/queue.c **** 		{
2304:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdTRUE;
 4073              	 .loc 1 2304 0
 4074 0018 0123     	 movs r3,#1
 4075 001a FB60     	 str r3,[r7,#12]
 4076 001c 01E0     	 b .L295
 4077              	.L294:
2305:../Dave/Generated/FREERTOS/queue.c **** 		}
2306:../Dave/Generated/FREERTOS/queue.c **** 		else
2307:../Dave/Generated/FREERTOS/queue.c **** 		{
2308:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdFALSE;
 4078              	 .loc 1 2308 0
 4079 001e 0023     	 movs r3,#0
 4080 0020 FB60     	 str r3,[r7,#12]
 4081              	.L295:
2309:../Dave/Generated/FREERTOS/queue.c **** 		}
2310:../Dave/Generated/FREERTOS/queue.c **** 	}
2311:../Dave/Generated/FREERTOS/queue.c **** 	taskEXIT_CRITICAL();
 4082              	 .loc 1 2311 0
 4083 0022 FFF7FEFF 	 bl vPortExitCritical
2312:../Dave/Generated/FREERTOS/queue.c **** 
2313:../Dave/Generated/FREERTOS/queue.c **** 	return xReturn;
 4084              	 .loc 1 2313 0
 4085 0026 FB68     	 ldr r3,[r7,#12]
2314:../Dave/Generated/FREERTOS/queue.c **** }
 4086              	 .loc 1 2314 0
 4087 0028 1846     	 mov r0,r3
 4088 002a 1037     	 adds r7,r7,#16
 4089              	 .cfi_def_cfa_offset 8
 4090 002c BD46     	 mov sp,r7
 4091              	 .cfi_def_cfa_register 13
 4092              	 
 4093 002e 80BD     	 pop {r7,pc}
 4094              	 .cfi_endproc
 4095              	.LFE168:
 4097              	 .section .text.xQueueIsQueueFullFromISR,"ax",%progbits
 4098              	 .align 2
 4099              	 .global xQueueIsQueueFullFromISR
 4100              	 .thumb
 4101              	 .thumb_func
 4103              	xQueueIsQueueFullFromISR:
 4104              	.LFB169:
2315:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2316:../Dave/Generated/FREERTOS/queue.c **** 
2317:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
2318:../Dave/Generated/FREERTOS/queue.c **** {
 4105              	 .loc 1 2318 0
 4106              	 .cfi_startproc
 4107              	 
 4108              	 
 4109              	 
 4110 0000 80B4     	 push {r7}
 4111              	 .cfi_def_cfa_offset 4
 4112              	 .cfi_offset 7,-4
 4113 0002 85B0     	 sub sp,sp,#20
 4114              	 .cfi_def_cfa_offset 24
 4115 0004 00AF     	 add r7,sp,#0
 4116              	 .cfi_def_cfa_register 7
 4117 0006 7860     	 str r0,[r7,#4]
2319:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xReturn;
2320:../Dave/Generated/FREERTOS/queue.c **** 
2321:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( xQueue );
 4118              	 .loc 1 2321 0
 4119 0008 7B68     	 ldr r3,[r7,#4]
 4120 000a 002B     	 cmp r3,#0
 4121 000c 09D1     	 bne .L298
 4122              	.LBB209:
 4123              	.LBB210:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 4124              	 .loc 2 195 0 discriminator 1
 4125              	
 4126 000e 4FF0FC03 	 mov r3,#252
 4127 0012 83F31188 	 msr basepri,r3
 4128 0016 BFF36F8F 	 isb 
 4129 001a BFF34F8F 	 dsb 
 4130              	
 4131              	
 4132              	 .thumb
 4133 001e BB60     	 str r3,[r7,#8]
 4134              	.L299:
 4135              	.LBE210:
 4136              	.LBE209:
 4137              	 .loc 1 2321 0 discriminator 1
 4138 0020 FEE7     	 b .L299
 4139              	.L298:
2322:../Dave/Generated/FREERTOS/queue.c **** 	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
 4140              	 .loc 1 2322 0
 4141 0022 7B68     	 ldr r3,[r7,#4]
 4142 0024 9A6B     	 ldr r2,[r3,#56]
 4143 0026 7B68     	 ldr r3,[r7,#4]
 4144 0028 DB6B     	 ldr r3,[r3,#60]
 4145 002a 9A42     	 cmp r2,r3
 4146 002c 02D1     	 bne .L300
2323:../Dave/Generated/FREERTOS/queue.c **** 	{
2324:../Dave/Generated/FREERTOS/queue.c **** 		xReturn = pdTRUE;
 4147              	 .loc 1 2324 0
 4148 002e 0123     	 movs r3,#1
 4149 0030 FB60     	 str r3,[r7,#12]
 4150 0032 01E0     	 b .L301
 4151              	.L300:
2325:../Dave/Generated/FREERTOS/queue.c **** 	}
2326:../Dave/Generated/FREERTOS/queue.c **** 	else
2327:../Dave/Generated/FREERTOS/queue.c **** 	{
2328:../Dave/Generated/FREERTOS/queue.c **** 		xReturn = pdFALSE;
 4152              	 .loc 1 2328 0
 4153 0034 0023     	 movs r3,#0
 4154 0036 FB60     	 str r3,[r7,#12]
 4155              	.L301:
2329:../Dave/Generated/FREERTOS/queue.c **** 	}
2330:../Dave/Generated/FREERTOS/queue.c **** 
2331:../Dave/Generated/FREERTOS/queue.c **** 	return xReturn;
 4156              	 .loc 1 2331 0
 4157 0038 FB68     	 ldr r3,[r7,#12]
2332:../Dave/Generated/FREERTOS/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 4158              	 .loc 1 2332 0
 4159 003a 1846     	 mov r0,r3
 4160 003c 1437     	 adds r7,r7,#20
 4161              	 .cfi_def_cfa_offset 4
 4162 003e BD46     	 mov sp,r7
 4163              	 .cfi_def_cfa_register 13
 4164              	 
 4165 0040 5DF8047B 	 ldr r7,[sp],#4
 4166              	 .cfi_restore 7
 4167              	 .cfi_def_cfa_offset 0
 4168 0044 7047     	 bx lr
 4169              	 .cfi_endproc
 4170              	.LFE169:
 4172 0046 00BF     	 .section .text.vQueueAddToRegistry,"ax",%progbits
 4173              	 .align 2
 4174              	 .global vQueueAddToRegistry
 4175              	 .thumb
 4176              	 .thumb_func
 4178              	vQueueAddToRegistry:
 4179              	.LFB170:
2333:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2334:../Dave/Generated/FREERTOS/queue.c **** 
2335:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2336:../Dave/Generated/FREERTOS/queue.c **** 
2337:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait 
2338:../Dave/Generated/FREERTOS/queue.c **** 	{
2339:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xReturn;
2340:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2341:../Dave/Generated/FREERTOS/queue.c **** 
2342:../Dave/Generated/FREERTOS/queue.c **** 		/* If the queue is already full we may have to block.  A critical section
2343:../Dave/Generated/FREERTOS/queue.c **** 		is required to prevent an interrupt removing something from the queue
2344:../Dave/Generated/FREERTOS/queue.c **** 		between the check to see if the queue is full and blocking on the queue. */
2345:../Dave/Generated/FREERTOS/queue.c **** 		portDISABLE_INTERRUPTS();
2346:../Dave/Generated/FREERTOS/queue.c **** 		{
2347:../Dave/Generated/FREERTOS/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
2348:../Dave/Generated/FREERTOS/queue.c **** 			{
2349:../Dave/Generated/FREERTOS/queue.c **** 				/* The queue is full - do we want to block or just leave without
2350:../Dave/Generated/FREERTOS/queue.c **** 				posting? */
2351:../Dave/Generated/FREERTOS/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
2352:../Dave/Generated/FREERTOS/queue.c **** 				{
2353:../Dave/Generated/FREERTOS/queue.c **** 					/* As this is called from a coroutine we cannot block directly, but
2354:../Dave/Generated/FREERTOS/queue.c **** 					return indicating that we need to block. */
2355:../Dave/Generated/FREERTOS/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
2356:../Dave/Generated/FREERTOS/queue.c **** 					portENABLE_INTERRUPTS();
2357:../Dave/Generated/FREERTOS/queue.c **** 					return errQUEUE_BLOCKED;
2358:../Dave/Generated/FREERTOS/queue.c **** 				}
2359:../Dave/Generated/FREERTOS/queue.c **** 				else
2360:../Dave/Generated/FREERTOS/queue.c **** 				{
2361:../Dave/Generated/FREERTOS/queue.c **** 					portENABLE_INTERRUPTS();
2362:../Dave/Generated/FREERTOS/queue.c **** 					return errQUEUE_FULL;
2363:../Dave/Generated/FREERTOS/queue.c **** 				}
2364:../Dave/Generated/FREERTOS/queue.c **** 			}
2365:../Dave/Generated/FREERTOS/queue.c **** 		}
2366:../Dave/Generated/FREERTOS/queue.c **** 		portENABLE_INTERRUPTS();
2367:../Dave/Generated/FREERTOS/queue.c **** 
2368:../Dave/Generated/FREERTOS/queue.c **** 		portDISABLE_INTERRUPTS();
2369:../Dave/Generated/FREERTOS/queue.c **** 		{
2370:../Dave/Generated/FREERTOS/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2371:../Dave/Generated/FREERTOS/queue.c **** 			{
2372:../Dave/Generated/FREERTOS/queue.c **** 				/* There is room in the queue, copy the data into the queue. */
2373:../Dave/Generated/FREERTOS/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2374:../Dave/Generated/FREERTOS/queue.c **** 				xReturn = pdPASS;
2375:../Dave/Generated/FREERTOS/queue.c **** 
2376:../Dave/Generated/FREERTOS/queue.c **** 				/* Were any co-routines waiting for data to become available? */
2377:../Dave/Generated/FREERTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2378:../Dave/Generated/FREERTOS/queue.c **** 				{
2379:../Dave/Generated/FREERTOS/queue.c **** 					/* In this instance the co-routine could be placed directly
2380:../Dave/Generated/FREERTOS/queue.c **** 					into the ready list as we are within a critical section.
2381:../Dave/Generated/FREERTOS/queue.c **** 					Instead the same pending ready list mechanism is used as if
2382:../Dave/Generated/FREERTOS/queue.c **** 					the event were caused from within an interrupt. */
2383:../Dave/Generated/FREERTOS/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2384:../Dave/Generated/FREERTOS/queue.c **** 					{
2385:../Dave/Generated/FREERTOS/queue.c **** 						/* The co-routine waiting has a higher priority so record
2386:../Dave/Generated/FREERTOS/queue.c **** 						that a yield might be appropriate. */
2387:../Dave/Generated/FREERTOS/queue.c **** 						xReturn = errQUEUE_YIELD;
2388:../Dave/Generated/FREERTOS/queue.c **** 					}
2389:../Dave/Generated/FREERTOS/queue.c **** 					else
2390:../Dave/Generated/FREERTOS/queue.c **** 					{
2391:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2392:../Dave/Generated/FREERTOS/queue.c **** 					}
2393:../Dave/Generated/FREERTOS/queue.c **** 				}
2394:../Dave/Generated/FREERTOS/queue.c **** 				else
2395:../Dave/Generated/FREERTOS/queue.c **** 				{
2396:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2397:../Dave/Generated/FREERTOS/queue.c **** 				}
2398:../Dave/Generated/FREERTOS/queue.c **** 			}
2399:../Dave/Generated/FREERTOS/queue.c **** 			else
2400:../Dave/Generated/FREERTOS/queue.c **** 			{
2401:../Dave/Generated/FREERTOS/queue.c **** 				xReturn = errQUEUE_FULL;
2402:../Dave/Generated/FREERTOS/queue.c **** 			}
2403:../Dave/Generated/FREERTOS/queue.c **** 		}
2404:../Dave/Generated/FREERTOS/queue.c **** 		portENABLE_INTERRUPTS();
2405:../Dave/Generated/FREERTOS/queue.c **** 
2406:../Dave/Generated/FREERTOS/queue.c **** 		return xReturn;
2407:../Dave/Generated/FREERTOS/queue.c **** 	}
2408:../Dave/Generated/FREERTOS/queue.c **** 
2409:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_CO_ROUTINES */
2410:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2411:../Dave/Generated/FREERTOS/queue.c **** 
2412:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2413:../Dave/Generated/FREERTOS/queue.c **** 
2414:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
2415:../Dave/Generated/FREERTOS/queue.c **** 	{
2416:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xReturn;
2417:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2418:../Dave/Generated/FREERTOS/queue.c **** 
2419:../Dave/Generated/FREERTOS/queue.c **** 		/* If the queue is already empty we may have to block.  A critical section
2420:../Dave/Generated/FREERTOS/queue.c **** 		is required to prevent an interrupt adding something to the queue
2421:../Dave/Generated/FREERTOS/queue.c **** 		between the check to see if the queue is empty and blocking on the queue. */
2422:../Dave/Generated/FREERTOS/queue.c **** 		portDISABLE_INTERRUPTS();
2423:../Dave/Generated/FREERTOS/queue.c **** 		{
2424:../Dave/Generated/FREERTOS/queue.c **** 			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
2425:../Dave/Generated/FREERTOS/queue.c **** 			{
2426:../Dave/Generated/FREERTOS/queue.c **** 				/* There are no messages in the queue, do we want to block or just
2427:../Dave/Generated/FREERTOS/queue.c **** 				leave with nothing? */
2428:../Dave/Generated/FREERTOS/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
2429:../Dave/Generated/FREERTOS/queue.c **** 				{
2430:../Dave/Generated/FREERTOS/queue.c **** 					/* As this is a co-routine we cannot block directly, but return
2431:../Dave/Generated/FREERTOS/queue.c **** 					indicating that we need to block. */
2432:../Dave/Generated/FREERTOS/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
2433:../Dave/Generated/FREERTOS/queue.c **** 					portENABLE_INTERRUPTS();
2434:../Dave/Generated/FREERTOS/queue.c **** 					return errQUEUE_BLOCKED;
2435:../Dave/Generated/FREERTOS/queue.c **** 				}
2436:../Dave/Generated/FREERTOS/queue.c **** 				else
2437:../Dave/Generated/FREERTOS/queue.c **** 				{
2438:../Dave/Generated/FREERTOS/queue.c **** 					portENABLE_INTERRUPTS();
2439:../Dave/Generated/FREERTOS/queue.c **** 					return errQUEUE_FULL;
2440:../Dave/Generated/FREERTOS/queue.c **** 				}
2441:../Dave/Generated/FREERTOS/queue.c **** 			}
2442:../Dave/Generated/FREERTOS/queue.c **** 			else
2443:../Dave/Generated/FREERTOS/queue.c **** 			{
2444:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2445:../Dave/Generated/FREERTOS/queue.c **** 			}
2446:../Dave/Generated/FREERTOS/queue.c **** 		}
2447:../Dave/Generated/FREERTOS/queue.c **** 		portENABLE_INTERRUPTS();
2448:../Dave/Generated/FREERTOS/queue.c **** 
2449:../Dave/Generated/FREERTOS/queue.c **** 		portDISABLE_INTERRUPTS();
2450:../Dave/Generated/FREERTOS/queue.c **** 		{
2451:../Dave/Generated/FREERTOS/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2452:../Dave/Generated/FREERTOS/queue.c **** 			{
2453:../Dave/Generated/FREERTOS/queue.c **** 				/* Data is available from the queue. */
2454:../Dave/Generated/FREERTOS/queue.c **** 				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
2455:../Dave/Generated/FREERTOS/queue.c **** 				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
2456:../Dave/Generated/FREERTOS/queue.c **** 				{
2457:../Dave/Generated/FREERTOS/queue.c **** 					pxQueue->u.pcReadFrom = pxQueue->pcHead;
2458:../Dave/Generated/FREERTOS/queue.c **** 				}
2459:../Dave/Generated/FREERTOS/queue.c **** 				else
2460:../Dave/Generated/FREERTOS/queue.c **** 				{
2461:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2462:../Dave/Generated/FREERTOS/queue.c **** 				}
2463:../Dave/Generated/FREERTOS/queue.c **** 				--( pxQueue->uxMessagesWaiting );
2464:../Dave/Generated/FREERTOS/queue.c **** 				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->u
2465:../Dave/Generated/FREERTOS/queue.c **** 
2466:../Dave/Generated/FREERTOS/queue.c **** 				xReturn = pdPASS;
2467:../Dave/Generated/FREERTOS/queue.c **** 
2468:../Dave/Generated/FREERTOS/queue.c **** 				/* Were any co-routines waiting for space to become available? */
2469:../Dave/Generated/FREERTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2470:../Dave/Generated/FREERTOS/queue.c **** 				{
2471:../Dave/Generated/FREERTOS/queue.c **** 					/* In this instance the co-routine could be placed directly
2472:../Dave/Generated/FREERTOS/queue.c **** 					into the ready list as we are within a critical section.
2473:../Dave/Generated/FREERTOS/queue.c **** 					Instead the same pending ready list mechanism is used as if
2474:../Dave/Generated/FREERTOS/queue.c **** 					the event were caused from within an interrupt. */
2475:../Dave/Generated/FREERTOS/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2476:../Dave/Generated/FREERTOS/queue.c **** 					{
2477:../Dave/Generated/FREERTOS/queue.c **** 						xReturn = errQUEUE_YIELD;
2478:../Dave/Generated/FREERTOS/queue.c **** 					}
2479:../Dave/Generated/FREERTOS/queue.c **** 					else
2480:../Dave/Generated/FREERTOS/queue.c **** 					{
2481:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2482:../Dave/Generated/FREERTOS/queue.c **** 					}
2483:../Dave/Generated/FREERTOS/queue.c **** 				}
2484:../Dave/Generated/FREERTOS/queue.c **** 				else
2485:../Dave/Generated/FREERTOS/queue.c **** 				{
2486:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2487:../Dave/Generated/FREERTOS/queue.c **** 				}
2488:../Dave/Generated/FREERTOS/queue.c **** 			}
2489:../Dave/Generated/FREERTOS/queue.c **** 			else
2490:../Dave/Generated/FREERTOS/queue.c **** 			{
2491:../Dave/Generated/FREERTOS/queue.c **** 				xReturn = pdFAIL;
2492:../Dave/Generated/FREERTOS/queue.c **** 			}
2493:../Dave/Generated/FREERTOS/queue.c **** 		}
2494:../Dave/Generated/FREERTOS/queue.c **** 		portENABLE_INTERRUPTS();
2495:../Dave/Generated/FREERTOS/queue.c **** 
2496:../Dave/Generated/FREERTOS/queue.c **** 		return xReturn;
2497:../Dave/Generated/FREERTOS/queue.c **** 	}
2498:../Dave/Generated/FREERTOS/queue.c **** 
2499:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_CO_ROUTINES */
2500:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2501:../Dave/Generated/FREERTOS/queue.c **** 
2502:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2503:../Dave/Generated/FREERTOS/queue.c **** 
2504:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRou
2505:../Dave/Generated/FREERTOS/queue.c **** 	{
2506:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2507:../Dave/Generated/FREERTOS/queue.c **** 
2508:../Dave/Generated/FREERTOS/queue.c **** 		/* Cannot block within an ISR so if there is no space on the queue then
2509:../Dave/Generated/FREERTOS/queue.c **** 		exit without doing anything. */
2510:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2511:../Dave/Generated/FREERTOS/queue.c **** 		{
2512:../Dave/Generated/FREERTOS/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2513:../Dave/Generated/FREERTOS/queue.c **** 
2514:../Dave/Generated/FREERTOS/queue.c **** 			/* We only want to wake one co-routine per ISR, so check that a
2515:../Dave/Generated/FREERTOS/queue.c **** 			co-routine has not already been woken. */
2516:../Dave/Generated/FREERTOS/queue.c **** 			if( xCoRoutinePreviouslyWoken == pdFALSE )
2517:../Dave/Generated/FREERTOS/queue.c **** 			{
2518:../Dave/Generated/FREERTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2519:../Dave/Generated/FREERTOS/queue.c **** 				{
2520:../Dave/Generated/FREERTOS/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2521:../Dave/Generated/FREERTOS/queue.c **** 					{
2522:../Dave/Generated/FREERTOS/queue.c **** 						return pdTRUE;
2523:../Dave/Generated/FREERTOS/queue.c **** 					}
2524:../Dave/Generated/FREERTOS/queue.c **** 					else
2525:../Dave/Generated/FREERTOS/queue.c **** 					{
2526:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2527:../Dave/Generated/FREERTOS/queue.c **** 					}
2528:../Dave/Generated/FREERTOS/queue.c **** 				}
2529:../Dave/Generated/FREERTOS/queue.c **** 				else
2530:../Dave/Generated/FREERTOS/queue.c **** 				{
2531:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2532:../Dave/Generated/FREERTOS/queue.c **** 				}
2533:../Dave/Generated/FREERTOS/queue.c **** 			}
2534:../Dave/Generated/FREERTOS/queue.c **** 			else
2535:../Dave/Generated/FREERTOS/queue.c **** 			{
2536:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2537:../Dave/Generated/FREERTOS/queue.c **** 			}
2538:../Dave/Generated/FREERTOS/queue.c **** 		}
2539:../Dave/Generated/FREERTOS/queue.c **** 		else
2540:../Dave/Generated/FREERTOS/queue.c **** 		{
2541:../Dave/Generated/FREERTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2542:../Dave/Generated/FREERTOS/queue.c **** 		}
2543:../Dave/Generated/FREERTOS/queue.c **** 
2544:../Dave/Generated/FREERTOS/queue.c **** 		return xCoRoutinePreviouslyWoken;
2545:../Dave/Generated/FREERTOS/queue.c **** 	}
2546:../Dave/Generated/FREERTOS/queue.c **** 
2547:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_CO_ROUTINES */
2548:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2549:../Dave/Generated/FREERTOS/queue.c **** 
2550:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2551:../Dave/Generated/FREERTOS/queue.c **** 
2552:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWo
2553:../Dave/Generated/FREERTOS/queue.c **** 	{
2554:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xReturn;
2555:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2556:../Dave/Generated/FREERTOS/queue.c **** 
2557:../Dave/Generated/FREERTOS/queue.c **** 		/* We cannot block from an ISR, so check there is data available. If
2558:../Dave/Generated/FREERTOS/queue.c **** 		not then just leave without doing anything. */
2559:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2560:../Dave/Generated/FREERTOS/queue.c **** 		{
2561:../Dave/Generated/FREERTOS/queue.c **** 			/* Copy the data from the queue. */
2562:../Dave/Generated/FREERTOS/queue.c **** 			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
2563:../Dave/Generated/FREERTOS/queue.c **** 			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
2564:../Dave/Generated/FREERTOS/queue.c **** 			{
2565:../Dave/Generated/FREERTOS/queue.c **** 				pxQueue->u.pcReadFrom = pxQueue->pcHead;
2566:../Dave/Generated/FREERTOS/queue.c **** 			}
2567:../Dave/Generated/FREERTOS/queue.c **** 			else
2568:../Dave/Generated/FREERTOS/queue.c **** 			{
2569:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2570:../Dave/Generated/FREERTOS/queue.c **** 			}
2571:../Dave/Generated/FREERTOS/queue.c **** 			--( pxQueue->uxMessagesWaiting );
2572:../Dave/Generated/FREERTOS/queue.c **** 			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->ux
2573:../Dave/Generated/FREERTOS/queue.c **** 
2574:../Dave/Generated/FREERTOS/queue.c **** 			if( ( *pxCoRoutineWoken ) == pdFALSE )
2575:../Dave/Generated/FREERTOS/queue.c **** 			{
2576:../Dave/Generated/FREERTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2577:../Dave/Generated/FREERTOS/queue.c **** 				{
2578:../Dave/Generated/FREERTOS/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2579:../Dave/Generated/FREERTOS/queue.c **** 					{
2580:../Dave/Generated/FREERTOS/queue.c **** 						*pxCoRoutineWoken = pdTRUE;
2581:../Dave/Generated/FREERTOS/queue.c **** 					}
2582:../Dave/Generated/FREERTOS/queue.c **** 					else
2583:../Dave/Generated/FREERTOS/queue.c **** 					{
2584:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2585:../Dave/Generated/FREERTOS/queue.c **** 					}
2586:../Dave/Generated/FREERTOS/queue.c **** 				}
2587:../Dave/Generated/FREERTOS/queue.c **** 				else
2588:../Dave/Generated/FREERTOS/queue.c **** 				{
2589:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2590:../Dave/Generated/FREERTOS/queue.c **** 				}
2591:../Dave/Generated/FREERTOS/queue.c **** 			}
2592:../Dave/Generated/FREERTOS/queue.c **** 			else
2593:../Dave/Generated/FREERTOS/queue.c **** 			{
2594:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2595:../Dave/Generated/FREERTOS/queue.c **** 			}
2596:../Dave/Generated/FREERTOS/queue.c **** 
2597:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdPASS;
2598:../Dave/Generated/FREERTOS/queue.c **** 		}
2599:../Dave/Generated/FREERTOS/queue.c **** 		else
2600:../Dave/Generated/FREERTOS/queue.c **** 		{
2601:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdFAIL;
2602:../Dave/Generated/FREERTOS/queue.c **** 		}
2603:../Dave/Generated/FREERTOS/queue.c **** 
2604:../Dave/Generated/FREERTOS/queue.c **** 		return xReturn;
2605:../Dave/Generated/FREERTOS/queue.c **** 	}
2606:../Dave/Generated/FREERTOS/queue.c **** 
2607:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_CO_ROUTINES */
2608:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2609:../Dave/Generated/FREERTOS/queue.c **** 
2610:../Dave/Generated/FREERTOS/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2611:../Dave/Generated/FREERTOS/queue.c **** 
2612:../Dave/Generated/FREERTOS/queue.c **** 	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified
2613:../Dave/Generated/FREERTOS/queue.c **** 	{
 4180              	 .loc 1 2613 0
 4181              	 .cfi_startproc
 4182              	 
 4183              	 
 4184              	 
 4185 0000 80B4     	 push {r7}
 4186              	 .cfi_def_cfa_offset 4
 4187              	 .cfi_offset 7,-4
 4188 0002 85B0     	 sub sp,sp,#20
 4189              	 .cfi_def_cfa_offset 24
 4190 0004 00AF     	 add r7,sp,#0
 4191              	 .cfi_def_cfa_register 7
 4192 0006 7860     	 str r0,[r7,#4]
 4193 0008 3960     	 str r1,[r7]
2614:../Dave/Generated/FREERTOS/queue.c **** 	UBaseType_t ux;
2615:../Dave/Generated/FREERTOS/queue.c **** 
2616:../Dave/Generated/FREERTOS/queue.c **** 		/* See if there is an empty space in the registry.  A NULL name denotes
2617:../Dave/Generated/FREERTOS/queue.c **** 		a free slot. */
2618:../Dave/Generated/FREERTOS/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 4194              	 .loc 1 2618 0
 4195 000a 0023     	 movs r3,#0
 4196 000c FB60     	 str r3,[r7,#12]
 4197 000e 14E0     	 b .L304
 4198              	.L307:
2619:../Dave/Generated/FREERTOS/queue.c **** 		{
2620:../Dave/Generated/FREERTOS/queue.c **** 			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 4199              	 .loc 1 2620 0
 4200 0010 0E4A     	 ldr r2,.L308
 4201 0012 FB68     	 ldr r3,[r7,#12]
 4202 0014 52F83330 	 ldr r3,[r2,r3,lsl#3]
 4203 0018 002B     	 cmp r3,#0
 4204 001a 0BD1     	 bne .L305
2621:../Dave/Generated/FREERTOS/queue.c **** 			{
2622:../Dave/Generated/FREERTOS/queue.c **** 				/* Store the information on this queue. */
2623:../Dave/Generated/FREERTOS/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 4205              	 .loc 1 2623 0
 4206 001c 0B49     	 ldr r1,.L308
 4207 001e FB68     	 ldr r3,[r7,#12]
 4208 0020 3A68     	 ldr r2,[r7]
 4209 0022 41F83320 	 str r2,[r1,r3,lsl#3]
2624:../Dave/Generated/FREERTOS/queue.c **** 				xQueueRegistry[ ux ].xHandle = xQueue;
 4210              	 .loc 1 2624 0
 4211 0026 094A     	 ldr r2,.L308
 4212 0028 FB68     	 ldr r3,[r7,#12]
 4213 002a DB00     	 lsls r3,r3,#3
 4214 002c 1344     	 add r3,r3,r2
 4215 002e 7A68     	 ldr r2,[r7,#4]
 4216 0030 5A60     	 str r2,[r3,#4]
2625:../Dave/Generated/FREERTOS/queue.c **** 
2626:../Dave/Generated/FREERTOS/queue.c **** 				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
2627:../Dave/Generated/FREERTOS/queue.c **** 				break;
 4217              	 .loc 1 2627 0
 4218 0032 05E0     	 b .L303
 4219              	.L305:
2618:../Dave/Generated/FREERTOS/queue.c **** 		{
 4220              	 .loc 1 2618 0 discriminator 2
 4221 0034 FB68     	 ldr r3,[r7,#12]
 4222 0036 0133     	 adds r3,r3,#1
 4223 0038 FB60     	 str r3,[r7,#12]
 4224              	.L304:
2618:../Dave/Generated/FREERTOS/queue.c **** 		{
 4225              	 .loc 1 2618 0 is_stmt 0 discriminator 1
 4226 003a FB68     	 ldr r3,[r7,#12]
 4227 003c 072B     	 cmp r3,#7
 4228 003e E7D9     	 bls .L307
 4229              	.L303:
2628:../Dave/Generated/FREERTOS/queue.c **** 			}
2629:../Dave/Generated/FREERTOS/queue.c **** 			else
2630:../Dave/Generated/FREERTOS/queue.c **** 			{
2631:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2632:../Dave/Generated/FREERTOS/queue.c **** 			}
2633:../Dave/Generated/FREERTOS/queue.c **** 		}
2634:../Dave/Generated/FREERTOS/queue.c **** 	}
 4230              	 .loc 1 2634 0 is_stmt 1
 4231 0040 1437     	 adds r7,r7,#20
 4232              	 .cfi_def_cfa_offset 4
 4233 0042 BD46     	 mov sp,r7
 4234              	 .cfi_def_cfa_register 13
 4235              	 
 4236 0044 5DF8047B 	 ldr r7,[sp],#4
 4237              	 .cfi_restore 7
 4238              	 .cfi_def_cfa_offset 0
 4239 0048 7047     	 bx lr
 4240              	.L309:
 4241 004a 00BF     	 .align 2
 4242              	.L308:
 4243 004c 00000000 	 .word xQueueRegistry
 4244              	 .cfi_endproc
 4245              	.LFE170:
 4247              	 .section .text.pcQueueGetName,"ax",%progbits
 4248              	 .align 2
 4249              	 .global pcQueueGetName
 4250              	 .thumb
 4251              	 .thumb_func
 4253              	pcQueueGetName:
 4254              	.LFB171:
2635:../Dave/Generated/FREERTOS/queue.c **** 
2636:../Dave/Generated/FREERTOS/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2637:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2638:../Dave/Generated/FREERTOS/queue.c **** 
2639:../Dave/Generated/FREERTOS/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2640:../Dave/Generated/FREERTOS/queue.c **** 
2641:../Dave/Generated/FREERTOS/queue.c **** 	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed
2642:../Dave/Generated/FREERTOS/queue.c **** 	{
 4255              	 .loc 1 2642 0
 4256              	 .cfi_startproc
 4257              	 
 4258              	 
 4259              	 
 4260 0000 80B4     	 push {r7}
 4261              	 .cfi_def_cfa_offset 4
 4262              	 .cfi_offset 7,-4
 4263 0002 85B0     	 sub sp,sp,#20
 4264              	 .cfi_def_cfa_offset 24
 4265 0004 00AF     	 add r7,sp,#0
 4266              	 .cfi_def_cfa_register 7
 4267 0006 7860     	 str r0,[r7,#4]
2643:../Dave/Generated/FREERTOS/queue.c **** 	UBaseType_t ux;
2644:../Dave/Generated/FREERTOS/queue.c **** 	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and singl
 4268              	 .loc 1 2644 0
 4269 0008 0023     	 movs r3,#0
 4270 000a BB60     	 str r3,[r7,#8]
2645:../Dave/Generated/FREERTOS/queue.c **** 
2646:../Dave/Generated/FREERTOS/queue.c **** 		/* Note there is nothing here to protect against another task adding or
2647:../Dave/Generated/FREERTOS/queue.c **** 		removing entries from the registry while it is being searched. */
2648:../Dave/Generated/FREERTOS/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 4271              	 .loc 1 2648 0
 4272 000c 0023     	 movs r3,#0
 4273 000e FB60     	 str r3,[r7,#12]
 4274 0010 10E0     	 b .L311
 4275              	.L314:
2649:../Dave/Generated/FREERTOS/queue.c **** 		{
2650:../Dave/Generated/FREERTOS/queue.c **** 			if( xQueueRegistry[ ux ].xHandle == xQueue )
 4276              	 .loc 1 2650 0
 4277 0012 0D4A     	 ldr r2,.L316
 4278 0014 FB68     	 ldr r3,[r7,#12]
 4279 0016 DB00     	 lsls r3,r3,#3
 4280 0018 1344     	 add r3,r3,r2
 4281 001a 5A68     	 ldr r2,[r3,#4]
 4282 001c 7B68     	 ldr r3,[r7,#4]
 4283 001e 9A42     	 cmp r2,r3
 4284 0020 05D1     	 bne .L312
2651:../Dave/Generated/FREERTOS/queue.c **** 			{
2652:../Dave/Generated/FREERTOS/queue.c **** 				pcReturn = xQueueRegistry[ ux ].pcQueueName;
 4285              	 .loc 1 2652 0
 4286 0022 094A     	 ldr r2,.L316
 4287 0024 FB68     	 ldr r3,[r7,#12]
 4288 0026 52F83330 	 ldr r3,[r2,r3,lsl#3]
 4289 002a BB60     	 str r3,[r7,#8]
2653:../Dave/Generated/FREERTOS/queue.c **** 				break;
 4290              	 .loc 1 2653 0
 4291 002c 05E0     	 b .L313
 4292              	.L312:
2648:../Dave/Generated/FREERTOS/queue.c **** 		{
 4293              	 .loc 1 2648 0 discriminator 2
 4294 002e FB68     	 ldr r3,[r7,#12]
 4295 0030 0133     	 adds r3,r3,#1
 4296 0032 FB60     	 str r3,[r7,#12]
 4297              	.L311:
2648:../Dave/Generated/FREERTOS/queue.c **** 		{
 4298              	 .loc 1 2648 0 is_stmt 0 discriminator 1
 4299 0034 FB68     	 ldr r3,[r7,#12]
 4300 0036 072B     	 cmp r3,#7
 4301 0038 EBD9     	 bls .L314
 4302              	.L313:
2654:../Dave/Generated/FREERTOS/queue.c **** 			}
2655:../Dave/Generated/FREERTOS/queue.c **** 			else
2656:../Dave/Generated/FREERTOS/queue.c **** 			{
2657:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2658:../Dave/Generated/FREERTOS/queue.c **** 			}
2659:../Dave/Generated/FREERTOS/queue.c **** 		}
2660:../Dave/Generated/FREERTOS/queue.c **** 
2661:../Dave/Generated/FREERTOS/queue.c **** 		return pcReturn;
 4303              	 .loc 1 2661 0 is_stmt 1
 4304 003a BB68     	 ldr r3,[r7,#8]
2662:../Dave/Generated/FREERTOS/queue.c **** 	} /*lint !e818 xQueue cannot be a pointer to const because it is a typedef. */
 4305              	 .loc 1 2662 0
 4306 003c 1846     	 mov r0,r3
 4307 003e 1437     	 adds r7,r7,#20
 4308              	 .cfi_def_cfa_offset 4
 4309 0040 BD46     	 mov sp,r7
 4310              	 .cfi_def_cfa_register 13
 4311              	 
 4312 0042 5DF8047B 	 ldr r7,[sp],#4
 4313              	 .cfi_restore 7
 4314              	 .cfi_def_cfa_offset 0
 4315 0046 7047     	 bx lr
 4316              	.L317:
 4317              	 .align 2
 4318              	.L316:
 4319 0048 00000000 	 .word xQueueRegistry
 4320              	 .cfi_endproc
 4321              	.LFE171:
 4323              	 .section .text.vQueueUnregisterQueue,"ax",%progbits
 4324              	 .align 2
 4325              	 .global vQueueUnregisterQueue
 4326              	 .thumb
 4327              	 .thumb_func
 4329              	vQueueUnregisterQueue:
 4330              	.LFB172:
2663:../Dave/Generated/FREERTOS/queue.c **** 
2664:../Dave/Generated/FREERTOS/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2665:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2666:../Dave/Generated/FREERTOS/queue.c **** 
2667:../Dave/Generated/FREERTOS/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2668:../Dave/Generated/FREERTOS/queue.c **** 
2669:../Dave/Generated/FREERTOS/queue.c **** 	void vQueueUnregisterQueue( QueueHandle_t xQueue )
2670:../Dave/Generated/FREERTOS/queue.c **** 	{
 4331              	 .loc 1 2670 0
 4332              	 .cfi_startproc
 4333              	 
 4334              	 
 4335              	 
 4336 0000 80B4     	 push {r7}
 4337              	 .cfi_def_cfa_offset 4
 4338              	 .cfi_offset 7,-4
 4339 0002 85B0     	 sub sp,sp,#20
 4340              	 .cfi_def_cfa_offset 24
 4341 0004 00AF     	 add r7,sp,#0
 4342              	 .cfi_def_cfa_register 7
 4343 0006 7860     	 str r0,[r7,#4]
2671:../Dave/Generated/FREERTOS/queue.c **** 	UBaseType_t ux;
2672:../Dave/Generated/FREERTOS/queue.c **** 
2673:../Dave/Generated/FREERTOS/queue.c **** 		/* See if the handle of the queue being unregistered in actually in the
2674:../Dave/Generated/FREERTOS/queue.c **** 		registry. */
2675:../Dave/Generated/FREERTOS/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 4344              	 .loc 1 2675 0
 4345 0008 0023     	 movs r3,#0
 4346 000a FB60     	 str r3,[r7,#12]
 4347 000c 16E0     	 b .L319
 4348              	.L322:
2676:../Dave/Generated/FREERTOS/queue.c **** 		{
2677:../Dave/Generated/FREERTOS/queue.c **** 			if( xQueueRegistry[ ux ].xHandle == xQueue )
 4349              	 .loc 1 2677 0
 4350 000e 0F4A     	 ldr r2,.L323
 4351 0010 FB68     	 ldr r3,[r7,#12]
 4352 0012 DB00     	 lsls r3,r3,#3
 4353 0014 1344     	 add r3,r3,r2
 4354 0016 5A68     	 ldr r2,[r3,#4]
 4355 0018 7B68     	 ldr r3,[r7,#4]
 4356 001a 9A42     	 cmp r2,r3
 4357 001c 0BD1     	 bne .L320
2678:../Dave/Generated/FREERTOS/queue.c **** 			{
2679:../Dave/Generated/FREERTOS/queue.c **** 				/* Set the name to NULL to show that this slot if free again. */
2680:../Dave/Generated/FREERTOS/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = NULL;
 4358              	 .loc 1 2680 0
 4359 001e 0B4A     	 ldr r2,.L323
 4360 0020 FB68     	 ldr r3,[r7,#12]
 4361 0022 0021     	 movs r1,#0
 4362 0024 42F83310 	 str r1,[r2,r3,lsl#3]
2681:../Dave/Generated/FREERTOS/queue.c **** 
2682:../Dave/Generated/FREERTOS/queue.c **** 				/* Set the handle to NULL to ensure the same queue handle cannot
2683:../Dave/Generated/FREERTOS/queue.c **** 				appear in the registry twice if it is added, removed, then
2684:../Dave/Generated/FREERTOS/queue.c **** 				added again. */
2685:../Dave/Generated/FREERTOS/queue.c **** 				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
 4363              	 .loc 1 2685 0
 4364 0028 084A     	 ldr r2,.L323
 4365 002a FB68     	 ldr r3,[r7,#12]
 4366 002c DB00     	 lsls r3,r3,#3
 4367 002e 1344     	 add r3,r3,r2
 4368 0030 0022     	 movs r2,#0
 4369 0032 5A60     	 str r2,[r3,#4]
2686:../Dave/Generated/FREERTOS/queue.c **** 				break;
 4370              	 .loc 1 2686 0
 4371 0034 05E0     	 b .L318
 4372              	.L320:
2675:../Dave/Generated/FREERTOS/queue.c **** 		{
 4373              	 .loc 1 2675 0 discriminator 2
 4374 0036 FB68     	 ldr r3,[r7,#12]
 4375 0038 0133     	 adds r3,r3,#1
 4376 003a FB60     	 str r3,[r7,#12]
 4377              	.L319:
2675:../Dave/Generated/FREERTOS/queue.c **** 		{
 4378              	 .loc 1 2675 0 is_stmt 0 discriminator 1
 4379 003c FB68     	 ldr r3,[r7,#12]
 4380 003e 072B     	 cmp r3,#7
 4381 0040 E5D9     	 bls .L322
 4382              	.L318:
2687:../Dave/Generated/FREERTOS/queue.c **** 			}
2688:../Dave/Generated/FREERTOS/queue.c **** 			else
2689:../Dave/Generated/FREERTOS/queue.c **** 			{
2690:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2691:../Dave/Generated/FREERTOS/queue.c **** 			}
2692:../Dave/Generated/FREERTOS/queue.c **** 		}
2693:../Dave/Generated/FREERTOS/queue.c **** 
2694:../Dave/Generated/FREERTOS/queue.c **** 	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 4383              	 .loc 1 2694 0 is_stmt 1
 4384 0042 1437     	 adds r7,r7,#20
 4385              	 .cfi_def_cfa_offset 4
 4386 0044 BD46     	 mov sp,r7
 4387              	 .cfi_def_cfa_register 13
 4388              	 
 4389 0046 5DF8047B 	 ldr r7,[sp],#4
 4390              	 .cfi_restore 7
 4391              	 .cfi_def_cfa_offset 0
 4392 004a 7047     	 bx lr
 4393              	.L324:
 4394              	 .align 2
 4395              	.L323:
 4396 004c 00000000 	 .word xQueueRegistry
 4397              	 .cfi_endproc
 4398              	.LFE172:
 4400              	 .section .text.vQueueWaitForMessageRestricted,"ax",%progbits
 4401              	 .align 2
 4402              	 .global vQueueWaitForMessageRestricted
 4403              	 .thumb
 4404              	 .thumb_func
 4406              	vQueueWaitForMessageRestricted:
 4407              	.LFB173:
2695:../Dave/Generated/FREERTOS/queue.c **** 
2696:../Dave/Generated/FREERTOS/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2697:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2698:../Dave/Generated/FREERTOS/queue.c **** 
2699:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_TIMERS == 1 )
2700:../Dave/Generated/FREERTOS/queue.c **** 
2701:../Dave/Generated/FREERTOS/queue.c **** 	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType
2702:../Dave/Generated/FREERTOS/queue.c **** 	{
 4408              	 .loc 1 2702 0
 4409              	 .cfi_startproc
 4410              	 
 4411              	 
 4412 0000 80B5     	 push {r7,lr}
 4413              	 .cfi_def_cfa_offset 8
 4414              	 .cfi_offset 7,-8
 4415              	 .cfi_offset 14,-4
 4416 0002 86B0     	 sub sp,sp,#24
 4417              	 .cfi_def_cfa_offset 32
 4418 0004 00AF     	 add r7,sp,#0
 4419              	 .cfi_def_cfa_register 7
 4420 0006 F860     	 str r0,[r7,#12]
 4421 0008 B960     	 str r1,[r7,#8]
 4422 000a 7A60     	 str r2,[r7,#4]
2703:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 4423              	 .loc 1 2703 0
 4424 000c FB68     	 ldr r3,[r7,#12]
 4425 000e 7B61     	 str r3,[r7,#20]
2704:../Dave/Generated/FREERTOS/queue.c **** 
2705:../Dave/Generated/FREERTOS/queue.c **** 		/* This function should not be called by application code hence the
2706:../Dave/Generated/FREERTOS/queue.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
2707:../Dave/Generated/FREERTOS/queue.c **** 		designed for use by kernel code, and has special calling requirements.
2708:../Dave/Generated/FREERTOS/queue.c **** 		It can result in vListInsert() being called on a list that can only
2709:../Dave/Generated/FREERTOS/queue.c **** 		possibly ever have one item in it, so the list will be fast, but even
2710:../Dave/Generated/FREERTOS/queue.c **** 		so it should be called with the scheduler locked and not from a critical
2711:../Dave/Generated/FREERTOS/queue.c **** 		section. */
2712:../Dave/Generated/FREERTOS/queue.c **** 
2713:../Dave/Generated/FREERTOS/queue.c **** 		/* Only do anything if there are no messages in the queue.  This function
2714:../Dave/Generated/FREERTOS/queue.c **** 		will not actually cause the task to block, just place it on a blocked
2715:../Dave/Generated/FREERTOS/queue.c **** 		list.  It will not block until the scheduler is unlocked - at which
2716:../Dave/Generated/FREERTOS/queue.c **** 		time a yield will be performed.  If an item is added to the queue while
2717:../Dave/Generated/FREERTOS/queue.c **** 		the queue is locked, and the calling task blocks on the queue, then the
2718:../Dave/Generated/FREERTOS/queue.c **** 		calling task will be immediately unblocked when the queue is unlocked. */
2719:../Dave/Generated/FREERTOS/queue.c **** 		prvLockQueue( pxQueue );
 4426              	 .loc 1 2719 0
 4427 0010 FFF7FEFF 	 bl vPortEnterCritical
 4428 0014 7B69     	 ldr r3,[r7,#20]
 4429 0016 93F84430 	 ldrb r3,[r3,#68]
 4430 001a DBB2     	 uxtb r3,r3
 4431 001c 5BB2     	 sxtb r3,r3
 4432 001e B3F1FF3F 	 cmp r3,#-1
 4433 0022 03D1     	 bne .L326
 4434              	 .loc 1 2719 0 is_stmt 0 discriminator 1
 4435 0024 7B69     	 ldr r3,[r7,#20]
 4436 0026 0022     	 movs r2,#0
 4437 0028 83F84420 	 strb r2,[r3,#68]
 4438              	.L326:
 4439              	 .loc 1 2719 0 discriminator 3
 4440 002c 7B69     	 ldr r3,[r7,#20]
 4441 002e 93F84530 	 ldrb r3,[r3,#69]
 4442 0032 DBB2     	 uxtb r3,r3
 4443 0034 5BB2     	 sxtb r3,r3
 4444 0036 B3F1FF3F 	 cmp r3,#-1
 4445 003a 03D1     	 bne .L327
 4446              	 .loc 1 2719 0 discriminator 4
 4447 003c 7B69     	 ldr r3,[r7,#20]
 4448 003e 0022     	 movs r2,#0
 4449 0040 83F84520 	 strb r2,[r3,#69]
 4450              	.L327:
 4451              	 .loc 1 2719 0 discriminator 6
 4452 0044 FFF7FEFF 	 bl vPortExitCritical
2720:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 4453              	 .loc 1 2720 0 is_stmt 1 discriminator 6
 4454 0048 7B69     	 ldr r3,[r7,#20]
 4455 004a 9B6B     	 ldr r3,[r3,#56]
 4456 004c 002B     	 cmp r3,#0
 4457 004e 06D1     	 bne .L328
2721:../Dave/Generated/FREERTOS/queue.c **** 		{
2722:../Dave/Generated/FREERTOS/queue.c **** 			/* There is nothing in the queue, block for the specified period. */
2723:../Dave/Generated/FREERTOS/queue.c **** 			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefi
 4458              	 .loc 1 2723 0
 4459 0050 7B69     	 ldr r3,[r7,#20]
 4460 0052 2433     	 adds r3,r3,#36
 4461 0054 1846     	 mov r0,r3
 4462 0056 B968     	 ldr r1,[r7,#8]
 4463 0058 7A68     	 ldr r2,[r7,#4]
 4464 005a FFF7FEFF 	 bl vTaskPlaceOnEventListRestricted
 4465              	.L328:
2724:../Dave/Generated/FREERTOS/queue.c **** 		}
2725:../Dave/Generated/FREERTOS/queue.c **** 		else
2726:../Dave/Generated/FREERTOS/queue.c **** 		{
2727:../Dave/Generated/FREERTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2728:../Dave/Generated/FREERTOS/queue.c **** 		}
2729:../Dave/Generated/FREERTOS/queue.c **** 		prvUnlockQueue( pxQueue );
 4466              	 .loc 1 2729 0
 4467 005e 7869     	 ldr r0,[r7,#20]
 4468 0060 FFF7FEFF 	 bl prvUnlockQueue
2730:../Dave/Generated/FREERTOS/queue.c **** 	}
 4469              	 .loc 1 2730 0
 4470 0064 1837     	 adds r7,r7,#24
 4471              	 .cfi_def_cfa_offset 8
 4472 0066 BD46     	 mov sp,r7
 4473              	 .cfi_def_cfa_register 13
 4474              	 
 4475 0068 80BD     	 pop {r7,pc}
 4476              	 .cfi_endproc
 4477              	.LFE173:
 4479 006a 00BF     	 .section .text.xQueueCreateSet,"ax",%progbits
 4480              	 .align 2
 4481              	 .global xQueueCreateSet
 4482              	 .thumb
 4483              	 .thumb_func
 4485              	xQueueCreateSet:
 4486              	.LFB174:
2731:../Dave/Generated/FREERTOS/queue.c **** 
2732:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_TIMERS */
2733:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2734:../Dave/Generated/FREERTOS/queue.c **** 
2735:../Dave/Generated/FREERTOS/queue.c **** #if( ( configUSE_QUEUE_SETS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
2736:../Dave/Generated/FREERTOS/queue.c **** 
2737:../Dave/Generated/FREERTOS/queue.c **** 	QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength )
2738:../Dave/Generated/FREERTOS/queue.c **** 	{
 4487              	 .loc 1 2738 0
 4488              	 .cfi_startproc
 4489              	 
 4490              	 
 4491 0000 80B5     	 push {r7,lr}
 4492              	 .cfi_def_cfa_offset 8
 4493              	 .cfi_offset 7,-8
 4494              	 .cfi_offset 14,-4
 4495 0002 84B0     	 sub sp,sp,#16
 4496              	 .cfi_def_cfa_offset 24
 4497 0004 00AF     	 add r7,sp,#0
 4498              	 .cfi_def_cfa_register 7
 4499 0006 7860     	 str r0,[r7,#4]
2739:../Dave/Generated/FREERTOS/queue.c **** 	QueueSetHandle_t pxQueue;
2740:../Dave/Generated/FREERTOS/queue.c **** 
2741:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue = xQueueGenericCreate( uxEventQueueLength, ( UBaseType_t ) sizeof( Queue_t * ), queueQUEU
 4500              	 .loc 1 2741 0
 4501 0008 7868     	 ldr r0,[r7,#4]
 4502 000a 0421     	 movs r1,#4
 4503 000c 0022     	 movs r2,#0
 4504 000e FFF7FEFF 	 bl xQueueGenericCreate
 4505 0012 F860     	 str r0,[r7,#12]
2742:../Dave/Generated/FREERTOS/queue.c **** 
2743:../Dave/Generated/FREERTOS/queue.c **** 		return pxQueue;
 4506              	 .loc 1 2743 0
 4507 0014 FB68     	 ldr r3,[r7,#12]
2744:../Dave/Generated/FREERTOS/queue.c **** 	}
 4508              	 .loc 1 2744 0
 4509 0016 1846     	 mov r0,r3
 4510 0018 1037     	 adds r7,r7,#16
 4511              	 .cfi_def_cfa_offset 8
 4512 001a BD46     	 mov sp,r7
 4513              	 .cfi_def_cfa_register 13
 4514              	 
 4515 001c 80BD     	 pop {r7,pc}
 4516              	 .cfi_endproc
 4517              	.LFE174:
 4519 001e 00BF     	 .section .text.xQueueAddToSet,"ax",%progbits
 4520              	 .align 2
 4521              	 .global xQueueAddToSet
 4522              	 .thumb
 4523              	 .thumb_func
 4525              	xQueueAddToSet:
 4526              	.LFB175:
2745:../Dave/Generated/FREERTOS/queue.c **** 
2746:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_QUEUE_SETS */
2747:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2748:../Dave/Generated/FREERTOS/queue.c **** 
2749:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
2750:../Dave/Generated/FREERTOS/queue.c **** 
2751:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
2752:../Dave/Generated/FREERTOS/queue.c **** 	{
 4527              	 .loc 1 2752 0
 4528              	 .cfi_startproc
 4529              	 
 4530              	 
 4531 0000 80B5     	 push {r7,lr}
 4532              	 .cfi_def_cfa_offset 8
 4533              	 .cfi_offset 7,-8
 4534              	 .cfi_offset 14,-4
 4535 0002 84B0     	 sub sp,sp,#16
 4536              	 .cfi_def_cfa_offset 24
 4537 0004 00AF     	 add r7,sp,#0
 4538              	 .cfi_def_cfa_register 7
 4539 0006 7860     	 str r0,[r7,#4]
 4540 0008 3960     	 str r1,[r7]
2753:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xReturn;
2754:../Dave/Generated/FREERTOS/queue.c **** 
2755:../Dave/Generated/FREERTOS/queue.c **** 		taskENTER_CRITICAL();
 4541              	 .loc 1 2755 0
 4542 000a FFF7FEFF 	 bl vPortEnterCritical
2756:../Dave/Generated/FREERTOS/queue.c **** 		{
2757:../Dave/Generated/FREERTOS/queue.c **** 			if( ( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer != NULL )
 4543              	 .loc 1 2757 0
 4544 000e 7B68     	 ldr r3,[r7,#4]
 4545 0010 9B6C     	 ldr r3,[r3,#72]
 4546 0012 002B     	 cmp r3,#0
 4547 0014 02D0     	 beq .L332
2758:../Dave/Generated/FREERTOS/queue.c **** 			{
2759:../Dave/Generated/FREERTOS/queue.c **** 				/* Cannot add a queue/semaphore to more than one queue set. */
2760:../Dave/Generated/FREERTOS/queue.c **** 				xReturn = pdFAIL;
 4548              	 .loc 1 2760 0
 4549 0016 0023     	 movs r3,#0
 4550 0018 FB60     	 str r3,[r7,#12]
 4551 001a 0BE0     	 b .L333
 4552              	.L332:
2761:../Dave/Generated/FREERTOS/queue.c **** 			}
2762:../Dave/Generated/FREERTOS/queue.c **** 			else if( ( ( Queue_t * ) xQueueOrSemaphore )->uxMessagesWaiting != ( UBaseType_t ) 0 )
 4553              	 .loc 1 2762 0
 4554 001c 7B68     	 ldr r3,[r7,#4]
 4555 001e 9B6B     	 ldr r3,[r3,#56]
 4556 0020 002B     	 cmp r3,#0
 4557 0022 02D0     	 beq .L334
2763:../Dave/Generated/FREERTOS/queue.c **** 			{
2764:../Dave/Generated/FREERTOS/queue.c **** 				/* Cannot add a queue/semaphore to a queue set if there are already
2765:../Dave/Generated/FREERTOS/queue.c **** 				items in the queue/semaphore. */
2766:../Dave/Generated/FREERTOS/queue.c **** 				xReturn = pdFAIL;
 4558              	 .loc 1 2766 0
 4559 0024 0023     	 movs r3,#0
 4560 0026 FB60     	 str r3,[r7,#12]
 4561 0028 04E0     	 b .L333
 4562              	.L334:
2767:../Dave/Generated/FREERTOS/queue.c **** 			}
2768:../Dave/Generated/FREERTOS/queue.c **** 			else
2769:../Dave/Generated/FREERTOS/queue.c **** 			{
2770:../Dave/Generated/FREERTOS/queue.c **** 				( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer = xQueueSet;
 4563              	 .loc 1 2770 0
 4564 002a 7B68     	 ldr r3,[r7,#4]
 4565 002c 3A68     	 ldr r2,[r7]
 4566 002e 9A64     	 str r2,[r3,#72]
2771:../Dave/Generated/FREERTOS/queue.c **** 				xReturn = pdPASS;
 4567              	 .loc 1 2771 0
 4568 0030 0123     	 movs r3,#1
 4569 0032 FB60     	 str r3,[r7,#12]
 4570              	.L333:
2772:../Dave/Generated/FREERTOS/queue.c **** 			}
2773:../Dave/Generated/FREERTOS/queue.c **** 		}
2774:../Dave/Generated/FREERTOS/queue.c **** 		taskEXIT_CRITICAL();
 4571              	 .loc 1 2774 0
 4572 0034 FFF7FEFF 	 bl vPortExitCritical
2775:../Dave/Generated/FREERTOS/queue.c **** 
2776:../Dave/Generated/FREERTOS/queue.c **** 		return xReturn;
 4573              	 .loc 1 2776 0
 4574 0038 FB68     	 ldr r3,[r7,#12]
2777:../Dave/Generated/FREERTOS/queue.c **** 	}
 4575              	 .loc 1 2777 0
 4576 003a 1846     	 mov r0,r3
 4577 003c 1037     	 adds r7,r7,#16
 4578              	 .cfi_def_cfa_offset 8
 4579 003e BD46     	 mov sp,r7
 4580              	 .cfi_def_cfa_register 13
 4581              	 
 4582 0040 80BD     	 pop {r7,pc}
 4583              	 .cfi_endproc
 4584              	.LFE175:
 4586 0042 00BF     	 .section .text.xQueueRemoveFromSet,"ax",%progbits
 4587              	 .align 2
 4588              	 .global xQueueRemoveFromSet
 4589              	 .thumb
 4590              	 .thumb_func
 4592              	xQueueRemoveFromSet:
 4593              	.LFB176:
2778:../Dave/Generated/FREERTOS/queue.c **** 
2779:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_QUEUE_SETS */
2780:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2781:../Dave/Generated/FREERTOS/queue.c **** 
2782:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
2783:../Dave/Generated/FREERTOS/queue.c **** 
2784:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueS
2785:../Dave/Generated/FREERTOS/queue.c **** 	{
 4594              	 .loc 1 2785 0
 4595              	 .cfi_startproc
 4596              	 
 4597              	 
 4598 0000 80B5     	 push {r7,lr}
 4599              	 .cfi_def_cfa_offset 8
 4600              	 .cfi_offset 7,-8
 4601              	 .cfi_offset 14,-4
 4602 0002 84B0     	 sub sp,sp,#16
 4603              	 .cfi_def_cfa_offset 24
 4604 0004 00AF     	 add r7,sp,#0
 4605              	 .cfi_def_cfa_register 7
 4606 0006 7860     	 str r0,[r7,#4]
 4607 0008 3960     	 str r1,[r7]
2786:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xReturn;
2787:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t * const pxQueueOrSemaphore = ( Queue_t * ) xQueueOrSemaphore;
 4608              	 .loc 1 2787 0
 4609 000a 7B68     	 ldr r3,[r7,#4]
 4610 000c BB60     	 str r3,[r7,#8]
2788:../Dave/Generated/FREERTOS/queue.c **** 
2789:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueueOrSemaphore->pxQueueSetContainer != xQueueSet )
 4611              	 .loc 1 2789 0
 4612 000e BB68     	 ldr r3,[r7,#8]
 4613 0010 9A6C     	 ldr r2,[r3,#72]
 4614 0012 3B68     	 ldr r3,[r7]
 4615 0014 9A42     	 cmp r2,r3
 4616 0016 02D0     	 beq .L337
2790:../Dave/Generated/FREERTOS/queue.c **** 		{
2791:../Dave/Generated/FREERTOS/queue.c **** 			/* The queue was not a member of the set. */
2792:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdFAIL;
 4617              	 .loc 1 2792 0
 4618 0018 0023     	 movs r3,#0
 4619 001a FB60     	 str r3,[r7,#12]
 4620 001c 0FE0     	 b .L338
 4621              	.L337:
2793:../Dave/Generated/FREERTOS/queue.c **** 		}
2794:../Dave/Generated/FREERTOS/queue.c **** 		else if( pxQueueOrSemaphore->uxMessagesWaiting != ( UBaseType_t ) 0 )
 4622              	 .loc 1 2794 0
 4623 001e BB68     	 ldr r3,[r7,#8]
 4624 0020 9B6B     	 ldr r3,[r3,#56]
 4625 0022 002B     	 cmp r3,#0
 4626 0024 02D0     	 beq .L339
2795:../Dave/Generated/FREERTOS/queue.c **** 		{
2796:../Dave/Generated/FREERTOS/queue.c **** 			/* It is dangerous to remove a queue from a set when the queue is
2797:../Dave/Generated/FREERTOS/queue.c **** 			not empty because the queue set will still hold pending events for
2798:../Dave/Generated/FREERTOS/queue.c **** 			the queue. */
2799:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdFAIL;
 4627              	 .loc 1 2799 0
 4628 0026 0023     	 movs r3,#0
 4629 0028 FB60     	 str r3,[r7,#12]
 4630 002a 08E0     	 b .L338
 4631              	.L339:
2800:../Dave/Generated/FREERTOS/queue.c **** 		}
2801:../Dave/Generated/FREERTOS/queue.c **** 		else
2802:../Dave/Generated/FREERTOS/queue.c **** 		{
2803:../Dave/Generated/FREERTOS/queue.c **** 			taskENTER_CRITICAL();
 4632              	 .loc 1 2803 0
 4633 002c FFF7FEFF 	 bl vPortEnterCritical
2804:../Dave/Generated/FREERTOS/queue.c **** 			{
2805:../Dave/Generated/FREERTOS/queue.c **** 				/* The queue is no longer contained in the set. */
2806:../Dave/Generated/FREERTOS/queue.c **** 				pxQueueOrSemaphore->pxQueueSetContainer = NULL;
 4634              	 .loc 1 2806 0
 4635 0030 BB68     	 ldr r3,[r7,#8]
 4636 0032 0022     	 movs r2,#0
 4637 0034 9A64     	 str r2,[r3,#72]
2807:../Dave/Generated/FREERTOS/queue.c **** 			}
2808:../Dave/Generated/FREERTOS/queue.c **** 			taskEXIT_CRITICAL();
 4638              	 .loc 1 2808 0
 4639 0036 FFF7FEFF 	 bl vPortExitCritical
2809:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdPASS;
 4640              	 .loc 1 2809 0
 4641 003a 0123     	 movs r3,#1
 4642 003c FB60     	 str r3,[r7,#12]
 4643              	.L338:
2810:../Dave/Generated/FREERTOS/queue.c **** 		}
2811:../Dave/Generated/FREERTOS/queue.c **** 
2812:../Dave/Generated/FREERTOS/queue.c **** 		return xReturn;
 4644              	 .loc 1 2812 0
 4645 003e FB68     	 ldr r3,[r7,#12]
2813:../Dave/Generated/FREERTOS/queue.c **** 	} /*lint !e818 xQueueSet could not be declared as pointing to const as it is a typedef. */
 4646              	 .loc 1 2813 0
 4647 0040 1846     	 mov r0,r3
 4648 0042 1037     	 adds r7,r7,#16
 4649              	 .cfi_def_cfa_offset 8
 4650 0044 BD46     	 mov sp,r7
 4651              	 .cfi_def_cfa_register 13
 4652              	 
 4653 0046 80BD     	 pop {r7,pc}
 4654              	 .cfi_endproc
 4655              	.LFE176:
 4657              	 .section .text.xQueueSelectFromSet,"ax",%progbits
 4658              	 .align 2
 4659              	 .global xQueueSelectFromSet
 4660              	 .thumb
 4661              	 .thumb_func
 4663              	xQueueSelectFromSet:
 4664              	.LFB177:
2814:../Dave/Generated/FREERTOS/queue.c **** 
2815:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_QUEUE_SETS */
2816:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2817:../Dave/Generated/FREERTOS/queue.c **** 
2818:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
2819:../Dave/Generated/FREERTOS/queue.c **** 
2820:../Dave/Generated/FREERTOS/queue.c **** 	QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, TickType_t const xTicksToW
2821:../Dave/Generated/FREERTOS/queue.c **** 	{
 4665              	 .loc 1 2821 0
 4666              	 .cfi_startproc
 4667              	 
 4668              	 
 4669 0000 80B5     	 push {r7,lr}
 4670              	 .cfi_def_cfa_offset 8
 4671              	 .cfi_offset 7,-8
 4672              	 .cfi_offset 14,-4
 4673 0002 84B0     	 sub sp,sp,#16
 4674              	 .cfi_def_cfa_offset 24
 4675 0004 00AF     	 add r7,sp,#0
 4676              	 .cfi_def_cfa_register 7
 4677 0006 7860     	 str r0,[r7,#4]
 4678 0008 3960     	 str r1,[r7]
2822:../Dave/Generated/FREERTOS/queue.c **** 	QueueSetMemberHandle_t xReturn = NULL;
 4679              	 .loc 1 2822 0
 4680 000a 0023     	 movs r3,#0
 4681 000c FB60     	 str r3,[r7,#12]
2823:../Dave/Generated/FREERTOS/queue.c **** 
2824:../Dave/Generated/FREERTOS/queue.c **** 		( void ) xQueueReceive( ( QueueHandle_t ) xQueueSet, &xReturn, xTicksToWait ); /*lint !e961 Casti
 4682              	 .loc 1 2824 0
 4683 000e 07F10C03 	 add r3,r7,#12
 4684 0012 7868     	 ldr r0,[r7,#4]
 4685 0014 1946     	 mov r1,r3
 4686 0016 3A68     	 ldr r2,[r7]
 4687 0018 FFF7FEFF 	 bl xQueueReceive
2825:../Dave/Generated/FREERTOS/queue.c **** 		return xReturn;
 4688              	 .loc 1 2825 0
 4689 001c FB68     	 ldr r3,[r7,#12]
2826:../Dave/Generated/FREERTOS/queue.c **** 	}
 4690              	 .loc 1 2826 0
 4691 001e 1846     	 mov r0,r3
 4692 0020 1037     	 adds r7,r7,#16
 4693              	 .cfi_def_cfa_offset 8
 4694 0022 BD46     	 mov sp,r7
 4695              	 .cfi_def_cfa_register 13
 4696              	 
 4697 0024 80BD     	 pop {r7,pc}
 4698              	 .cfi_endproc
 4699              	.LFE177:
 4701 0026 00BF     	 .section .text.xQueueSelectFromSetFromISR,"ax",%progbits
 4702              	 .align 2
 4703              	 .global xQueueSelectFromSetFromISR
 4704              	 .thumb
 4705              	 .thumb_func
 4707              	xQueueSelectFromSetFromISR:
 4708              	.LFB178:
2827:../Dave/Generated/FREERTOS/queue.c **** 
2828:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_QUEUE_SETS */
2829:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2830:../Dave/Generated/FREERTOS/queue.c **** 
2831:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
2832:../Dave/Generated/FREERTOS/queue.c **** 
2833:../Dave/Generated/FREERTOS/queue.c **** 	QueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet )
2834:../Dave/Generated/FREERTOS/queue.c **** 	{
 4709              	 .loc 1 2834 0
 4710              	 .cfi_startproc
 4711              	 
 4712              	 
 4713 0000 80B5     	 push {r7,lr}
 4714              	 .cfi_def_cfa_offset 8
 4715              	 .cfi_offset 7,-8
 4716              	 .cfi_offset 14,-4
 4717 0002 84B0     	 sub sp,sp,#16
 4718              	 .cfi_def_cfa_offset 24
 4719 0004 00AF     	 add r7,sp,#0
 4720              	 .cfi_def_cfa_register 7
 4721 0006 7860     	 str r0,[r7,#4]
2835:../Dave/Generated/FREERTOS/queue.c **** 	QueueSetMemberHandle_t xReturn = NULL;
 4722              	 .loc 1 2835 0
 4723 0008 0023     	 movs r3,#0
 4724 000a FB60     	 str r3,[r7,#12]
2836:../Dave/Generated/FREERTOS/queue.c **** 
2837:../Dave/Generated/FREERTOS/queue.c **** 		( void ) xQueueReceiveFromISR( ( QueueHandle_t ) xQueueSet, &xReturn, NULL ); /*lint !e961 Castin
 4725              	 .loc 1 2837 0
 4726 000c 07F10C03 	 add r3,r7,#12
 4727 0010 7868     	 ldr r0,[r7,#4]
 4728 0012 1946     	 mov r1,r3
 4729 0014 0022     	 movs r2,#0
 4730 0016 FFF7FEFF 	 bl xQueueReceiveFromISR
2838:../Dave/Generated/FREERTOS/queue.c **** 		return xReturn;
 4731              	 .loc 1 2838 0
 4732 001a FB68     	 ldr r3,[r7,#12]
2839:../Dave/Generated/FREERTOS/queue.c **** 	}
 4733              	 .loc 1 2839 0
 4734 001c 1846     	 mov r0,r3
 4735 001e 1037     	 adds r7,r7,#16
 4736              	 .cfi_def_cfa_offset 8
 4737 0020 BD46     	 mov sp,r7
 4738              	 .cfi_def_cfa_register 13
 4739              	 
 4740 0022 80BD     	 pop {r7,pc}
 4741              	 .cfi_endproc
 4742              	.LFE178:
 4744              	 .section .text.prvNotifyQueueSetContainer,"ax",%progbits
 4745              	 .align 2
 4746              	 .thumb
 4747              	 .thumb_func
 4749              	prvNotifyQueueSetContainer:
 4750              	.LFB179:
2840:../Dave/Generated/FREERTOS/queue.c **** 
2841:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_QUEUE_SETS */
2842:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2843:../Dave/Generated/FREERTOS/queue.c **** 
2844:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
2845:../Dave/Generated/FREERTOS/queue.c **** 
2846:../Dave/Generated/FREERTOS/queue.c **** 	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCop
2847:../Dave/Generated/FREERTOS/queue.c **** 	{
 4751              	 .loc 1 2847 0
 4752              	 .cfi_startproc
 4753              	 
 4754              	 
 4755 0000 80B5     	 push {r7,lr}
 4756              	 .cfi_def_cfa_offset 8
 4757              	 .cfi_offset 7,-8
 4758              	 .cfi_offset 14,-4
 4759 0002 88B0     	 sub sp,sp,#32
 4760              	 .cfi_def_cfa_offset 40
 4761 0004 00AF     	 add r7,sp,#0
 4762              	 .cfi_def_cfa_register 7
 4763 0006 7860     	 str r0,[r7,#4]
 4764 0008 3960     	 str r1,[r7]
2848:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
 4765              	 .loc 1 2848 0
 4766 000a 7B68     	 ldr r3,[r7,#4]
 4767 000c 9B6C     	 ldr r3,[r3,#72]
 4768 000e BB61     	 str r3,[r7,#24]
2849:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xReturn = pdFALSE;
 4769              	 .loc 1 2849 0
 4770 0010 0023     	 movs r3,#0
 4771 0012 FB61     	 str r3,[r7,#28]
2850:../Dave/Generated/FREERTOS/queue.c **** 
2851:../Dave/Generated/FREERTOS/queue.c **** 		/* This function must be called form a critical section. */
2852:../Dave/Generated/FREERTOS/queue.c **** 
2853:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( pxQueueSetContainer );
 4772              	 .loc 1 2853 0
 4773 0014 BB69     	 ldr r3,[r7,#24]
 4774 0016 002B     	 cmp r3,#0
 4775 0018 09D1     	 bne .L346
 4776              	.LBB211:
 4777              	.LBB212:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 4778              	 .loc 2 195 0 discriminator 1
 4779              	
 4780 001a 4FF0FC03 	 mov r3,#252
 4781 001e 83F31188 	 msr basepri,r3
 4782 0022 BFF36F8F 	 isb 
 4783 0026 BFF34F8F 	 dsb 
 4784              	
 4785              	
 4786              	 .thumb
 4787 002a 3B61     	 str r3,[r7,#16]
 4788              	.L347:
 4789              	.LBE212:
 4790              	.LBE211:
 4791              	 .loc 1 2853 0 discriminator 1
 4792 002c FEE7     	 b .L347
 4793              	.L346:
2854:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
 4794              	 .loc 1 2854 0
 4795 002e BB69     	 ldr r3,[r7,#24]
 4796 0030 9A6B     	 ldr r2,[r3,#56]
 4797 0032 BB69     	 ldr r3,[r7,#24]
 4798 0034 DB6B     	 ldr r3,[r3,#60]
 4799 0036 9A42     	 cmp r2,r3
 4800 0038 09D3     	 bcc .L348
 4801              	.LBB213:
 4802              	.LBB214:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 4803              	 .loc 2 195 0 discriminator 1
 4804              	
 4805 003a 4FF0FC03 	 mov r3,#252
 4806 003e 83F31188 	 msr basepri,r3
 4807 0042 BFF36F8F 	 isb 
 4808 0046 BFF34F8F 	 dsb 
 4809              	
 4810              	
 4811              	 .thumb
 4812 004a FB60     	 str r3,[r7,#12]
 4813              	.L349:
 4814              	.LBE214:
 4815              	.LBE213:
 4816              	 .loc 1 2854 0 discriminator 2
 4817 004c FEE7     	 b .L349
 4818              	.L348:
2855:../Dave/Generated/FREERTOS/queue.c **** 
2856:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
 4819              	 .loc 1 2856 0
 4820 004e BB69     	 ldr r3,[r7,#24]
 4821 0050 9A6B     	 ldr r2,[r3,#56]
 4822 0052 BB69     	 ldr r3,[r7,#24]
 4823 0054 DB6B     	 ldr r3,[r3,#60]
 4824 0056 9A42     	 cmp r2,r3
 4825 0058 26D2     	 bcs .L350
 4826              	.LBB215:
2857:../Dave/Generated/FREERTOS/queue.c **** 		{
2858:../Dave/Generated/FREERTOS/queue.c **** 			const int8_t cTxLock = pxQueueSetContainer->cTxLock;
 4827              	 .loc 1 2858 0
 4828 005a BB69     	 ldr r3,[r7,#24]
 4829 005c 93F84530 	 ldrb r3,[r3,#69]
 4830 0060 FB75     	 strb r3,[r7,#23]
2859:../Dave/Generated/FREERTOS/queue.c **** 
2860:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_SEND( pxQueueSetContainer );
2861:../Dave/Generated/FREERTOS/queue.c **** 
2862:../Dave/Generated/FREERTOS/queue.c **** 			/* The data copied is the handle of the queue that contains data. */
2863:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
 4831              	 .loc 1 2863 0
 4832 0062 3B1D     	 adds r3,r7,#4
 4833 0064 B869     	 ldr r0,[r7,#24]
 4834 0066 1946     	 mov r1,r3
 4835 0068 3A68     	 ldr r2,[r7]
 4836 006a FFF7FEFF 	 bl prvCopyDataToQueue
 4837 006e F861     	 str r0,[r7,#28]
2864:../Dave/Generated/FREERTOS/queue.c **** 
2865:../Dave/Generated/FREERTOS/queue.c **** 			if( cTxLock == queueUNLOCKED )
 4838              	 .loc 1 2865 0
 4839 0070 97F91730 	 ldrsb r3,[r7,#23]
 4840 0074 B3F1FF3F 	 cmp r3,#-1
 4841 0078 0ED1     	 bne .L351
2866:../Dave/Generated/FREERTOS/queue.c **** 			{
2867:../Dave/Generated/FREERTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
 4842              	 .loc 1 2867 0
 4843 007a BB69     	 ldr r3,[r7,#24]
 4844 007c 5B6A     	 ldr r3,[r3,#36]
 4845 007e 002B     	 cmp r3,#0
 4846 0080 12D0     	 beq .L352
2868:../Dave/Generated/FREERTOS/queue.c **** 				{
2869:../Dave/Generated/FREERTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
 4847              	 .loc 1 2869 0
 4848 0082 BB69     	 ldr r3,[r7,#24]
 4849 0084 2433     	 adds r3,r3,#36
 4850 0086 1846     	 mov r0,r3
 4851 0088 FFF7FEFF 	 bl xTaskRemoveFromEventList
 4852 008c 0346     	 mov r3,r0
 4853 008e 002B     	 cmp r3,#0
 4854 0090 0AD0     	 beq .L352
2870:../Dave/Generated/FREERTOS/queue.c **** 					{
2871:../Dave/Generated/FREERTOS/queue.c **** 						/* The task waiting has a higher priority. */
2872:../Dave/Generated/FREERTOS/queue.c **** 						xReturn = pdTRUE;
 4855              	 .loc 1 2872 0
 4856 0092 0123     	 movs r3,#1
 4857 0094 FB61     	 str r3,[r7,#28]
 4858 0096 07E0     	 b .L352
 4859              	.L351:
2873:../Dave/Generated/FREERTOS/queue.c **** 					}
2874:../Dave/Generated/FREERTOS/queue.c **** 					else
2875:../Dave/Generated/FREERTOS/queue.c **** 					{
2876:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2877:../Dave/Generated/FREERTOS/queue.c **** 					}
2878:../Dave/Generated/FREERTOS/queue.c **** 				}
2879:../Dave/Generated/FREERTOS/queue.c **** 				else
2880:../Dave/Generated/FREERTOS/queue.c **** 				{
2881:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2882:../Dave/Generated/FREERTOS/queue.c **** 				}
2883:../Dave/Generated/FREERTOS/queue.c **** 			}
2884:../Dave/Generated/FREERTOS/queue.c **** 			else
2885:../Dave/Generated/FREERTOS/queue.c **** 			{
2886:../Dave/Generated/FREERTOS/queue.c **** 				pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );
 4860              	 .loc 1 2886 0
 4861 0098 FB7D     	 ldrb r3,[r7,#23]
 4862 009a 0133     	 adds r3,r3,#1
 4863 009c DBB2     	 uxtb r3,r3
 4864 009e DAB2     	 uxtb r2,r3
 4865 00a0 BB69     	 ldr r3,[r7,#24]
 4866 00a2 83F84520 	 strb r2,[r3,#69]
 4867              	.LBE215:
 4868 00a6 FFE7     	 b .L350
 4869              	.L352:
 4870              	.L350:
2887:../Dave/Generated/FREERTOS/queue.c **** 			}
2888:../Dave/Generated/FREERTOS/queue.c **** 		}
2889:../Dave/Generated/FREERTOS/queue.c **** 		else
2890:../Dave/Generated/FREERTOS/queue.c **** 		{
2891:../Dave/Generated/FREERTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2892:../Dave/Generated/FREERTOS/queue.c **** 		}
2893:../Dave/Generated/FREERTOS/queue.c **** 
2894:../Dave/Generated/FREERTOS/queue.c **** 		return xReturn;
 4871              	 .loc 1 2894 0
 4872 00a8 FB69     	 ldr r3,[r7,#28]
2895:../Dave/Generated/FREERTOS/queue.c **** 	}
 4873              	 .loc 1 2895 0
 4874 00aa 1846     	 mov r0,r3
 4875 00ac 2037     	 adds r7,r7,#32
 4876              	 .cfi_def_cfa_offset 8
 4877 00ae BD46     	 mov sp,r7
 4878              	 .cfi_def_cfa_register 13
 4879              	 
 4880 00b0 80BD     	 pop {r7,pc}
 4881              	 .cfi_endproc
 4882              	.LFE179:
 4884 00b2 00BF     	 .text
 4885              	.Letext0:
 4886              	 .file 3 "c:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\lib\\gcc\\arm-none-eabi\\4.9.3\\include\\stddef.h"
 4887              	 .file 4 "c:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 4888              	 .file 5 "c:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 4889              	 .file 6 "../Dave/Generated/FREERTOS/list.h"
 4890              	 .file 7 "../Dave/Generated/FREERTOS/task.h"
 4891              	 .file 8 "../Dave/Generated/FREERTOS/queue.h"
 4892              	 .file 9 "C:/Users/Yoshi/Documents/GitHub/Software/01_jrg/04_CANModule/CAN_Modul_keckvale_AH/Libraries/CMSIS/Include/cmsis_gcc.h"
 4893              	 .file 10 "C:/Users/Yoshi/Documents/GitHub/Software/01_jrg/04_CANModule/CAN_Modul_keckvale_AH/Libraries/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 queue.c
                            *COM*:00000040 xQueueRegistry
    {standard input}:21     .text.xQueueGenericReset:00000000 $t
    {standard input}:26     .text.xQueueGenericReset:00000000 xQueueGenericReset
    {standard input}:167    .text.xQueueGenericReset:000000cc $d
    {standard input}:172    .text.xQueueGenericCreate:00000000 $t
    {standard input}:177    .text.xQueueGenericCreate:00000000 xQueueGenericCreate
    {standard input}:275    .text.prvInitialiseNewQueue:00000000 prvInitialiseNewQueue
    {standard input}:271    .text.prvInitialiseNewQueue:00000000 $t
    {standard input}:339    .text.prvInitialiseMutex:00000000 $t
    {standard input}:343    .text.prvInitialiseMutex:00000000 prvInitialiseMutex
    {standard input}:858    .text.xQueueGenericSend:00000000 xQueueGenericSend
    {standard input}:392    .text.xQueueCreateMutex:00000000 $t
    {standard input}:397    .text.xQueueCreateMutex:00000000 xQueueCreateMutex
    {standard input}:442    .text.xQueueGetMutexHolder:00000000 $t
    {standard input}:447    .text.xQueueGetMutexHolder:00000000 xQueueGetMutexHolder
    {standard input}:495    .text.xQueueGetMutexHolderFromISR:00000000 $t
    {standard input}:500    .text.xQueueGetMutexHolderFromISR:00000000 xQueueGetMutexHolderFromISR
    {standard input}:569    .text.xQueueGiveMutexRecursive:00000000 $t
    {standard input}:574    .text.xQueueGiveMutexRecursive:00000000 xQueueGiveMutexRecursive
    {standard input}:663    .text.xQueueTakeMutexRecursive:00000000 $t
    {standard input}:668    .text.xQueueTakeMutexRecursive:00000000 xQueueTakeMutexRecursive
    {standard input}:2069   .text.xQueueSemaphoreTake:00000000 xQueueSemaphoreTake
    {standard input}:758    .text.xQueueCreateCountingSemaphore:00000000 $t
    {standard input}:763    .text.xQueueCreateCountingSemaphore:00000000 xQueueCreateCountingSemaphore
    {standard input}:853    .text.xQueueGenericSend:00000000 $t
    {standard input}:3564   .text.prvCopyDataToQueue:00000000 prvCopyDataToQueue
    {standard input}:4749   .text.prvNotifyQueueSetContainer:00000000 prvNotifyQueueSetContainer
    {standard input}:4049   .text.prvIsQueueFull:00000000 prvIsQueueFull
    {standard input}:3783   .text.prvUnlockQueue:00000000 prvUnlockQueue
    {standard input}:1237   .text.xQueueGenericSend:00000220 $d
    {standard input}:1242   .text.xQueueGenericSendFromISR:00000000 $t
    {standard input}:1247   .text.xQueueGenericSendFromISR:00000000 xQueueGenericSendFromISR
    {standard input}:1504   .text.xQueueGiveFromISR:00000000 $t
    {standard input}:1509   .text.xQueueGiveFromISR:00000000 xQueueGiveFromISR
    {standard input}:1749   .text.xQueueReceive:00000000 $t
    {standard input}:1754   .text.xQueueReceive:00000000 xQueueReceive
    {standard input}:3716   .text.prvCopyDataFromQueue:00000000 prvCopyDataFromQueue
    {standard input}:3925   .text.prvIsQueueEmpty:00000000 prvIsQueueEmpty
    {standard input}:2059   .text.xQueueReceive:000001bc $d
    {standard input}:2064   .text.xQueueSemaphoreTake:00000000 $t
    {standard input}:3511   .text.prvGetDisinheritPriorityAfterTimeout:00000000 prvGetDisinheritPriorityAfterTimeout
    {standard input}:2427   .text.xQueueSemaphoreTake:00000210 $d
    {standard input}:2432   .text.xQueuePeek:00000000 $t
    {standard input}:2437   .text.xQueuePeek:00000000 xQueuePeek
    {standard input}:2745   .text.xQueuePeek:000001c0 $d
    {standard input}:2750   .text.xQueueReceiveFromISR:00000000 $t
    {standard input}:2755   .text.xQueueReceiveFromISR:00000000 xQueueReceiveFromISR
    {standard input}:2952   .text.xQueuePeekFromISR:00000000 $t
    {standard input}:2957   .text.xQueuePeekFromISR:00000000 xQueuePeekFromISR
    {standard input}:3133   .text.uxQueueMessagesWaiting:00000000 $t
    {standard input}:3138   .text.uxQueueMessagesWaiting:00000000 uxQueueMessagesWaiting
    {standard input}:3197   .text.uxQueueSpacesAvailable:00000000 $t
    {standard input}:3202   .text.uxQueueSpacesAvailable:00000000 uxQueueSpacesAvailable
    {standard input}:3267   .text.uxQueueMessagesWaitingFromISR:00000000 $t
    {standard input}:3272   .text.uxQueueMessagesWaitingFromISR:00000000 uxQueueMessagesWaitingFromISR
    {standard input}:3330   .text.vQueueDelete:00000000 $t
    {standard input}:3335   .text.vQueueDelete:00000000 vQueueDelete
    {standard input}:4329   .text.vQueueUnregisterQueue:00000000 vQueueUnregisterQueue
    {standard input}:3392   .text.uxQueueGetQueueNumber:00000000 $t
    {standard input}:3397   .text.uxQueueGetQueueNumber:00000000 uxQueueGetQueueNumber
    {standard input}:3430   .text.vQueueSetQueueNumber:00000000 $t
    {standard input}:3435   .text.vQueueSetQueueNumber:00000000 vQueueSetQueueNumber
    {standard input}:3469   .text.ucQueueGetQueueType:00000000 $t
    {standard input}:3474   .text.ucQueueGetQueueType:00000000 ucQueueGetQueueType
    {standard input}:3507   .text.prvGetDisinheritPriorityAfterTimeout:00000000 $t
    {standard input}:3560   .text.prvCopyDataToQueue:00000000 $t
    {standard input}:3712   .text.prvCopyDataFromQueue:00000000 $t
    {standard input}:3779   .text.prvUnlockQueue:00000000 $t
    {standard input}:3921   .text.prvIsQueueEmpty:00000000 $t
    {standard input}:3972   .text.xQueueIsQueueEmptyFromISR:00000000 $t
    {standard input}:3977   .text.xQueueIsQueueEmptyFromISR:00000000 xQueueIsQueueEmptyFromISR
    {standard input}:4045   .text.prvIsQueueFull:00000000 $t
    {standard input}:4098   .text.xQueueIsQueueFullFromISR:00000000 $t
    {standard input}:4103   .text.xQueueIsQueueFullFromISR:00000000 xQueueIsQueueFullFromISR
    {standard input}:4173   .text.vQueueAddToRegistry:00000000 $t
    {standard input}:4178   .text.vQueueAddToRegistry:00000000 vQueueAddToRegistry
    {standard input}:4243   .text.vQueueAddToRegistry:0000004c $d
    {standard input}:4248   .text.pcQueueGetName:00000000 $t
    {standard input}:4253   .text.pcQueueGetName:00000000 pcQueueGetName
    {standard input}:4319   .text.pcQueueGetName:00000048 $d
    {standard input}:4324   .text.vQueueUnregisterQueue:00000000 $t
    {standard input}:4396   .text.vQueueUnregisterQueue:0000004c $d
    {standard input}:4401   .text.vQueueWaitForMessageRestricted:00000000 $t
    {standard input}:4406   .text.vQueueWaitForMessageRestricted:00000000 vQueueWaitForMessageRestricted
    {standard input}:4480   .text.xQueueCreateSet:00000000 $t
    {standard input}:4485   .text.xQueueCreateSet:00000000 xQueueCreateSet
    {standard input}:4520   .text.xQueueAddToSet:00000000 $t
    {standard input}:4525   .text.xQueueAddToSet:00000000 xQueueAddToSet
    {standard input}:4587   .text.xQueueRemoveFromSet:00000000 $t
    {standard input}:4592   .text.xQueueRemoveFromSet:00000000 xQueueRemoveFromSet
    {standard input}:4658   .text.xQueueSelectFromSet:00000000 $t
    {standard input}:4663   .text.xQueueSelectFromSet:00000000 xQueueSelectFromSet
    {standard input}:4702   .text.xQueueSelectFromSetFromISR:00000000 $t
    {standard input}:4707   .text.xQueueSelectFromSetFromISR:00000000 xQueueSelectFromSetFromISR
    {standard input}:4745   .text.prvNotifyQueueSetContainer:00000000 $t
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
vPortEnterCritical
xTaskRemoveFromEventList
vListInitialise
vPortExitCritical
pvPortMalloc
xTaskGetCurrentTaskHandle
xTaskGetSchedulerState
vTaskInternalSetTimeOutState
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskResumeAll
vPortValidateInterruptPriority
pvTaskIncrementMutexHeldCount
xTaskPriorityInherit
vTaskPriorityDisinheritAfterTimeout
vPortFree
xTaskPriorityDisinherit
memcpy
vTaskMissedYield
vTaskPlaceOnEventListRestricted
