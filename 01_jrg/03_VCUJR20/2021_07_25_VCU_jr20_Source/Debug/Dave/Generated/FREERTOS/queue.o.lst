   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,6
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "queue.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .comm xQueueRegistry,64,4
  20              	 .section .text.xQueueGenericReset,"ax",%progbits
  21              	 .align 2
  22              	 .global xQueueGenericReset
  23              	 .thumb
  24              	 .thumb_func
  26              	xQueueGenericReset:
  27              	.LFB137:
  28              	 .file 1 "../Dave/Generated/FREERTOS/queue.c"
   1:../Dave/Generated/FREERTOS/queue.c **** /*
   2:../Dave/Generated/FREERTOS/queue.c ****  * FreeRTOS Kernel V10.2.1
   3:../Dave/Generated/FREERTOS/queue.c ****  * Copyright (C) 2019 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:../Dave/Generated/FREERTOS/queue.c ****  *
   5:../Dave/Generated/FREERTOS/queue.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:../Dave/Generated/FREERTOS/queue.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:../Dave/Generated/FREERTOS/queue.c ****  * the Software without restriction, including without limitation the rights to
   8:../Dave/Generated/FREERTOS/queue.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:../Dave/Generated/FREERTOS/queue.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:../Dave/Generated/FREERTOS/queue.c ****  * subject to the following conditions:
  11:../Dave/Generated/FREERTOS/queue.c ****  *
  12:../Dave/Generated/FREERTOS/queue.c ****  * The above copyright notice and this permission notice shall be included in all
  13:../Dave/Generated/FREERTOS/queue.c ****  * copies or substantial portions of the Software.
  14:../Dave/Generated/FREERTOS/queue.c ****  *
  15:../Dave/Generated/FREERTOS/queue.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:../Dave/Generated/FREERTOS/queue.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:../Dave/Generated/FREERTOS/queue.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:../Dave/Generated/FREERTOS/queue.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:../Dave/Generated/FREERTOS/queue.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:../Dave/Generated/FREERTOS/queue.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:../Dave/Generated/FREERTOS/queue.c ****  *
  22:../Dave/Generated/FREERTOS/queue.c ****  * http://www.FreeRTOS.org
  23:../Dave/Generated/FREERTOS/queue.c ****  * http://aws.amazon.com/freertos
  24:../Dave/Generated/FREERTOS/queue.c ****  *
  25:../Dave/Generated/FREERTOS/queue.c ****  * 1 tab == 4 spaces!
  26:../Dave/Generated/FREERTOS/queue.c ****  */
  27:../Dave/Generated/FREERTOS/queue.c **** 
  28:../Dave/Generated/FREERTOS/queue.c **** #include <stdlib.h>
  29:../Dave/Generated/FREERTOS/queue.c **** #include <string.h>
  30:../Dave/Generated/FREERTOS/queue.c **** 
  31:../Dave/Generated/FREERTOS/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  32:../Dave/Generated/FREERTOS/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  33:../Dave/Generated/FREERTOS/queue.c **** task.h is included from an application file. */
  34:../Dave/Generated/FREERTOS/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  35:../Dave/Generated/FREERTOS/queue.c **** 
  36:../Dave/Generated/FREERTOS/queue.c **** #include "FreeRTOS.h"
  37:../Dave/Generated/FREERTOS/queue.c **** #include "task.h"
  38:../Dave/Generated/FREERTOS/queue.c **** #include "queue.h"
  39:../Dave/Generated/FREERTOS/queue.c **** 
  40:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  41:../Dave/Generated/FREERTOS/queue.c **** 	#include "croutine.h"
  42:../Dave/Generated/FREERTOS/queue.c **** #endif
  43:../Dave/Generated/FREERTOS/queue.c **** 
  44:../Dave/Generated/FREERTOS/queue.c **** /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
  45:../Dave/Generated/FREERTOS/queue.c **** because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
  46:../Dave/Generated/FREERTOS/queue.c **** for the header files above, but not in this file, in order to generate the
  47:../Dave/Generated/FREERTOS/queue.c **** correct privileged Vs unprivileged linkage and placement. */
  48:../Dave/Generated/FREERTOS/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
  49:../Dave/Generated/FREERTOS/queue.c **** 
  50:../Dave/Generated/FREERTOS/queue.c **** 
  51:../Dave/Generated/FREERTOS/queue.c **** /* Constants used with the cRxLock and cTxLock structure members. */
  52:../Dave/Generated/FREERTOS/queue.c **** #define queueUNLOCKED					( ( int8_t ) -1 )
  53:../Dave/Generated/FREERTOS/queue.c **** #define queueLOCKED_UNMODIFIED			( ( int8_t ) 0 )
  54:../Dave/Generated/FREERTOS/queue.c **** 
  55:../Dave/Generated/FREERTOS/queue.c **** /* When the Queue_t structure is used to represent a base queue its pcHead and
  56:../Dave/Generated/FREERTOS/queue.c **** pcTail members are used as pointers into the queue storage area.  When the
  57:../Dave/Generated/FREERTOS/queue.c **** Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
  58:../Dave/Generated/FREERTOS/queue.c **** not necessary, and the pcHead pointer is set to NULL to indicate that the
  59:../Dave/Generated/FREERTOS/queue.c **** structure instead holds a pointer to the mutex holder (if any).  Map alternative
  60:../Dave/Generated/FREERTOS/queue.c **** names to the pcHead and structure member to ensure the readability of the code
  61:../Dave/Generated/FREERTOS/queue.c **** is maintained.  The QueuePointers_t and SemaphoreData_t types are used to form
  62:../Dave/Generated/FREERTOS/queue.c **** a union as their usage is mutually exclusive dependent on what the queue is
  63:../Dave/Generated/FREERTOS/queue.c **** being used for. */
  64:../Dave/Generated/FREERTOS/queue.c **** #define uxQueueType						pcHead
  65:../Dave/Generated/FREERTOS/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
  66:../Dave/Generated/FREERTOS/queue.c **** 
  67:../Dave/Generated/FREERTOS/queue.c **** typedef struct QueuePointers
  68:../Dave/Generated/FREERTOS/queue.c **** {
  69:../Dave/Generated/FREERTOS/queue.c **** 	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte i
  70:../Dave/Generated/FREERTOS/queue.c **** 	int8_t *pcReadFrom;				/*< Points to the last place that a queued item was read from when the stru
  71:../Dave/Generated/FREERTOS/queue.c **** } QueuePointers_t;
  72:../Dave/Generated/FREERTOS/queue.c **** 
  73:../Dave/Generated/FREERTOS/queue.c **** typedef struct SemaphoreData
  74:../Dave/Generated/FREERTOS/queue.c **** {
  75:../Dave/Generated/FREERTOS/queue.c **** 	TaskHandle_t xMutexHolder;		 /*< The handle of the task that holds the mutex. */
  76:../Dave/Generated/FREERTOS/queue.c **** 	UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex ha
  77:../Dave/Generated/FREERTOS/queue.c **** } SemaphoreData_t;
  78:../Dave/Generated/FREERTOS/queue.c **** 
  79:../Dave/Generated/FREERTOS/queue.c **** /* Semaphores do not actually store or copy data, so have an item size of
  80:../Dave/Generated/FREERTOS/queue.c **** zero. */
  81:../Dave/Generated/FREERTOS/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
  82:../Dave/Generated/FREERTOS/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
  83:../Dave/Generated/FREERTOS/queue.c **** 
  84:../Dave/Generated/FREERTOS/queue.c **** #if( configUSE_PREEMPTION == 0 )
  85:../Dave/Generated/FREERTOS/queue.c **** 	/* If the cooperative scheduler is being used then a yield should not be
  86:../Dave/Generated/FREERTOS/queue.c **** 	performed just because a higher priority task has been woken. */
  87:../Dave/Generated/FREERTOS/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION()
  88:../Dave/Generated/FREERTOS/queue.c **** #else
  89:../Dave/Generated/FREERTOS/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
  90:../Dave/Generated/FREERTOS/queue.c **** #endif
  91:../Dave/Generated/FREERTOS/queue.c **** 
  92:../Dave/Generated/FREERTOS/queue.c **** /*
  93:../Dave/Generated/FREERTOS/queue.c ****  * Definition of the queue used by the scheduler.
  94:../Dave/Generated/FREERTOS/queue.c ****  * Items are queued by copy, not reference.  See the following link for the
  95:../Dave/Generated/FREERTOS/queue.c ****  * rationale: https://www.freertos.org/Embedded-RTOS-Queues.html
  96:../Dave/Generated/FREERTOS/queue.c ****  */
  97:../Dave/Generated/FREERTOS/queue.c **** typedef struct QueueDefinition 		/* The old naming convention is used to prevent breaking kernel aw
  98:../Dave/Generated/FREERTOS/queue.c **** {
  99:../Dave/Generated/FREERTOS/queue.c **** 	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
 100:../Dave/Generated/FREERTOS/queue.c **** 	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
 101:../Dave/Generated/FREERTOS/queue.c **** 
 102:../Dave/Generated/FREERTOS/queue.c **** 	union
 103:../Dave/Generated/FREERTOS/queue.c **** 	{
 104:../Dave/Generated/FREERTOS/queue.c **** 		QueuePointers_t xQueue;		/*< Data required exclusively when this structure is used as a queue. */
 105:../Dave/Generated/FREERTOS/queue.c **** 		SemaphoreData_t xSemaphore; /*< Data required exclusively when this structure is used as a semaph
 106:../Dave/Generated/FREERTOS/queue.c **** 	} u;
 107:../Dave/Generated/FREERTOS/queue.c **** 
 108:../Dave/Generated/FREERTOS/queue.c **** 	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  
 109:../Dave/Generated/FREERTOS/queue.c **** 	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.
 110:../Dave/Generated/FREERTOS/queue.c **** 
 111:../Dave/Generated/FREERTOS/queue.c **** 	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
 112:../Dave/Generated/FREERTOS/queue.c **** 	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, n
 113:../Dave/Generated/FREERTOS/queue.c **** 	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
 114:../Dave/Generated/FREERTOS/queue.c **** 
 115:../Dave/Generated/FREERTOS/queue.c **** 	volatile int8_t cRxLock;		/*< Stores the number of items received from the queue (removed from the
 116:../Dave/Generated/FREERTOS/queue.c **** 	volatile int8_t cTxLock;		/*< Stores the number of items transmitted to the queue (added to the qu
 117:../Dave/Generated/FREERTOS/queue.c **** 
 118:../Dave/Generated/FREERTOS/queue.c **** 	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 119:../Dave/Generated/FREERTOS/queue.c **** 		uint8_t ucStaticallyAllocated;	/*< Set to pdTRUE if the memory used by the queue was statically a
 120:../Dave/Generated/FREERTOS/queue.c **** 	#endif
 121:../Dave/Generated/FREERTOS/queue.c **** 
 122:../Dave/Generated/FREERTOS/queue.c **** 	#if ( configUSE_QUEUE_SETS == 1 )
 123:../Dave/Generated/FREERTOS/queue.c **** 		struct QueueDefinition *pxQueueSetContainer;
 124:../Dave/Generated/FREERTOS/queue.c **** 	#endif
 125:../Dave/Generated/FREERTOS/queue.c **** 
 126:../Dave/Generated/FREERTOS/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 127:../Dave/Generated/FREERTOS/queue.c **** 		UBaseType_t uxQueueNumber;
 128:../Dave/Generated/FREERTOS/queue.c **** 		uint8_t ucQueueType;
 129:../Dave/Generated/FREERTOS/queue.c **** 	#endif
 130:../Dave/Generated/FREERTOS/queue.c **** 
 131:../Dave/Generated/FREERTOS/queue.c **** } xQUEUE;
 132:../Dave/Generated/FREERTOS/queue.c **** 
 133:../Dave/Generated/FREERTOS/queue.c **** /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
 134:../Dave/Generated/FREERTOS/queue.c **** name below to enable the use of older kernel aware debuggers. */
 135:../Dave/Generated/FREERTOS/queue.c **** typedef xQUEUE Queue_t;
 136:../Dave/Generated/FREERTOS/queue.c **** 
 137:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 138:../Dave/Generated/FREERTOS/queue.c **** 
 139:../Dave/Generated/FREERTOS/queue.c **** /*
 140:../Dave/Generated/FREERTOS/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 141:../Dave/Generated/FREERTOS/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 142:../Dave/Generated/FREERTOS/queue.c ****  */
 143:../Dave/Generated/FREERTOS/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
 144:../Dave/Generated/FREERTOS/queue.c **** 
 145:../Dave/Generated/FREERTOS/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 146:../Dave/Generated/FREERTOS/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 147:../Dave/Generated/FREERTOS/queue.c **** 	more user friendly. */
 148:../Dave/Generated/FREERTOS/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 149:../Dave/Generated/FREERTOS/queue.c **** 	{
 150:../Dave/Generated/FREERTOS/queue.c **** 		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single c
 151:../Dave/Generated/FREERTOS/queue.c **** 		QueueHandle_t xHandle;
 152:../Dave/Generated/FREERTOS/queue.c **** 	} xQueueRegistryItem;
 153:../Dave/Generated/FREERTOS/queue.c **** 
 154:../Dave/Generated/FREERTOS/queue.c **** 	/* The old xQueueRegistryItem name is maintained above then typedefed to the
 155:../Dave/Generated/FREERTOS/queue.c **** 	new xQueueRegistryItem name below to enable the use of older kernel aware
 156:../Dave/Generated/FREERTOS/queue.c **** 	debuggers. */
 157:../Dave/Generated/FREERTOS/queue.c **** 	typedef xQueueRegistryItem QueueRegistryItem_t;
 158:../Dave/Generated/FREERTOS/queue.c **** 
 159:../Dave/Generated/FREERTOS/queue.c **** 	/* The queue registry is simply an array of QueueRegistryItem_t structures.
 160:../Dave/Generated/FREERTOS/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 161:../Dave/Generated/FREERTOS/queue.c **** 	array position being vacant. */
 162:../Dave/Generated/FREERTOS/queue.c **** 	PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 163:../Dave/Generated/FREERTOS/queue.c **** 
 164:../Dave/Generated/FREERTOS/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
 165:../Dave/Generated/FREERTOS/queue.c **** 
 166:../Dave/Generated/FREERTOS/queue.c **** /*
 167:../Dave/Generated/FREERTOS/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 168:../Dave/Generated/FREERTOS/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 169:../Dave/Generated/FREERTOS/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 170:../Dave/Generated/FREERTOS/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 171:../Dave/Generated/FREERTOS/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 172:../Dave/Generated/FREERTOS/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 173:../Dave/Generated/FREERTOS/queue.c ****  */
 174:../Dave/Generated/FREERTOS/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
 175:../Dave/Generated/FREERTOS/queue.c **** 
 176:../Dave/Generated/FREERTOS/queue.c **** /*
 177:../Dave/Generated/FREERTOS/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 178:../Dave/Generated/FREERTOS/queue.c ****  *
 179:../Dave/Generated/FREERTOS/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 180:../Dave/Generated/FREERTOS/queue.c ****  */
 181:../Dave/Generated/FREERTOS/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 182:../Dave/Generated/FREERTOS/queue.c **** 
 183:../Dave/Generated/FREERTOS/queue.c **** /*
 184:../Dave/Generated/FREERTOS/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 185:../Dave/Generated/FREERTOS/queue.c ****  *
 186:../Dave/Generated/FREERTOS/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 187:../Dave/Generated/FREERTOS/queue.c ****  */
 188:../Dave/Generated/FREERTOS/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 189:../Dave/Generated/FREERTOS/queue.c **** 
 190:../Dave/Generated/FREERTOS/queue.c **** /*
 191:../Dave/Generated/FREERTOS/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 192:../Dave/Generated/FREERTOS/queue.c ****  * back of the queue.
 193:../Dave/Generated/FREERTOS/queue.c ****  */
 194:../Dave/Generated/FREERTOS/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
 195:../Dave/Generated/FREERTOS/queue.c **** 
 196:../Dave/Generated/FREERTOS/queue.c **** /*
 197:../Dave/Generated/FREERTOS/queue.c ****  * Copies an item out of a queue.
 198:../Dave/Generated/FREERTOS/queue.c ****  */
 199:../Dave/Generated/FREERTOS/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCT
 200:../Dave/Generated/FREERTOS/queue.c **** 
 201:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
 202:../Dave/Generated/FREERTOS/queue.c **** 	/*
 203:../Dave/Generated/FREERTOS/queue.c **** 	 * Checks to see if a queue is a member of a queue set, and if so, notifies
 204:../Dave/Generated/FREERTOS/queue.c **** 	 * the queue set that the queue contains data.
 205:../Dave/Generated/FREERTOS/queue.c **** 	 */
 206:../Dave/Generated/FREERTOS/queue.c **** 	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCop
 207:../Dave/Generated/FREERTOS/queue.c **** #endif
 208:../Dave/Generated/FREERTOS/queue.c **** 
 209:../Dave/Generated/FREERTOS/queue.c **** /*
 210:../Dave/Generated/FREERTOS/queue.c ****  * Called after a Queue_t structure has been allocated either statically or
 211:../Dave/Generated/FREERTOS/queue.c ****  * dynamically to fill in the structure's members.
 212:../Dave/Generated/FREERTOS/queue.c ****  */
 213:../Dave/Generated/FREERTOS/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, u
 214:../Dave/Generated/FREERTOS/queue.c **** 
 215:../Dave/Generated/FREERTOS/queue.c **** /*
 216:../Dave/Generated/FREERTOS/queue.c ****  * Mutexes are a special type of queue.  When a mutex is created, first the
 217:../Dave/Generated/FREERTOS/queue.c ****  * queue is created, then prvInitialiseMutex() is called to configure the queue
 218:../Dave/Generated/FREERTOS/queue.c ****  * as a mutex.
 219:../Dave/Generated/FREERTOS/queue.c ****  */
 220:../Dave/Generated/FREERTOS/queue.c **** #if( configUSE_MUTEXES == 1 )
 221:../Dave/Generated/FREERTOS/queue.c **** 	static void prvInitialiseMutex( Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;
 222:../Dave/Generated/FREERTOS/queue.c **** #endif
 223:../Dave/Generated/FREERTOS/queue.c **** 
 224:../Dave/Generated/FREERTOS/queue.c **** #if( configUSE_MUTEXES == 1 )
 225:../Dave/Generated/FREERTOS/queue.c **** 	/*
 226:../Dave/Generated/FREERTOS/queue.c **** 	 * If a task waiting for a mutex causes the mutex holder to inherit a
 227:../Dave/Generated/FREERTOS/queue.c **** 	 * priority, but the waiting task times out, then the holder should
 228:../Dave/Generated/FREERTOS/queue.c **** 	 * disinherit the priority - but only down to the highest priority of any
 229:../Dave/Generated/FREERTOS/queue.c **** 	 * other tasks that are waiting for the same mutex.  This function returns
 230:../Dave/Generated/FREERTOS/queue.c **** 	 * that priority.
 231:../Dave/Generated/FREERTOS/queue.c **** 	 */
 232:../Dave/Generated/FREERTOS/queue.c **** 	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue ) PRIVILEGE
 233:../Dave/Generated/FREERTOS/queue.c **** #endif
 234:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 235:../Dave/Generated/FREERTOS/queue.c **** 
 236:../Dave/Generated/FREERTOS/queue.c **** /*
 237:../Dave/Generated/FREERTOS/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 238:../Dave/Generated/FREERTOS/queue.c ****  * accessing the queue event lists.
 239:../Dave/Generated/FREERTOS/queue.c ****  */
 240:../Dave/Generated/FREERTOS/queue.c **** #define prvLockQueue( pxQueue )								\
 241:../Dave/Generated/FREERTOS/queue.c **** 	taskENTER_CRITICAL();									\
 242:../Dave/Generated/FREERTOS/queue.c **** 	{														\
 243:../Dave/Generated/FREERTOS/queue.c **** 		if( ( pxQueue )->cRxLock == queueUNLOCKED )			\
 244:../Dave/Generated/FREERTOS/queue.c **** 		{													\
 245:../Dave/Generated/FREERTOS/queue.c **** 			( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED;	\
 246:../Dave/Generated/FREERTOS/queue.c **** 		}													\
 247:../Dave/Generated/FREERTOS/queue.c **** 		if( ( pxQueue )->cTxLock == queueUNLOCKED )			\
 248:../Dave/Generated/FREERTOS/queue.c **** 		{													\
 249:../Dave/Generated/FREERTOS/queue.c **** 			( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED;	\
 250:../Dave/Generated/FREERTOS/queue.c **** 		}													\
 251:../Dave/Generated/FREERTOS/queue.c **** 	}														\
 252:../Dave/Generated/FREERTOS/queue.c **** 	taskEXIT_CRITICAL()
 253:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 254:../Dave/Generated/FREERTOS/queue.c **** 
 255:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
 256:../Dave/Generated/FREERTOS/queue.c **** {
  29              	 .loc 1 256 0
  30              	 .cfi_startproc
  31              	 
  32              	 
  33 0000 80B5     	 push {r7,lr}
  34              	.LCFI0:
  35              	 .cfi_def_cfa_offset 8
  36              	 .cfi_offset 7,-8
  37              	 .cfi_offset 14,-4
  38 0002 84B0     	 sub sp,sp,#16
  39              	.LCFI1:
  40              	 .cfi_def_cfa_offset 24
  41 0004 00AF     	 add r7,sp,#0
  42              	.LCFI2:
  43              	 .cfi_def_cfa_register 7
  44 0006 7860     	 str r0,[r7,#4]
  45 0008 3960     	 str r1,[r7]
 257:../Dave/Generated/FREERTOS/queue.c **** Queue_t * const pxQueue = xQueue;
  46              	 .loc 1 257 0
  47 000a 7B68     	 ldr r3,[r7,#4]
  48 000c FB60     	 str r3,[r7,#12]
 258:../Dave/Generated/FREERTOS/queue.c **** 
 259:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue );
  49              	 .loc 1 259 0
  50 000e FB68     	 ldr r3,[r7,#12]
  51 0010 002B     	 cmp r3,#0
  52 0012 09D1     	 bne .L2
  53              	.LBB109:
  54              	.LBB110:
  55              	 .file 2 "../Dave/Generated/FREERTOS/portable/GCC/portmacro.h"
   1:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*
   2:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * FreeRTOS Kernel V10.2.1
   3:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * Copyright (C) 2019 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  *
   5:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * this software and associated documentation files (the "Software"), to deal in
   7:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * the Software without restriction, including without limitation the rights to
   8:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * subject to the following conditions:
  11:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  *
  12:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * The above copyright notice and this permission notice shall be included in all
  13:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * copies or substantial portions of the Software.
  14:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  *
  15:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  *
  22:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * http://www.FreeRTOS.org
  23:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * http://aws.amazon.com/freertos
  24:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  *
  25:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * 1 tab == 4 spaces!
  26:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  */
  27:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  28:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  29:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #ifndef PORTMACRO_H
  30:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define PORTMACRO_H
  31:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  32:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #ifdef __cplusplus
  33:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** extern "C" {
  34:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #endif
  35:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  36:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*-----------------------------------------------------------
  37:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * Port specific definitions.
  38:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  *
  39:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * The settings in this file configure FreeRTOS correctly for the
  40:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * given hardware and compiler.
  41:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  *
  42:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  * These settings should not be altered.
  43:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  *-----------------------------------------------------------
  44:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h ****  */
  45:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  46:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /* Type definitions. */
  47:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portCHAR		char
  48:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portFLOAT		float
  49:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portDOUBLE		double
  50:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portLONG		long
  51:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portSHORT		short
  52:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portSTACK_TYPE	uint32_t
  53:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portBASE_TYPE	long
  54:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  55:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** typedef portSTACK_TYPE StackType_t;
  56:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** typedef long BaseType_t;
  57:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** typedef unsigned long UBaseType_t;
  58:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  59:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #if( configUSE_16_BIT_TICKS == 1 )
  60:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	typedef uint16_t TickType_t;
  61:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#define portMAX_DELAY ( TickType_t ) 0xffff
  62:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #else
  63:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	typedef uint32_t TickType_t;
  64:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
  65:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  66:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
  67:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	not need to be guarded with a critical section. */
  68:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#define portTICK_TYPE_IS_ATOMIC 1
  69:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #endif
  70:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*-----------------------------------------------------------*/
  71:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  72:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /* Architecture specifics. */
  73:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portSTACK_GROWTH			( -1 )
  74:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
  75:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portBYTE_ALIGNMENT			8
  76:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*-----------------------------------------------------------*/
  77:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  78:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /* Scheduler utilities. */
  79:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portYIELD() 															\
  80:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** {																				\
  81:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	/* Set a PendSV to request a context switch. */								\
  82:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
  83:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 																				\
  84:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	/* Barriers are normally not required but do ensure the code is completely	\
  85:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	within the specified behaviour for the architecture. */						\
  86:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	__asm volatile( "dsb" ::: "memory" );										\
  87:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	__asm volatile( "isb" );													\
  88:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** }
  89:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  90:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
  91:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
  92:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD()
  93:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
  94:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*-----------------------------------------------------------*/
  95:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
  96:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /* Critical section management. */
  97:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** extern void vPortEnterCritical( void );
  98:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** extern void vPortExitCritical( void );
  99:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
 100:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)
 101:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
 102:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portENABLE_INTERRUPTS()					vPortSetBASEPRI(0)
 103:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portENTER_CRITICAL()					vPortEnterCritical()
 104:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portEXIT_CRITICAL()						vPortExitCritical()
 105:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 106:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*-----------------------------------------------------------*/
 107:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 108:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /* Task function macros as described on the FreeRTOS.org WEB site.  These are
 109:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** not necessary for to use this port.  They are defined so the common demo files
 110:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** (which build with all the ports) will build. */
 111:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
 112:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
 113:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*-----------------------------------------------------------*/
 114:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 115:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /* Tickless idle/low power functionality. */
 116:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #ifndef portSUPPRESS_TICKS_AND_SLEEP
 117:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
 118:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdl
 119:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #endif
 120:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*-----------------------------------------------------------*/
 121:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 122:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /* Architecture specific optimisations. */
 123:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
 124:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
 125:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #endif
 126:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 127:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
 128:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 129:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	/* Generic helper function. */
 130:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitma
 131:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	{
 132:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	uint8_t ucReturn;
 133:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 134:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 135:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		return ucReturn;
 136:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	}
 137:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 138:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	/* Check the configuration. */
 139:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#if( configMAX_PRIORITIES > 32 )
 140:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is 
 141:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#endif
 142:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 143:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	/* Store/clear the ready priorities in a bit map. */
 144:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL 
 145:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL 
 146:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 147:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	/*-----------------------------------------------------------*/
 148:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 149:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( ui
 150:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 151:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 152:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 153:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*-----------------------------------------------------------*/
 154:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 155:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #ifdef configASSERT
 156:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	void vPortValidateInterruptPriority( void );
 157:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
 158:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #endif
 159:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 160:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /* portNOP() is not required by this port. */
 161:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portNOP()
 162:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 163:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #define portINLINE	__inline
 164:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 165:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #ifndef portFORCE_INLINE
 166:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	#define portFORCE_INLINE inline __attribute__(( always_inline))
 167:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** #endif
 168:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 169:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
 170:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** {
 171:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** uint32_t ulCurrentInterrupt;
 172:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** BaseType_t xReturn;
 173:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 174:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	/* Obtain the number of the currently executing interrupt. */
 175:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
 176:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 177:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	if( ulCurrentInterrupt == 0 )
 178:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	{
 179:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		xReturn = pdFALSE;
 180:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	}
 181:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	else
 182:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	{
 183:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		xReturn = pdTRUE;
 184:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	}
 185:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 186:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	return xReturn;
 187:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** }
 188:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 189:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*-----------------------------------------------------------*/
 190:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 191:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** portFORCE_INLINE static void vPortRaiseBASEPRI( void )
 192:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** {
 193:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** uint32_t ulNewBASEPRI;
 194:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	__asm volatile
  56              	 .loc 2 195 0 discriminator 1
  57              	
  58 0014 4FF0FC03 	 mov r3,#252
  59 0018 83F31188 	 msr basepri,r3
  60 001c BFF36F8F 	 isb 
  61 0020 BFF34F8F 	 dsb 
  62              	
  63              	
  64              	 .thumb
  65 0024 BB60     	 str r3,[r7,#8]
  66              	.L3:
  67              	.LBE110:
  68              	.LBE109:
  69              	 .loc 1 259 0 discriminator 1
  70 0026 FEE7     	 b .L3
  71              	.L2:
 260:../Dave/Generated/FREERTOS/queue.c **** 
 261:../Dave/Generated/FREERTOS/queue.c **** 	taskENTER_CRITICAL();
  72              	 .loc 1 261 0
  73 0028 FFF7FEFF 	 bl vPortEnterCritical
 262:../Dave/Generated/FREERTOS/queue.c **** 	{
 263:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint 
  74              	 .loc 1 263 0
  75 002c FB68     	 ldr r3,[r7,#12]
  76 002e 1A68     	 ldr r2,[r3]
  77 0030 FB68     	 ldr r3,[r7,#12]
  78 0032 DB6B     	 ldr r3,[r3,#60]
  79 0034 F968     	 ldr r1,[r7,#12]
  80 0036 096C     	 ldr r1,[r1,#64]
  81 0038 01FB03F3 	 mul r3,r1,r3
  82 003c 1A44     	 add r2,r2,r3
  83 003e FB68     	 ldr r3,[r7,#12]
  84 0040 9A60     	 str r2,[r3,#8]
 264:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
  85              	 .loc 1 264 0
  86 0042 FB68     	 ldr r3,[r7,#12]
  87 0044 0022     	 movs r2,#0
  88 0046 9A63     	 str r2,[r3,#56]
 265:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
  89              	 .loc 1 265 0
  90 0048 FB68     	 ldr r3,[r7,#12]
  91 004a 1A68     	 ldr r2,[r3]
  92 004c FB68     	 ldr r3,[r7,#12]
  93 004e 5A60     	 str r2,[r3,#4]
 266:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSi
  94              	 .loc 1 266 0
  95 0050 FB68     	 ldr r3,[r7,#12]
  96 0052 1A68     	 ldr r2,[r3]
  97 0054 FB68     	 ldr r3,[r7,#12]
  98 0056 DB6B     	 ldr r3,[r3,#60]
  99 0058 013B     	 subs r3,r3,#1
 100 005a F968     	 ldr r1,[r7,#12]
 101 005c 096C     	 ldr r1,[r1,#64]
 102 005e 01FB03F3 	 mul r3,r1,r3
 103 0062 1A44     	 add r2,r2,r3
 104 0064 FB68     	 ldr r3,[r7,#12]
 105 0066 DA60     	 str r2,[r3,#12]
 267:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
 106              	 .loc 1 267 0
 107 0068 FB68     	 ldr r3,[r7,#12]
 108 006a FF22     	 movs r2,#255
 109 006c 83F84420 	 strb r2,[r3,#68]
 268:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
 110              	 .loc 1 268 0
 111 0070 FB68     	 ldr r3,[r7,#12]
 112 0072 FF22     	 movs r2,#255
 113 0074 83F84520 	 strb r2,[r3,#69]
 269:../Dave/Generated/FREERTOS/queue.c **** 
 270:../Dave/Generated/FREERTOS/queue.c **** 		if( xNewQueue == pdFALSE )
 114              	 .loc 1 270 0
 115 0078 3B68     	 ldr r3,[r7]
 116 007a 002B     	 cmp r3,#0
 117 007c 14D1     	 bne .L4
 271:../Dave/Generated/FREERTOS/queue.c **** 		{
 272:../Dave/Generated/FREERTOS/queue.c **** 			/* If there are tasks blocked waiting to read from the queue, then
 273:../Dave/Generated/FREERTOS/queue.c **** 			the tasks will remain blocked as after this function exits the queue
 274:../Dave/Generated/FREERTOS/queue.c **** 			will still be empty.  If there are tasks blocked waiting to write to
 275:../Dave/Generated/FREERTOS/queue.c **** 			the queue, then one should be unblocked as after this function exits
 276:../Dave/Generated/FREERTOS/queue.c **** 			it will be possible to write to it. */
 277:../Dave/Generated/FREERTOS/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 118              	 .loc 1 277 0
 119 007e FB68     	 ldr r3,[r7,#12]
 120 0080 1B69     	 ldr r3,[r3,#16]
 121 0082 002B     	 cmp r3,#0
 122 0084 1AD0     	 beq .L5
 278:../Dave/Generated/FREERTOS/queue.c **** 			{
 279:../Dave/Generated/FREERTOS/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 123              	 .loc 1 279 0
 124 0086 FB68     	 ldr r3,[r7,#12]
 125 0088 1033     	 adds r3,r3,#16
 126 008a 1846     	 mov r0,r3
 127 008c FFF7FEFF 	 bl xTaskRemoveFromEventList
 128 0090 0346     	 mov r3,r0
 129 0092 002B     	 cmp r3,#0
 130 0094 12D0     	 beq .L5
 280:../Dave/Generated/FREERTOS/queue.c **** 				{
 281:../Dave/Generated/FREERTOS/queue.c **** 					queueYIELD_IF_USING_PREEMPTION();
 131              	 .loc 1 281 0
 132 0096 0D4B     	 ldr r3,.L7
 133 0098 4FF08052 	 mov r2,#268435456
 134 009c 1A60     	 str r2,[r3]
 135              	
 136 009e BFF34F8F 	 dsb
 137              	
 138              	
 139 00a2 BFF36F8F 	 isb
 140              	
 141              	 .thumb
 142 00a6 09E0     	 b .L5
 143              	.L4:
 282:../Dave/Generated/FREERTOS/queue.c **** 				}
 283:../Dave/Generated/FREERTOS/queue.c **** 				else
 284:../Dave/Generated/FREERTOS/queue.c **** 				{
 285:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 286:../Dave/Generated/FREERTOS/queue.c **** 				}
 287:../Dave/Generated/FREERTOS/queue.c **** 			}
 288:../Dave/Generated/FREERTOS/queue.c **** 			else
 289:../Dave/Generated/FREERTOS/queue.c **** 			{
 290:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 291:../Dave/Generated/FREERTOS/queue.c **** 			}
 292:../Dave/Generated/FREERTOS/queue.c **** 		}
 293:../Dave/Generated/FREERTOS/queue.c **** 		else
 294:../Dave/Generated/FREERTOS/queue.c **** 		{
 295:../Dave/Generated/FREERTOS/queue.c **** 			/* Ensure the event queues start in the correct state. */
 296:../Dave/Generated/FREERTOS/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 144              	 .loc 1 296 0
 145 00a8 FB68     	 ldr r3,[r7,#12]
 146 00aa 1033     	 adds r3,r3,#16
 147 00ac 1846     	 mov r0,r3
 148 00ae FFF7FEFF 	 bl vListInitialise
 297:../Dave/Generated/FREERTOS/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 149              	 .loc 1 297 0
 150 00b2 FB68     	 ldr r3,[r7,#12]
 151 00b4 2433     	 adds r3,r3,#36
 152 00b6 1846     	 mov r0,r3
 153 00b8 FFF7FEFF 	 bl vListInitialise
 154              	.L5:
 298:../Dave/Generated/FREERTOS/queue.c **** 		}
 299:../Dave/Generated/FREERTOS/queue.c **** 	}
 300:../Dave/Generated/FREERTOS/queue.c **** 	taskEXIT_CRITICAL();
 155              	 .loc 1 300 0
 156 00bc FFF7FEFF 	 bl vPortExitCritical
 301:../Dave/Generated/FREERTOS/queue.c **** 
 302:../Dave/Generated/FREERTOS/queue.c **** 	/* A value is returned for calling semantic consistency with previous
 303:../Dave/Generated/FREERTOS/queue.c **** 	versions. */
 304:../Dave/Generated/FREERTOS/queue.c **** 	return pdPASS;
 157              	 .loc 1 304 0
 158 00c0 0123     	 movs r3,#1
 305:../Dave/Generated/FREERTOS/queue.c **** }
 159              	 .loc 1 305 0
 160 00c2 1846     	 mov r0,r3
 161 00c4 1037     	 adds r7,r7,#16
 162              	.LCFI3:
 163              	 .cfi_def_cfa_offset 8
 164 00c6 BD46     	 mov sp,r7
 165              	.LCFI4:
 166              	 .cfi_def_cfa_register 13
 167              	 
 168 00c8 80BD     	 pop {r7,pc}
 169              	.L8:
 170 00ca 00BF     	 .align 2
 171              	.L7:
 172 00cc 04ED00E0 	 .word -536810236
 173              	 .cfi_endproc
 174              	.LFE137:
 176              	 .section .text.xQueueGenericCreate,"ax",%progbits
 177              	 .align 2
 178              	 .global xQueueGenericCreate
 179              	 .thumb
 180              	 .thumb_func
 182              	xQueueGenericCreate:
 183              	.LFB138:
 306:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 307:../Dave/Generated/FREERTOS/queue.c **** 
 308:../Dave/Generated/FREERTOS/queue.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 309:../Dave/Generated/FREERTOS/queue.c **** 
 310:../Dave/Generated/FREERTOS/queue.c **** 	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItem
 311:../Dave/Generated/FREERTOS/queue.c **** 	{
 312:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t *pxNewQueue;
 313:../Dave/Generated/FREERTOS/queue.c **** 
 314:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 315:../Dave/Generated/FREERTOS/queue.c **** 
 316:../Dave/Generated/FREERTOS/queue.c **** 		/* The StaticQueue_t structure and the queue storage area must be
 317:../Dave/Generated/FREERTOS/queue.c **** 		supplied. */
 318:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( pxStaticQueue != NULL );
 319:../Dave/Generated/FREERTOS/queue.c **** 
 320:../Dave/Generated/FREERTOS/queue.c **** 		/* A queue storage area should be provided if the item size is not 0, and
 321:../Dave/Generated/FREERTOS/queue.c **** 		should not be provided if the item size is 0. */
 322:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
 323:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 324:../Dave/Generated/FREERTOS/queue.c **** 
 325:../Dave/Generated/FREERTOS/queue.c **** 		#if( configASSERT_DEFINED == 1 )
 326:../Dave/Generated/FREERTOS/queue.c **** 		{
 327:../Dave/Generated/FREERTOS/queue.c **** 			/* Sanity check that the size of the structure used to declare a
 328:../Dave/Generated/FREERTOS/queue.c **** 			variable of type StaticQueue_t or StaticSemaphore_t equals the size of
 329:../Dave/Generated/FREERTOS/queue.c **** 			the real queue and semaphore structures. */
 330:../Dave/Generated/FREERTOS/queue.c **** 			volatile size_t xSize = sizeof( StaticQueue_t );
 331:../Dave/Generated/FREERTOS/queue.c **** 			configASSERT( xSize == sizeof( Queue_t ) );
 332:../Dave/Generated/FREERTOS/queue.c **** 			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
 333:../Dave/Generated/FREERTOS/queue.c **** 		}
 334:../Dave/Generated/FREERTOS/queue.c **** 		#endif /* configASSERT_DEFINED */
 335:../Dave/Generated/FREERTOS/queue.c **** 
 336:../Dave/Generated/FREERTOS/queue.c **** 		/* The address of a statically allocated queue was passed in, use it.
 337:../Dave/Generated/FREERTOS/queue.c **** 		The address of a statically allocated storage area was also passed in
 338:../Dave/Generated/FREERTOS/queue.c **** 		but is already set. */
 339:../Dave/Generated/FREERTOS/queue.c **** 		pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the structure
 340:../Dave/Generated/FREERTOS/queue.c **** 
 341:../Dave/Generated/FREERTOS/queue.c **** 		if( pxNewQueue != NULL )
 342:../Dave/Generated/FREERTOS/queue.c **** 		{
 343:../Dave/Generated/FREERTOS/queue.c **** 			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 344:../Dave/Generated/FREERTOS/queue.c **** 			{
 345:../Dave/Generated/FREERTOS/queue.c **** 				/* Queues can be allocated wither statically or dynamically, so
 346:../Dave/Generated/FREERTOS/queue.c **** 				note this queue was allocated statically in case the queue is
 347:../Dave/Generated/FREERTOS/queue.c **** 				later deleted. */
 348:../Dave/Generated/FREERTOS/queue.c **** 				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 349:../Dave/Generated/FREERTOS/queue.c **** 			}
 350:../Dave/Generated/FREERTOS/queue.c **** 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 351:../Dave/Generated/FREERTOS/queue.c **** 
 352:../Dave/Generated/FREERTOS/queue.c **** 			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 353:../Dave/Generated/FREERTOS/queue.c **** 		}
 354:../Dave/Generated/FREERTOS/queue.c **** 		else
 355:../Dave/Generated/FREERTOS/queue.c **** 		{
 356:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_CREATE_FAILED( ucQueueType );
 357:../Dave/Generated/FREERTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
 358:../Dave/Generated/FREERTOS/queue.c **** 		}
 359:../Dave/Generated/FREERTOS/queue.c **** 
 360:../Dave/Generated/FREERTOS/queue.c **** 		return pxNewQueue;
 361:../Dave/Generated/FREERTOS/queue.c **** 	}
 362:../Dave/Generated/FREERTOS/queue.c **** 
 363:../Dave/Generated/FREERTOS/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 364:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 365:../Dave/Generated/FREERTOS/queue.c **** 
 366:../Dave/Generated/FREERTOS/queue.c **** #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 367:../Dave/Generated/FREERTOS/queue.c **** 
 368:../Dave/Generated/FREERTOS/queue.c **** 	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, 
 369:../Dave/Generated/FREERTOS/queue.c **** 	{
 184              	 .loc 1 369 0
 185              	 .cfi_startproc
 186              	 
 187              	 
 188 0000 90B5     	 push {r4,r7,lr}
 189              	.LCFI5:
 190              	 .cfi_def_cfa_offset 12
 191              	 .cfi_offset 4,-12
 192              	 .cfi_offset 7,-8
 193              	 .cfi_offset 14,-4
 194 0002 8BB0     	 sub sp,sp,#44
 195              	.LCFI6:
 196              	 .cfi_def_cfa_offset 56
 197 0004 02AF     	 add r7,sp,#8
 198              	.LCFI7:
 199              	 .cfi_def_cfa 7,48
 200 0006 F860     	 str r0,[r7,#12]
 201 0008 B960     	 str r1,[r7,#8]
 202 000a 1346     	 mov r3,r2
 203 000c FB71     	 strb r3,[r7,#7]
 370:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t *pxNewQueue;
 371:../Dave/Generated/FREERTOS/queue.c **** 	size_t xQueueSizeInBytes;
 372:../Dave/Generated/FREERTOS/queue.c **** 	uint8_t *pucQueueStorage;
 373:../Dave/Generated/FREERTOS/queue.c **** 
 374:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 204              	 .loc 1 374 0
 205 000e FB68     	 ldr r3,[r7,#12]
 206 0010 002B     	 cmp r3,#0
 207 0012 09D1     	 bne .L10
 208              	.LBB111:
 209              	.LBB112:
 210              	 .loc 2 195 0 discriminator 1
 211              	
 212 0014 4FF0FC03 	 mov r3,#252
 213 0018 83F31188 	 msr basepri,r3
 214 001c BFF36F8F 	 isb 
 215 0020 BFF34F8F 	 dsb 
 216              	
 217              	
 218              	 .thumb
 219 0024 3B61     	 str r3,[r7,#16]
 220              	.L11:
 221              	.LBE112:
 222              	.LBE111:
 223              	 .loc 1 374 0 discriminator 1
 224 0026 FEE7     	 b .L11
 225              	.L10:
 375:../Dave/Generated/FREERTOS/queue.c **** 
 376:../Dave/Generated/FREERTOS/queue.c **** 		if( uxItemSize == ( UBaseType_t ) 0 )
 226              	 .loc 1 376 0
 227 0028 BB68     	 ldr r3,[r7,#8]
 228 002a 002B     	 cmp r3,#0
 229 002c 02D1     	 bne .L12
 377:../Dave/Generated/FREERTOS/queue.c **** 		{
 378:../Dave/Generated/FREERTOS/queue.c **** 			/* There is not going to be a queue storage area. */
 379:../Dave/Generated/FREERTOS/queue.c **** 			xQueueSizeInBytes = ( size_t ) 0;
 230              	 .loc 1 379 0
 231 002e 0023     	 movs r3,#0
 232 0030 FB61     	 str r3,[r7,#28]
 233 0032 04E0     	 b .L13
 234              	.L12:
 380:../Dave/Generated/FREERTOS/queue.c **** 		}
 381:../Dave/Generated/FREERTOS/queue.c **** 		else
 382:../Dave/Generated/FREERTOS/queue.c **** 		{
 383:../Dave/Generated/FREERTOS/queue.c **** 			/* Allocate enough space to hold the maximum number of items that
 384:../Dave/Generated/FREERTOS/queue.c **** 			can be in the queue at any time. */
 385:../Dave/Generated/FREERTOS/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as t
 235              	 .loc 1 385 0
 236 0034 FB68     	 ldr r3,[r7,#12]
 237 0036 BA68     	 ldr r2,[r7,#8]
 238 0038 02FB03F3 	 mul r3,r2,r3
 239 003c FB61     	 str r3,[r7,#28]
 240              	.L13:
 386:../Dave/Generated/FREERTOS/queue.c **** 		}
 387:../Dave/Generated/FREERTOS/queue.c **** 
 388:../Dave/Generated/FREERTOS/queue.c **** 		/* Allocate the queue and storage area.  Justification for MISRA
 389:../Dave/Generated/FREERTOS/queue.c **** 		deviation as follows:  pvPortMalloc() always ensures returned memory
 390:../Dave/Generated/FREERTOS/queue.c **** 		blocks are aligned per the requirements of the MCU stack.  In this case
 391:../Dave/Generated/FREERTOS/queue.c **** 		pvPortMalloc() must return a pointer that is guaranteed to meet the
 392:../Dave/Generated/FREERTOS/queue.c **** 		alignment requirements of the Queue_t structure - which in this case
 393:../Dave/Generated/FREERTOS/queue.c **** 		is an int8_t *.  Therefore, whenever the stack alignment requirements
 394:../Dave/Generated/FREERTOS/queue.c **** 		are greater than or equal to the pointer to char requirements the cast
 395:../Dave/Generated/FREERTOS/queue.c **** 		is safe.  In other cases alignment requirements are not strict (one or
 396:../Dave/Generated/FREERTOS/queue.c **** 		two bytes). */
 397:../Dave/Generated/FREERTOS/queue.c **** 		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !
 241              	 .loc 1 397 0
 242 003e FB69     	 ldr r3,[r7,#28]
 243 0040 5433     	 adds r3,r3,#84
 244 0042 1846     	 mov r0,r3
 245 0044 FFF7FEFF 	 bl pvPortMalloc
 246 0048 B861     	 str r0,[r7,#24]
 398:../Dave/Generated/FREERTOS/queue.c **** 
 399:../Dave/Generated/FREERTOS/queue.c **** 		if( pxNewQueue != NULL )
 247              	 .loc 1 399 0
 248 004a BB69     	 ldr r3,[r7,#24]
 249 004c 002B     	 cmp r3,#0
 250 004e 0DD0     	 beq .L14
 400:../Dave/Generated/FREERTOS/queue.c **** 		{
 401:../Dave/Generated/FREERTOS/queue.c **** 			/* Jump past the queue structure to find the location of the queue
 402:../Dave/Generated/FREERTOS/queue.c **** 			storage area. */
 403:../Dave/Generated/FREERTOS/queue.c **** 			pucQueueStorage = ( uint8_t * ) pxNewQueue;
 251              	 .loc 1 403 0
 252 0050 BB69     	 ldr r3,[r7,#24]
 253 0052 7B61     	 str r3,[r7,#20]
 404:../Dave/Generated/FREERTOS/queue.c **** 			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, es
 254              	 .loc 1 404 0
 255 0054 7B69     	 ldr r3,[r7,#20]
 256 0056 5433     	 adds r3,r3,#84
 257 0058 7B61     	 str r3,[r7,#20]
 405:../Dave/Generated/FREERTOS/queue.c **** 
 406:../Dave/Generated/FREERTOS/queue.c **** 			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
 407:../Dave/Generated/FREERTOS/queue.c **** 			{
 408:../Dave/Generated/FREERTOS/queue.c **** 				/* Queues can be created either statically or dynamically, so
 409:../Dave/Generated/FREERTOS/queue.c **** 				note this task was created dynamically in case it is later
 410:../Dave/Generated/FREERTOS/queue.c **** 				deleted. */
 411:../Dave/Generated/FREERTOS/queue.c **** 				pxNewQueue->ucStaticallyAllocated = pdFALSE;
 412:../Dave/Generated/FREERTOS/queue.c **** 			}
 413:../Dave/Generated/FREERTOS/queue.c **** 			#endif /* configSUPPORT_STATIC_ALLOCATION */
 414:../Dave/Generated/FREERTOS/queue.c **** 
 415:../Dave/Generated/FREERTOS/queue.c **** 			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 258              	 .loc 1 415 0
 259 005a FC79     	 ldrb r4,[r7,#7]
 260 005c BB69     	 ldr r3,[r7,#24]
 261 005e 0093     	 str r3,[sp]
 262 0060 F868     	 ldr r0,[r7,#12]
 263 0062 B968     	 ldr r1,[r7,#8]
 264 0064 7A69     	 ldr r2,[r7,#20]
 265 0066 2346     	 mov r3,r4
 266 0068 FFF7FEFF 	 bl prvInitialiseNewQueue
 267              	.L14:
 416:../Dave/Generated/FREERTOS/queue.c **** 		}
 417:../Dave/Generated/FREERTOS/queue.c **** 		else
 418:../Dave/Generated/FREERTOS/queue.c **** 		{
 419:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_CREATE_FAILED( ucQueueType );
 420:../Dave/Generated/FREERTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
 421:../Dave/Generated/FREERTOS/queue.c **** 		}
 422:../Dave/Generated/FREERTOS/queue.c **** 
 423:../Dave/Generated/FREERTOS/queue.c **** 		return pxNewQueue;
 268              	 .loc 1 423 0
 269 006c BB69     	 ldr r3,[r7,#24]
 424:../Dave/Generated/FREERTOS/queue.c **** 	}
 270              	 .loc 1 424 0
 271 006e 1846     	 mov r0,r3
 272 0070 2437     	 adds r7,r7,#36
 273              	.LCFI8:
 274              	 .cfi_def_cfa_offset 12
 275 0072 BD46     	 mov sp,r7
 276              	.LCFI9:
 277              	 .cfi_def_cfa_register 13
 278              	 
 279 0074 90BD     	 pop {r4,r7,pc}
 280              	 .cfi_endproc
 281              	.LFE138:
 283 0076 00BF     	 .section .text.prvInitialiseNewQueue,"ax",%progbits
 284              	 .align 2
 285              	 .thumb
 286              	 .thumb_func
 288              	prvInitialiseNewQueue:
 289              	.LFB139:
 425:../Dave/Generated/FREERTOS/queue.c **** 
 426:../Dave/Generated/FREERTOS/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 427:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 428:../Dave/Generated/FREERTOS/queue.c **** 
 429:../Dave/Generated/FREERTOS/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, u
 430:../Dave/Generated/FREERTOS/queue.c **** {
 290              	 .loc 1 430 0
 291              	 .cfi_startproc
 292              	 
 293              	 
 294 0000 80B5     	 push {r7,lr}
 295              	.LCFI10:
 296              	 .cfi_def_cfa_offset 8
 297              	 .cfi_offset 7,-8
 298              	 .cfi_offset 14,-4
 299 0002 84B0     	 sub sp,sp,#16
 300              	.LCFI11:
 301              	 .cfi_def_cfa_offset 24
 302 0004 00AF     	 add r7,sp,#0
 303              	.LCFI12:
 304              	 .cfi_def_cfa_register 7
 305 0006 F860     	 str r0,[r7,#12]
 306 0008 B960     	 str r1,[r7,#8]
 307 000a 7A60     	 str r2,[r7,#4]
 308 000c FB70     	 strb r3,[r7,#3]
 431:../Dave/Generated/FREERTOS/queue.c **** 	/* Remove compiler warnings about unused parameters should
 432:../Dave/Generated/FREERTOS/queue.c **** 	configUSE_TRACE_FACILITY not be set to 1. */
 433:../Dave/Generated/FREERTOS/queue.c **** 	( void ) ucQueueType;
 434:../Dave/Generated/FREERTOS/queue.c **** 
 435:../Dave/Generated/FREERTOS/queue.c **** 	if( uxItemSize == ( UBaseType_t ) 0 )
 309              	 .loc 1 435 0
 310 000e BB68     	 ldr r3,[r7,#8]
 311 0010 002B     	 cmp r3,#0
 312 0012 03D1     	 bne .L17
 436:../Dave/Generated/FREERTOS/queue.c **** 	{
 437:../Dave/Generated/FREERTOS/queue.c **** 		/* No RAM was allocated for the queue storage area, but PC head cannot
 438:../Dave/Generated/FREERTOS/queue.c **** 		be set to NULL because NULL is used as a key to say the queue is used as
 439:../Dave/Generated/FREERTOS/queue.c **** 		a mutex.  Therefore just set pcHead to point to the queue as a benign
 440:../Dave/Generated/FREERTOS/queue.c **** 		value that is known to be within the memory map. */
 441:../Dave/Generated/FREERTOS/queue.c **** 		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 313              	 .loc 1 441 0
 314 0014 BB69     	 ldr r3,[r7,#24]
 315 0016 BA69     	 ldr r2,[r7,#24]
 316 0018 1A60     	 str r2,[r3]
 317 001a 02E0     	 b .L18
 318              	.L17:
 442:../Dave/Generated/FREERTOS/queue.c **** 	}
 443:../Dave/Generated/FREERTOS/queue.c **** 	else
 444:../Dave/Generated/FREERTOS/queue.c **** 	{
 445:../Dave/Generated/FREERTOS/queue.c **** 		/* Set the head to the start of the queue storage area. */
 446:../Dave/Generated/FREERTOS/queue.c **** 		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 319              	 .loc 1 446 0
 320 001c BB69     	 ldr r3,[r7,#24]
 321 001e 7A68     	 ldr r2,[r7,#4]
 322 0020 1A60     	 str r2,[r3]
 323              	.L18:
 447:../Dave/Generated/FREERTOS/queue.c **** 	}
 448:../Dave/Generated/FREERTOS/queue.c **** 
 449:../Dave/Generated/FREERTOS/queue.c **** 	/* Initialise the queue members as described where the queue type is
 450:../Dave/Generated/FREERTOS/queue.c **** 	defined. */
 451:../Dave/Generated/FREERTOS/queue.c **** 	pxNewQueue->uxLength = uxQueueLength;
 324              	 .loc 1 451 0
 325 0022 BB69     	 ldr r3,[r7,#24]
 326 0024 FA68     	 ldr r2,[r7,#12]
 327 0026 DA63     	 str r2,[r3,#60]
 452:../Dave/Generated/FREERTOS/queue.c **** 	pxNewQueue->uxItemSize = uxItemSize;
 328              	 .loc 1 452 0
 329 0028 BB69     	 ldr r3,[r7,#24]
 330 002a BA68     	 ldr r2,[r7,#8]
 331 002c 1A64     	 str r2,[r3,#64]
 453:../Dave/Generated/FREERTOS/queue.c **** 	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 332              	 .loc 1 453 0
 333 002e B869     	 ldr r0,[r7,#24]
 334 0030 0121     	 movs r1,#1
 335 0032 FFF7FEFF 	 bl xQueueGenericReset
 454:../Dave/Generated/FREERTOS/queue.c **** 
 455:../Dave/Generated/FREERTOS/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 456:../Dave/Generated/FREERTOS/queue.c **** 	{
 457:../Dave/Generated/FREERTOS/queue.c **** 		pxNewQueue->ucQueueType = ucQueueType;
 336              	 .loc 1 457 0
 337 0036 BB69     	 ldr r3,[r7,#24]
 338 0038 FA78     	 ldrb r2,[r7,#3]
 339 003a 83F85020 	 strb r2,[r3,#80]
 458:../Dave/Generated/FREERTOS/queue.c **** 	}
 459:../Dave/Generated/FREERTOS/queue.c **** 	#endif /* configUSE_TRACE_FACILITY */
 460:../Dave/Generated/FREERTOS/queue.c **** 
 461:../Dave/Generated/FREERTOS/queue.c **** 	#if( configUSE_QUEUE_SETS == 1 )
 462:../Dave/Generated/FREERTOS/queue.c **** 	{
 463:../Dave/Generated/FREERTOS/queue.c **** 		pxNewQueue->pxQueueSetContainer = NULL;
 340              	 .loc 1 463 0
 341 003e BB69     	 ldr r3,[r7,#24]
 342 0040 0022     	 movs r2,#0
 343 0042 9A64     	 str r2,[r3,#72]
 464:../Dave/Generated/FREERTOS/queue.c **** 	}
 465:../Dave/Generated/FREERTOS/queue.c **** 	#endif /* configUSE_QUEUE_SETS */
 466:../Dave/Generated/FREERTOS/queue.c **** 
 467:../Dave/Generated/FREERTOS/queue.c **** 	traceQUEUE_CREATE( pxNewQueue );
 468:../Dave/Generated/FREERTOS/queue.c **** }
 344              	 .loc 1 468 0
 345 0044 1037     	 adds r7,r7,#16
 346              	.LCFI13:
 347              	 .cfi_def_cfa_offset 8
 348 0046 BD46     	 mov sp,r7
 349              	.LCFI14:
 350              	 .cfi_def_cfa_register 13
 351              	 
 352 0048 80BD     	 pop {r7,pc}
 353              	 .cfi_endproc
 354              	.LFE139:
 356 004a 00BF     	 .section .text.prvInitialiseMutex,"ax",%progbits
 357              	 .align 2
 358              	 .thumb
 359              	 .thumb_func
 361              	prvInitialiseMutex:
 362              	.LFB140:
 469:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 470:../Dave/Generated/FREERTOS/queue.c **** 
 471:../Dave/Generated/FREERTOS/queue.c **** #if( configUSE_MUTEXES == 1 )
 472:../Dave/Generated/FREERTOS/queue.c **** 
 473:../Dave/Generated/FREERTOS/queue.c **** 	static void prvInitialiseMutex( Queue_t *pxNewQueue )
 474:../Dave/Generated/FREERTOS/queue.c **** 	{
 363              	 .loc 1 474 0
 364              	 .cfi_startproc
 365              	 
 366              	 
 367 0000 80B5     	 push {r7,lr}
 368              	.LCFI15:
 369              	 .cfi_def_cfa_offset 8
 370              	 .cfi_offset 7,-8
 371              	 .cfi_offset 14,-4
 372 0002 82B0     	 sub sp,sp,#8
 373              	.LCFI16:
 374              	 .cfi_def_cfa_offset 16
 375 0004 00AF     	 add r7,sp,#0
 376              	.LCFI17:
 377              	 .cfi_def_cfa_register 7
 378 0006 7860     	 str r0,[r7,#4]
 475:../Dave/Generated/FREERTOS/queue.c **** 		if( pxNewQueue != NULL )
 379              	 .loc 1 475 0
 380 0008 7B68     	 ldr r3,[r7,#4]
 381 000a 002B     	 cmp r3,#0
 382 000c 0ED0     	 beq .L19
 476:../Dave/Generated/FREERTOS/queue.c **** 		{
 477:../Dave/Generated/FREERTOS/queue.c **** 			/* The queue create function will set all the queue structure members
 478:../Dave/Generated/FREERTOS/queue.c **** 			correctly for a generic queue, but this function is creating a
 479:../Dave/Generated/FREERTOS/queue.c **** 			mutex.  Overwrite those members that need to be set differently -
 480:../Dave/Generated/FREERTOS/queue.c **** 			in particular the information required for priority inheritance. */
 481:../Dave/Generated/FREERTOS/queue.c **** 			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 383              	 .loc 1 481 0
 384 000e 7B68     	 ldr r3,[r7,#4]
 385 0010 0022     	 movs r2,#0
 386 0012 9A60     	 str r2,[r3,#8]
 482:../Dave/Generated/FREERTOS/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 387              	 .loc 1 482 0
 388 0014 7B68     	 ldr r3,[r7,#4]
 389 0016 0022     	 movs r2,#0
 390 0018 1A60     	 str r2,[r3]
 483:../Dave/Generated/FREERTOS/queue.c **** 
 484:../Dave/Generated/FREERTOS/queue.c **** 			/* In case this is a recursive mutex. */
 485:../Dave/Generated/FREERTOS/queue.c **** 			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 391              	 .loc 1 485 0
 392 001a 7B68     	 ldr r3,[r7,#4]
 393 001c 0022     	 movs r2,#0
 394 001e DA60     	 str r2,[r3,#12]
 486:../Dave/Generated/FREERTOS/queue.c **** 
 487:../Dave/Generated/FREERTOS/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 488:../Dave/Generated/FREERTOS/queue.c **** 
 489:../Dave/Generated/FREERTOS/queue.c **** 			/* Start with the semaphore in the expected state. */
 490:../Dave/Generated/FREERTOS/queue.c **** 			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 395              	 .loc 1 490 0
 396 0020 7868     	 ldr r0,[r7,#4]
 397 0022 0021     	 movs r1,#0
 398 0024 0022     	 movs r2,#0
 399 0026 0023     	 movs r3,#0
 400 0028 FFF7FEFF 	 bl xQueueGenericSend
 401              	.L19:
 491:../Dave/Generated/FREERTOS/queue.c **** 		}
 492:../Dave/Generated/FREERTOS/queue.c **** 		else
 493:../Dave/Generated/FREERTOS/queue.c **** 		{
 494:../Dave/Generated/FREERTOS/queue.c **** 			traceCREATE_MUTEX_FAILED();
 495:../Dave/Generated/FREERTOS/queue.c **** 		}
 496:../Dave/Generated/FREERTOS/queue.c **** 	}
 402              	 .loc 1 496 0
 403 002c 0837     	 adds r7,r7,#8
 404              	.LCFI18:
 405              	 .cfi_def_cfa_offset 8
 406 002e BD46     	 mov sp,r7
 407              	.LCFI19:
 408              	 .cfi_def_cfa_register 13
 409              	 
 410 0030 80BD     	 pop {r7,pc}
 411              	 .cfi_endproc
 412              	.LFE140:
 414 0032 00BF     	 .section .text.xQueueCreateMutex,"ax",%progbits
 415              	 .align 2
 416              	 .global xQueueCreateMutex
 417              	 .thumb
 418              	 .thumb_func
 420              	xQueueCreateMutex:
 421              	.LFB141:
 497:../Dave/Generated/FREERTOS/queue.c **** 
 498:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_MUTEXES */
 499:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 500:../Dave/Generated/FREERTOS/queue.c **** 
 501:../Dave/Generated/FREERTOS/queue.c **** #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 502:../Dave/Generated/FREERTOS/queue.c **** 
 503:../Dave/Generated/FREERTOS/queue.c **** 	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
 504:../Dave/Generated/FREERTOS/queue.c **** 	{
 422              	 .loc 1 504 0
 423              	 .cfi_startproc
 424              	 
 425              	 
 426 0000 80B5     	 push {r7,lr}
 427              	.LCFI20:
 428              	 .cfi_def_cfa_offset 8
 429              	 .cfi_offset 7,-8
 430              	 .cfi_offset 14,-4
 431 0002 86B0     	 sub sp,sp,#24
 432              	.LCFI21:
 433              	 .cfi_def_cfa_offset 32
 434 0004 00AF     	 add r7,sp,#0
 435              	.LCFI22:
 436              	 .cfi_def_cfa_register 7
 437 0006 0346     	 mov r3,r0
 438 0008 FB71     	 strb r3,[r7,#7]
 505:../Dave/Generated/FREERTOS/queue.c **** 	QueueHandle_t xNewQueue;
 506:../Dave/Generated/FREERTOS/queue.c **** 	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 439              	 .loc 1 506 0
 440 000a 0123     	 movs r3,#1
 441 000c 7B61     	 str r3,[r7,#20]
 442 000e 0023     	 movs r3,#0
 443 0010 3B61     	 str r3,[r7,#16]
 507:../Dave/Generated/FREERTOS/queue.c **** 
 508:../Dave/Generated/FREERTOS/queue.c **** 		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 444              	 .loc 1 508 0
 445 0012 FB79     	 ldrb r3,[r7,#7]
 446 0014 7869     	 ldr r0,[r7,#20]
 447 0016 3969     	 ldr r1,[r7,#16]
 448 0018 1A46     	 mov r2,r3
 449 001a FFF7FEFF 	 bl xQueueGenericCreate
 450 001e F860     	 str r0,[r7,#12]
 509:../Dave/Generated/FREERTOS/queue.c **** 		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 451              	 .loc 1 509 0
 452 0020 F868     	 ldr r0,[r7,#12]
 453 0022 FFF7FEFF 	 bl prvInitialiseMutex
 510:../Dave/Generated/FREERTOS/queue.c **** 
 511:../Dave/Generated/FREERTOS/queue.c **** 		return xNewQueue;
 454              	 .loc 1 511 0
 455 0026 FB68     	 ldr r3,[r7,#12]
 512:../Dave/Generated/FREERTOS/queue.c **** 	}
 456              	 .loc 1 512 0
 457 0028 1846     	 mov r0,r3
 458 002a 1837     	 adds r7,r7,#24
 459              	.LCFI23:
 460              	 .cfi_def_cfa_offset 8
 461 002c BD46     	 mov sp,r7
 462              	.LCFI24:
 463              	 .cfi_def_cfa_register 13
 464              	 
 465 002e 80BD     	 pop {r7,pc}
 466              	 .cfi_endproc
 467              	.LFE141:
 469              	 .section .text.xQueueGetMutexHolder,"ax",%progbits
 470              	 .align 2
 471              	 .global xQueueGetMutexHolder
 472              	 .thumb
 473              	 .thumb_func
 475              	xQueueGetMutexHolder:
 476              	.LFB142:
 513:../Dave/Generated/FREERTOS/queue.c **** 
 514:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_MUTEXES */
 515:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 516:../Dave/Generated/FREERTOS/queue.c **** 
 517:../Dave/Generated/FREERTOS/queue.c **** #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 518:../Dave/Generated/FREERTOS/queue.c **** 
 519:../Dave/Generated/FREERTOS/queue.c **** 	QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue )
 520:../Dave/Generated/FREERTOS/queue.c **** 	{
 521:../Dave/Generated/FREERTOS/queue.c **** 	QueueHandle_t xNewQueue;
 522:../Dave/Generated/FREERTOS/queue.c **** 	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 523:../Dave/Generated/FREERTOS/queue.c **** 
 524:../Dave/Generated/FREERTOS/queue.c **** 		/* Prevent compiler warnings about unused parameters if
 525:../Dave/Generated/FREERTOS/queue.c **** 		configUSE_TRACE_FACILITY does not equal 1. */
 526:../Dave/Generated/FREERTOS/queue.c **** 		( void ) ucQueueType;
 527:../Dave/Generated/FREERTOS/queue.c **** 
 528:../Dave/Generated/FREERTOS/queue.c **** 		xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueTy
 529:../Dave/Generated/FREERTOS/queue.c **** 		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 530:../Dave/Generated/FREERTOS/queue.c **** 
 531:../Dave/Generated/FREERTOS/queue.c **** 		return xNewQueue;
 532:../Dave/Generated/FREERTOS/queue.c **** 	}
 533:../Dave/Generated/FREERTOS/queue.c **** 
 534:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_MUTEXES */
 535:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 536:../Dave/Generated/FREERTOS/queue.c **** 
 537:../Dave/Generated/FREERTOS/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 538:../Dave/Generated/FREERTOS/queue.c **** 
 539:../Dave/Generated/FREERTOS/queue.c **** 	TaskHandle_t xQueueGetMutexHolder( QueueHandle_t xSemaphore )
 540:../Dave/Generated/FREERTOS/queue.c **** 	{
 477              	 .loc 1 540 0
 478              	 .cfi_startproc
 479              	 
 480              	 
 481 0000 80B5     	 push {r7,lr}
 482              	.LCFI25:
 483              	 .cfi_def_cfa_offset 8
 484              	 .cfi_offset 7,-8
 485              	 .cfi_offset 14,-4
 486 0002 84B0     	 sub sp,sp,#16
 487              	.LCFI26:
 488              	 .cfi_def_cfa_offset 24
 489 0004 00AF     	 add r7,sp,#0
 490              	.LCFI27:
 491              	 .cfi_def_cfa_register 7
 492 0006 7860     	 str r0,[r7,#4]
 541:../Dave/Generated/FREERTOS/queue.c **** 	TaskHandle_t pxReturn;
 542:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t * const pxSemaphore = ( Queue_t * ) xSemaphore;
 493              	 .loc 1 542 0
 494 0008 7B68     	 ldr r3,[r7,#4]
 495 000a BB60     	 str r3,[r7,#8]
 543:../Dave/Generated/FREERTOS/queue.c **** 
 544:../Dave/Generated/FREERTOS/queue.c **** 		/* This function is called by xSemaphoreGetMutexHolder(), and should not
 545:../Dave/Generated/FREERTOS/queue.c **** 		be called directly.  Note:  This is a good way of determining if the
 546:../Dave/Generated/FREERTOS/queue.c **** 		calling task is the mutex holder, but not a good way of determining the
 547:../Dave/Generated/FREERTOS/queue.c **** 		identity of the mutex holder, as the holder may change between the
 548:../Dave/Generated/FREERTOS/queue.c **** 		following critical section exiting and the function returning. */
 549:../Dave/Generated/FREERTOS/queue.c **** 		taskENTER_CRITICAL();
 496              	 .loc 1 549 0
 497 000c FFF7FEFF 	 bl vPortEnterCritical
 550:../Dave/Generated/FREERTOS/queue.c **** 		{
 551:../Dave/Generated/FREERTOS/queue.c **** 			if( pxSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
 498              	 .loc 1 551 0
 499 0010 BB68     	 ldr r3,[r7,#8]
 500 0012 1B68     	 ldr r3,[r3]
 501 0014 002B     	 cmp r3,#0
 502 0016 03D1     	 bne .L24
 552:../Dave/Generated/FREERTOS/queue.c **** 			{
 553:../Dave/Generated/FREERTOS/queue.c **** 				pxReturn = pxSemaphore->u.xSemaphore.xMutexHolder;
 503              	 .loc 1 553 0
 504 0018 BB68     	 ldr r3,[r7,#8]
 505 001a 9B68     	 ldr r3,[r3,#8]
 506 001c FB60     	 str r3,[r7,#12]
 507 001e 01E0     	 b .L25
 508              	.L24:
 554:../Dave/Generated/FREERTOS/queue.c **** 			}
 555:../Dave/Generated/FREERTOS/queue.c **** 			else
 556:../Dave/Generated/FREERTOS/queue.c **** 			{
 557:../Dave/Generated/FREERTOS/queue.c **** 				pxReturn = NULL;
 509              	 .loc 1 557 0
 510 0020 0023     	 movs r3,#0
 511 0022 FB60     	 str r3,[r7,#12]
 512              	.L25:
 558:../Dave/Generated/FREERTOS/queue.c **** 			}
 559:../Dave/Generated/FREERTOS/queue.c **** 		}
 560:../Dave/Generated/FREERTOS/queue.c **** 		taskEXIT_CRITICAL();
 513              	 .loc 1 560 0
 514 0024 FFF7FEFF 	 bl vPortExitCritical
 561:../Dave/Generated/FREERTOS/queue.c **** 
 562:../Dave/Generated/FREERTOS/queue.c **** 		return pxReturn;
 515              	 .loc 1 562 0
 516 0028 FB68     	 ldr r3,[r7,#12]
 563:../Dave/Generated/FREERTOS/queue.c **** 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 517              	 .loc 1 563 0
 518 002a 1846     	 mov r0,r3
 519 002c 1037     	 adds r7,r7,#16
 520              	.LCFI28:
 521              	 .cfi_def_cfa_offset 8
 522 002e BD46     	 mov sp,r7
 523              	.LCFI29:
 524              	 .cfi_def_cfa_register 13
 525              	 
 526 0030 80BD     	 pop {r7,pc}
 527              	 .cfi_endproc
 528              	.LFE142:
 530 0032 00BF     	 .section .text.xQueueGetMutexHolderFromISR,"ax",%progbits
 531              	 .align 2
 532              	 .global xQueueGetMutexHolderFromISR
 533              	 .thumb
 534              	 .thumb_func
 536              	xQueueGetMutexHolderFromISR:
 537              	.LFB143:
 564:../Dave/Generated/FREERTOS/queue.c **** 
 565:../Dave/Generated/FREERTOS/queue.c **** #endif
 566:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 567:../Dave/Generated/FREERTOS/queue.c **** 
 568:../Dave/Generated/FREERTOS/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 569:../Dave/Generated/FREERTOS/queue.c **** 
 570:../Dave/Generated/FREERTOS/queue.c **** 	TaskHandle_t xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore )
 571:../Dave/Generated/FREERTOS/queue.c **** 	{
 538              	 .loc 1 571 0
 539              	 .cfi_startproc
 540              	 
 541              	 
 542              	 
 543 0000 80B4     	 push {r7}
 544              	.LCFI30:
 545              	 .cfi_def_cfa_offset 4
 546              	 .cfi_offset 7,-4
 547 0002 85B0     	 sub sp,sp,#20
 548              	.LCFI31:
 549              	 .cfi_def_cfa_offset 24
 550 0004 00AF     	 add r7,sp,#0
 551              	.LCFI32:
 552              	 .cfi_def_cfa_register 7
 553 0006 7860     	 str r0,[r7,#4]
 572:../Dave/Generated/FREERTOS/queue.c **** 	TaskHandle_t pxReturn;
 573:../Dave/Generated/FREERTOS/queue.c **** 
 574:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( xSemaphore );
 554              	 .loc 1 574 0
 555 0008 7B68     	 ldr r3,[r7,#4]
 556 000a 002B     	 cmp r3,#0
 557 000c 09D1     	 bne .L28
 558              	.LBB113:
 559              	.LBB114:
 560              	 .loc 2 195 0 discriminator 1
 561              	
 562 000e 4FF0FC03 	 mov r3,#252
 563 0012 83F31188 	 msr basepri,r3
 564 0016 BFF36F8F 	 isb 
 565 001a BFF34F8F 	 dsb 
 566              	
 567              	
 568              	 .thumb
 569 001e BB60     	 str r3,[r7,#8]
 570              	.L29:
 571              	.LBE114:
 572              	.LBE113:
 573              	 .loc 1 574 0 discriminator 1
 574 0020 FEE7     	 b .L29
 575              	.L28:
 575:../Dave/Generated/FREERTOS/queue.c **** 
 576:../Dave/Generated/FREERTOS/queue.c **** 		/* Mutexes cannot be used in interrupt service routines, so the mutex
 577:../Dave/Generated/FREERTOS/queue.c **** 		holder should not change in an ISR, and therefore a critical section is
 578:../Dave/Generated/FREERTOS/queue.c **** 		not required here. */
 579:../Dave/Generated/FREERTOS/queue.c **** 		if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 576              	 .loc 1 579 0
 577 0022 7B68     	 ldr r3,[r7,#4]
 578 0024 1B68     	 ldr r3,[r3]
 579 0026 002B     	 cmp r3,#0
 580 0028 03D1     	 bne .L30
 580:../Dave/Generated/FREERTOS/queue.c **** 		{
 581:../Dave/Generated/FREERTOS/queue.c **** 			pxReturn = ( ( Queue_t * ) xSemaphore )->u.xSemaphore.xMutexHolder;
 581              	 .loc 1 581 0
 582 002a 7B68     	 ldr r3,[r7,#4]
 583 002c 9B68     	 ldr r3,[r3,#8]
 584 002e FB60     	 str r3,[r7,#12]
 585 0030 01E0     	 b .L31
 586              	.L30:
 582:../Dave/Generated/FREERTOS/queue.c **** 		}
 583:../Dave/Generated/FREERTOS/queue.c **** 		else
 584:../Dave/Generated/FREERTOS/queue.c **** 		{
 585:../Dave/Generated/FREERTOS/queue.c **** 			pxReturn = NULL;
 587              	 .loc 1 585 0
 588 0032 0023     	 movs r3,#0
 589 0034 FB60     	 str r3,[r7,#12]
 590              	.L31:
 586:../Dave/Generated/FREERTOS/queue.c **** 		}
 587:../Dave/Generated/FREERTOS/queue.c **** 
 588:../Dave/Generated/FREERTOS/queue.c **** 		return pxReturn;
 591              	 .loc 1 588 0
 592 0036 FB68     	 ldr r3,[r7,#12]
 589:../Dave/Generated/FREERTOS/queue.c **** 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 593              	 .loc 1 589 0
 594 0038 1846     	 mov r0,r3
 595 003a 1437     	 adds r7,r7,#20
 596              	.LCFI33:
 597              	 .cfi_def_cfa_offset 4
 598 003c BD46     	 mov sp,r7
 599              	.LCFI34:
 600              	 .cfi_def_cfa_register 13
 601              	 
 602 003e 5DF8047B 	 ldr r7,[sp],#4
 603              	.LCFI35:
 604              	 .cfi_restore 7
 605              	 .cfi_def_cfa_offset 0
 606 0042 7047     	 bx lr
 607              	 .cfi_endproc
 608              	.LFE143:
 610              	 .section .text.xQueueGiveMutexRecursive,"ax",%progbits
 611              	 .align 2
 612              	 .global xQueueGiveMutexRecursive
 613              	 .thumb
 614              	 .thumb_func
 616              	xQueueGiveMutexRecursive:
 617              	.LFB144:
 590:../Dave/Generated/FREERTOS/queue.c **** 
 591:../Dave/Generated/FREERTOS/queue.c **** #endif
 592:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 593:../Dave/Generated/FREERTOS/queue.c **** 
 594:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 595:../Dave/Generated/FREERTOS/queue.c **** 
 596:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
 597:../Dave/Generated/FREERTOS/queue.c **** 	{
 618              	 .loc 1 597 0
 619              	 .cfi_startproc
 620              	 
 621              	 
 622 0000 90B5     	 push {r4,r7,lr}
 623              	.LCFI36:
 624              	 .cfi_def_cfa_offset 12
 625              	 .cfi_offset 4,-12
 626              	 .cfi_offset 7,-8
 627              	 .cfi_offset 14,-4
 628 0002 87B0     	 sub sp,sp,#28
 629              	.LCFI37:
 630              	 .cfi_def_cfa_offset 40
 631 0004 00AF     	 add r7,sp,#0
 632              	.LCFI38:
 633              	 .cfi_def_cfa_register 7
 634 0006 7860     	 str r0,[r7,#4]
 598:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xReturn;
 599:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 635              	 .loc 1 599 0
 636 0008 7B68     	 ldr r3,[r7,#4]
 637 000a 3B61     	 str r3,[r7,#16]
 600:../Dave/Generated/FREERTOS/queue.c **** 
 601:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( pxMutex );
 638              	 .loc 1 601 0
 639 000c 3B69     	 ldr r3,[r7,#16]
 640 000e 002B     	 cmp r3,#0
 641 0010 09D1     	 bne .L34
 642              	.LBB115:
 643              	.LBB116:
 644              	 .loc 2 195 0 discriminator 1
 645              	
 646 0012 4FF0FC03 	 mov r3,#252
 647 0016 83F31188 	 msr basepri,r3
 648 001a BFF36F8F 	 isb 
 649 001e BFF34F8F 	 dsb 
 650              	
 651              	
 652              	 .thumb
 653 0022 FB60     	 str r3,[r7,#12]
 654              	.L35:
 655              	.LBE116:
 656              	.LBE115:
 657              	 .loc 1 601 0 discriminator 1
 658 0024 FEE7     	 b .L35
 659              	.L34:
 602:../Dave/Generated/FREERTOS/queue.c **** 
 603:../Dave/Generated/FREERTOS/queue.c **** 		/* If this is the task that holds the mutex then xMutexHolder will not
 604:../Dave/Generated/FREERTOS/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 605:../Dave/Generated/FREERTOS/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 606:../Dave/Generated/FREERTOS/queue.c **** 		this is the only condition we are interested in it does not matter if
 607:../Dave/Generated/FREERTOS/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 608:../Dave/Generated/FREERTOS/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 609:../Dave/Generated/FREERTOS/queue.c **** 		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 660              	 .loc 1 609 0
 661 0026 3B69     	 ldr r3,[r7,#16]
 662 0028 9C68     	 ldr r4,[r3,#8]
 663 002a FFF7FEFF 	 bl xTaskGetCurrentTaskHandle
 664 002e 0346     	 mov r3,r0
 665 0030 9C42     	 cmp r4,r3
 666 0032 11D1     	 bne .L36
 610:../Dave/Generated/FREERTOS/queue.c **** 		{
 611:../Dave/Generated/FREERTOS/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 612:../Dave/Generated/FREERTOS/queue.c **** 
 613:../Dave/Generated/FREERTOS/queue.c **** 			/* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
 614:../Dave/Generated/FREERTOS/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 615:../Dave/Generated/FREERTOS/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 616:../Dave/Generated/FREERTOS/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 617:../Dave/Generated/FREERTOS/queue.c **** 			uxRecursiveCallCount member. */
 618:../Dave/Generated/FREERTOS/queue.c **** 			( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
 667              	 .loc 1 618 0
 668 0034 3B69     	 ldr r3,[r7,#16]
 669 0036 DB68     	 ldr r3,[r3,#12]
 670 0038 5A1E     	 subs r2,r3,#1
 671 003a 3B69     	 ldr r3,[r7,#16]
 672 003c DA60     	 str r2,[r3,#12]
 619:../Dave/Generated/FREERTOS/queue.c **** 
 620:../Dave/Generated/FREERTOS/queue.c **** 			/* Has the recursive call count unwound to 0? */
 621:../Dave/Generated/FREERTOS/queue.c **** 			if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 673              	 .loc 1 621 0
 674 003e 3B69     	 ldr r3,[r7,#16]
 675 0040 DB68     	 ldr r3,[r3,#12]
 676 0042 002B     	 cmp r3,#0
 677 0044 05D1     	 bne .L37
 622:../Dave/Generated/FREERTOS/queue.c **** 			{
 623:../Dave/Generated/FREERTOS/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 624:../Dave/Generated/FREERTOS/queue.c **** 				task that might be waiting to access the mutex. */
 625:../Dave/Generated/FREERTOS/queue.c **** 				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 678              	 .loc 1 625 0
 679 0046 3869     	 ldr r0,[r7,#16]
 680 0048 0021     	 movs r1,#0
 681 004a 0022     	 movs r2,#0
 682 004c 0023     	 movs r3,#0
 683 004e FFF7FEFF 	 bl xQueueGenericSend
 684              	.L37:
 626:../Dave/Generated/FREERTOS/queue.c **** 			}
 627:../Dave/Generated/FREERTOS/queue.c **** 			else
 628:../Dave/Generated/FREERTOS/queue.c **** 			{
 629:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 630:../Dave/Generated/FREERTOS/queue.c **** 			}
 631:../Dave/Generated/FREERTOS/queue.c **** 
 632:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdPASS;
 685              	 .loc 1 632 0
 686 0052 0123     	 movs r3,#1
 687 0054 7B61     	 str r3,[r7,#20]
 688 0056 01E0     	 b .L38
 689              	.L36:
 633:../Dave/Generated/FREERTOS/queue.c **** 		}
 634:../Dave/Generated/FREERTOS/queue.c **** 		else
 635:../Dave/Generated/FREERTOS/queue.c **** 		{
 636:../Dave/Generated/FREERTOS/queue.c **** 			/* The mutex cannot be given because the calling task is not the
 637:../Dave/Generated/FREERTOS/queue.c **** 			holder. */
 638:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdFAIL;
 690              	 .loc 1 638 0
 691 0058 0023     	 movs r3,#0
 692 005a 7B61     	 str r3,[r7,#20]
 693              	.L38:
 639:../Dave/Generated/FREERTOS/queue.c **** 
 640:../Dave/Generated/FREERTOS/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 641:../Dave/Generated/FREERTOS/queue.c **** 		}
 642:../Dave/Generated/FREERTOS/queue.c **** 
 643:../Dave/Generated/FREERTOS/queue.c **** 		return xReturn;
 694              	 .loc 1 643 0
 695 005c 7B69     	 ldr r3,[r7,#20]
 644:../Dave/Generated/FREERTOS/queue.c **** 	}
 696              	 .loc 1 644 0
 697 005e 1846     	 mov r0,r3
 698 0060 1C37     	 adds r7,r7,#28
 699              	.LCFI39:
 700              	 .cfi_def_cfa_offset 12
 701 0062 BD46     	 mov sp,r7
 702              	.LCFI40:
 703              	 .cfi_def_cfa_register 13
 704              	 
 705 0064 90BD     	 pop {r4,r7,pc}
 706              	 .cfi_endproc
 707              	.LFE144:
 709 0066 00BF     	 .section .text.xQueueTakeMutexRecursive,"ax",%progbits
 710              	 .align 2
 711              	 .global xQueueTakeMutexRecursive
 712              	 .thumb
 713              	 .thumb_func
 715              	xQueueTakeMutexRecursive:
 716              	.LFB145:
 645:../Dave/Generated/FREERTOS/queue.c **** 
 646:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 647:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 648:../Dave/Generated/FREERTOS/queue.c **** 
 649:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 650:../Dave/Generated/FREERTOS/queue.c **** 
 651:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
 652:../Dave/Generated/FREERTOS/queue.c **** 	{
 717              	 .loc 1 652 0
 718              	 .cfi_startproc
 719              	 
 720              	 
 721 0000 90B5     	 push {r4,r7,lr}
 722              	.LCFI41:
 723              	 .cfi_def_cfa_offset 12
 724              	 .cfi_offset 4,-12
 725              	 .cfi_offset 7,-8
 726              	 .cfi_offset 14,-4
 727 0002 87B0     	 sub sp,sp,#28
 728              	.LCFI42:
 729              	 .cfi_def_cfa_offset 40
 730 0004 00AF     	 add r7,sp,#0
 731              	.LCFI43:
 732              	 .cfi_def_cfa_register 7
 733 0006 7860     	 str r0,[r7,#4]
 734 0008 3960     	 str r1,[r7]
 653:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xReturn;
 654:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 735              	 .loc 1 654 0
 736 000a 7B68     	 ldr r3,[r7,#4]
 737 000c 3B61     	 str r3,[r7,#16]
 655:../Dave/Generated/FREERTOS/queue.c **** 
 656:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( pxMutex );
 738              	 .loc 1 656 0
 739 000e 3B69     	 ldr r3,[r7,#16]
 740 0010 002B     	 cmp r3,#0
 741 0012 09D1     	 bne .L41
 742              	.LBB117:
 743              	.LBB118:
 744              	 .loc 2 195 0 discriminator 1
 745              	
 746 0014 4FF0FC03 	 mov r3,#252
 747 0018 83F31188 	 msr basepri,r3
 748 001c BFF36F8F 	 isb 
 749 0020 BFF34F8F 	 dsb 
 750              	
 751              	
 752              	 .thumb
 753 0024 FB60     	 str r3,[r7,#12]
 754              	.L42:
 755              	.LBE118:
 756              	.LBE117:
 757              	 .loc 1 656 0 discriminator 1
 758 0026 FEE7     	 b .L42
 759              	.L41:
 657:../Dave/Generated/FREERTOS/queue.c **** 
 658:../Dave/Generated/FREERTOS/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 659:../Dave/Generated/FREERTOS/queue.c **** 		xQueueGiveMutexRecursive(). */
 660:../Dave/Generated/FREERTOS/queue.c **** 
 661:../Dave/Generated/FREERTOS/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 662:../Dave/Generated/FREERTOS/queue.c **** 
 663:../Dave/Generated/FREERTOS/queue.c **** 		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 760              	 .loc 1 663 0
 761 0028 3B69     	 ldr r3,[r7,#16]
 762 002a 9C68     	 ldr r4,[r3,#8]
 763 002c FFF7FEFF 	 bl xTaskGetCurrentTaskHandle
 764 0030 0346     	 mov r3,r0
 765 0032 9C42     	 cmp r4,r3
 766 0034 07D1     	 bne .L43
 664:../Dave/Generated/FREERTOS/queue.c **** 		{
 665:../Dave/Generated/FREERTOS/queue.c **** 			( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 767              	 .loc 1 665 0
 768 0036 3B69     	 ldr r3,[r7,#16]
 769 0038 DB68     	 ldr r3,[r3,#12]
 770 003a 5A1C     	 adds r2,r3,#1
 771 003c 3B69     	 ldr r3,[r7,#16]
 772 003e DA60     	 str r2,[r3,#12]
 666:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdPASS;
 773              	 .loc 1 666 0
 774 0040 0123     	 movs r3,#1
 775 0042 7B61     	 str r3,[r7,#20]
 776 0044 0CE0     	 b .L44
 777              	.L43:
 667:../Dave/Generated/FREERTOS/queue.c **** 		}
 668:../Dave/Generated/FREERTOS/queue.c **** 		else
 669:../Dave/Generated/FREERTOS/queue.c **** 		{
 670:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
 778              	 .loc 1 670 0
 779 0046 3869     	 ldr r0,[r7,#16]
 780 0048 3968     	 ldr r1,[r7]
 781 004a FFF7FEFF 	 bl xQueueSemaphoreTake
 782 004e 7861     	 str r0,[r7,#20]
 671:../Dave/Generated/FREERTOS/queue.c **** 
 672:../Dave/Generated/FREERTOS/queue.c **** 			/* pdPASS will only be returned if the mutex was successfully
 673:../Dave/Generated/FREERTOS/queue.c **** 			obtained.  The calling task may have entered the Blocked state
 674:../Dave/Generated/FREERTOS/queue.c **** 			before reaching here. */
 675:../Dave/Generated/FREERTOS/queue.c **** 			if( xReturn != pdFAIL )
 783              	 .loc 1 675 0
 784 0050 7B69     	 ldr r3,[r7,#20]
 785 0052 002B     	 cmp r3,#0
 786 0054 04D0     	 beq .L44
 676:../Dave/Generated/FREERTOS/queue.c **** 			{
 677:../Dave/Generated/FREERTOS/queue.c **** 				( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 787              	 .loc 1 677 0
 788 0056 3B69     	 ldr r3,[r7,#16]
 789 0058 DB68     	 ldr r3,[r3,#12]
 790 005a 5A1C     	 adds r2,r3,#1
 791 005c 3B69     	 ldr r3,[r7,#16]
 792 005e DA60     	 str r2,[r3,#12]
 793              	.L44:
 678:../Dave/Generated/FREERTOS/queue.c **** 			}
 679:../Dave/Generated/FREERTOS/queue.c **** 			else
 680:../Dave/Generated/FREERTOS/queue.c **** 			{
 681:../Dave/Generated/FREERTOS/queue.c **** 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 682:../Dave/Generated/FREERTOS/queue.c **** 			}
 683:../Dave/Generated/FREERTOS/queue.c **** 		}
 684:../Dave/Generated/FREERTOS/queue.c **** 
 685:../Dave/Generated/FREERTOS/queue.c **** 		return xReturn;
 794              	 .loc 1 685 0
 795 0060 7B69     	 ldr r3,[r7,#20]
 686:../Dave/Generated/FREERTOS/queue.c **** 	}
 796              	 .loc 1 686 0
 797 0062 1846     	 mov r0,r3
 798 0064 1C37     	 adds r7,r7,#28
 799              	.LCFI44:
 800              	 .cfi_def_cfa_offset 12
 801 0066 BD46     	 mov sp,r7
 802              	.LCFI45:
 803              	 .cfi_def_cfa_register 13
 804              	 
 805 0068 90BD     	 pop {r4,r7,pc}
 806              	 .cfi_endproc
 807              	.LFE145:
 809 006a 00BF     	 .section .text.xQueueCreateCountingSemaphore,"ax",%progbits
 810              	 .align 2
 811              	 .global xQueueCreateCountingSemaphore
 812              	 .thumb
 813              	 .thumb_func
 815              	xQueueCreateCountingSemaphore:
 816              	.LFB146:
 687:../Dave/Generated/FREERTOS/queue.c **** 
 688:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 689:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 690:../Dave/Generated/FREERTOS/queue.c **** 
 691:../Dave/Generated/FREERTOS/queue.c **** #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 692:../Dave/Generated/FREERTOS/queue.c **** 
 693:../Dave/Generated/FREERTOS/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t
 694:../Dave/Generated/FREERTOS/queue.c **** 	{
 695:../Dave/Generated/FREERTOS/queue.c **** 	QueueHandle_t xHandle;
 696:../Dave/Generated/FREERTOS/queue.c **** 
 697:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( uxMaxCount != 0 );
 698:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 699:../Dave/Generated/FREERTOS/queue.c **** 
 700:../Dave/Generated/FREERTOS/queue.c **** 		xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStatic
 701:../Dave/Generated/FREERTOS/queue.c **** 
 702:../Dave/Generated/FREERTOS/queue.c **** 		if( xHandle != NULL )
 703:../Dave/Generated/FREERTOS/queue.c **** 		{
 704:../Dave/Generated/FREERTOS/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 705:../Dave/Generated/FREERTOS/queue.c **** 
 706:../Dave/Generated/FREERTOS/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 707:../Dave/Generated/FREERTOS/queue.c **** 		}
 708:../Dave/Generated/FREERTOS/queue.c **** 		else
 709:../Dave/Generated/FREERTOS/queue.c **** 		{
 710:../Dave/Generated/FREERTOS/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 711:../Dave/Generated/FREERTOS/queue.c **** 		}
 712:../Dave/Generated/FREERTOS/queue.c **** 
 713:../Dave/Generated/FREERTOS/queue.c **** 		return xHandle;
 714:../Dave/Generated/FREERTOS/queue.c **** 	}
 715:../Dave/Generated/FREERTOS/queue.c **** 
 716:../Dave/Generated/FREERTOS/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 717:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 718:../Dave/Generated/FREERTOS/queue.c **** 
 719:../Dave/Generated/FREERTOS/queue.c **** #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 720:../Dave/Generated/FREERTOS/queue.c **** 
 721:../Dave/Generated/FREERTOS/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxIni
 722:../Dave/Generated/FREERTOS/queue.c **** 	{
 817              	 .loc 1 722 0
 818              	 .cfi_startproc
 819              	 
 820              	 
 821 0000 80B5     	 push {r7,lr}
 822              	.LCFI46:
 823              	 .cfi_def_cfa_offset 8
 824              	 .cfi_offset 7,-8
 825              	 .cfi_offset 14,-4
 826 0002 86B0     	 sub sp,sp,#24
 827              	.LCFI47:
 828              	 .cfi_def_cfa_offset 32
 829 0004 00AF     	 add r7,sp,#0
 830              	.LCFI48:
 831              	 .cfi_def_cfa_register 7
 832 0006 7860     	 str r0,[r7,#4]
 833 0008 3960     	 str r1,[r7]
 723:../Dave/Generated/FREERTOS/queue.c **** 	QueueHandle_t xHandle;
 724:../Dave/Generated/FREERTOS/queue.c **** 
 725:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( uxMaxCount != 0 );
 834              	 .loc 1 725 0
 835 000a 7B68     	 ldr r3,[r7,#4]
 836 000c 002B     	 cmp r3,#0
 837 000e 09D1     	 bne .L47
 838              	.LBB119:
 839              	.LBB120:
 840              	 .loc 2 195 0 discriminator 1
 841              	
 842 0010 4FF0FC03 	 mov r3,#252
 843 0014 83F31188 	 msr basepri,r3
 844 0018 BFF36F8F 	 isb 
 845 001c BFF34F8F 	 dsb 
 846              	
 847              	
 848              	 .thumb
 849 0020 3B61     	 str r3,[r7,#16]
 850              	.L48:
 851              	.LBE120:
 852              	.LBE119:
 853              	 .loc 1 725 0 discriminator 1
 854 0022 FEE7     	 b .L48
 855              	.L47:
 726:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 856              	 .loc 1 726 0
 857 0024 3A68     	 ldr r2,[r7]
 858 0026 7B68     	 ldr r3,[r7,#4]
 859 0028 9A42     	 cmp r2,r3
 860 002a 09D9     	 bls .L49
 861              	.LBB121:
 862              	.LBB122:
 863              	 .loc 2 195 0 discriminator 1
 864              	
 865 002c 4FF0FC03 	 mov r3,#252
 866 0030 83F31188 	 msr basepri,r3
 867 0034 BFF36F8F 	 isb 
 868 0038 BFF34F8F 	 dsb 
 869              	
 870              	
 871              	 .thumb
 872 003c FB60     	 str r3,[r7,#12]
 873              	.L50:
 874              	.LBE122:
 875              	.LBE121:
 876              	 .loc 1 726 0 discriminator 2
 877 003e FEE7     	 b .L50
 878              	.L49:
 727:../Dave/Generated/FREERTOS/queue.c **** 
 728:../Dave/Generated/FREERTOS/queue.c **** 		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUN
 879              	 .loc 1 728 0
 880 0040 7868     	 ldr r0,[r7,#4]
 881 0042 0021     	 movs r1,#0
 882 0044 0222     	 movs r2,#2
 883 0046 FFF7FEFF 	 bl xQueueGenericCreate
 884 004a 7861     	 str r0,[r7,#20]
 729:../Dave/Generated/FREERTOS/queue.c **** 
 730:../Dave/Generated/FREERTOS/queue.c **** 		if( xHandle != NULL )
 885              	 .loc 1 730 0
 886 004c 7B69     	 ldr r3,[r7,#20]
 887 004e 002B     	 cmp r3,#0
 888 0050 02D0     	 beq .L51
 731:../Dave/Generated/FREERTOS/queue.c **** 		{
 732:../Dave/Generated/FREERTOS/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 889              	 .loc 1 732 0
 890 0052 7B69     	 ldr r3,[r7,#20]
 891 0054 3A68     	 ldr r2,[r7]
 892 0056 9A63     	 str r2,[r3,#56]
 893              	.L51:
 733:../Dave/Generated/FREERTOS/queue.c **** 
 734:../Dave/Generated/FREERTOS/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 735:../Dave/Generated/FREERTOS/queue.c **** 		}
 736:../Dave/Generated/FREERTOS/queue.c **** 		else
 737:../Dave/Generated/FREERTOS/queue.c **** 		{
 738:../Dave/Generated/FREERTOS/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 739:../Dave/Generated/FREERTOS/queue.c **** 		}
 740:../Dave/Generated/FREERTOS/queue.c **** 
 741:../Dave/Generated/FREERTOS/queue.c **** 		return xHandle;
 894              	 .loc 1 741 0
 895 0058 7B69     	 ldr r3,[r7,#20]
 742:../Dave/Generated/FREERTOS/queue.c **** 	}
 896              	 .loc 1 742 0
 897 005a 1846     	 mov r0,r3
 898 005c 1837     	 adds r7,r7,#24
 899              	.LCFI49:
 900              	 .cfi_def_cfa_offset 8
 901 005e BD46     	 mov sp,r7
 902              	.LCFI50:
 903              	 .cfi_def_cfa_register 13
 904              	 
 905 0060 80BD     	 pop {r7,pc}
 906              	 .cfi_endproc
 907              	.LFE146:
 909 0062 00BF     	 .section .text.xQueueGenericSend,"ax",%progbits
 910              	 .align 2
 911              	 .global xQueueGenericSend
 912              	 .thumb
 913              	 .thumb_func
 915              	xQueueGenericSend:
 916              	.LFB147:
 743:../Dave/Generated/FREERTOS/queue.c **** 
 744:../Dave/Generated/FREERTOS/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 745:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 746:../Dave/Generated/FREERTOS/queue.c **** 
 747:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xT
 748:../Dave/Generated/FREERTOS/queue.c **** {
 917              	 .loc 1 748 0
 918              	 .cfi_startproc
 919              	 
 920              	 
 921 0000 80B5     	 push {r7,lr}
 922              	.LCFI51:
 923              	 .cfi_def_cfa_offset 8
 924              	 .cfi_offset 7,-8
 925              	 .cfi_offset 14,-4
 926 0002 8EB0     	 sub sp,sp,#56
 927              	.LCFI52:
 928              	 .cfi_def_cfa_offset 64
 929 0004 00AF     	 add r7,sp,#0
 930              	.LCFI53:
 931              	 .cfi_def_cfa_register 7
 932 0006 F860     	 str r0,[r7,#12]
 933 0008 B960     	 str r1,[r7,#8]
 934 000a 7A60     	 str r2,[r7,#4]
 935 000c 3B60     	 str r3,[r7]
 749:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 936              	 .loc 1 749 0
 937 000e 0023     	 movs r3,#0
 938 0010 7B63     	 str r3,[r7,#52]
 750:../Dave/Generated/FREERTOS/queue.c **** TimeOut_t xTimeOut;
 751:../Dave/Generated/FREERTOS/queue.c **** Queue_t * const pxQueue = xQueue;
 939              	 .loc 1 751 0
 940 0012 FB68     	 ldr r3,[r7,#12]
 941 0014 3B63     	 str r3,[r7,#48]
 752:../Dave/Generated/FREERTOS/queue.c **** 
 753:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue );
 942              	 .loc 1 753 0
 943 0016 3B6B     	 ldr r3,[r7,#48]
 944 0018 002B     	 cmp r3,#0
 945 001a 09D1     	 bne .L54
 946              	.LBB123:
 947              	.LBB124:
 948              	 .loc 2 195 0 discriminator 1
 949              	
 950 001c 4FF0FC03 	 mov r3,#252
 951 0020 83F31188 	 msr basepri,r3
 952 0024 BFF36F8F 	 isb 
 953 0028 BFF34F8F 	 dsb 
 954              	
 955              	
 956              	 .thumb
 957 002c 7B62     	 str r3,[r7,#36]
 958              	.L55:
 959              	.LBE124:
 960              	.LBE123:
 961              	 .loc 1 753 0 discriminator 1
 962 002e FEE7     	 b .L55
 963              	.L54:
 754:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 964              	 .loc 1 754 0
 965 0030 BB68     	 ldr r3,[r7,#8]
 966 0032 002B     	 cmp r3,#0
 967 0034 03D1     	 bne .L56
 968              	 .loc 1 754 0 is_stmt 0 discriminator 2
 969 0036 3B6B     	 ldr r3,[r7,#48]
 970 0038 1B6C     	 ldr r3,[r3,#64]
 971 003a 002B     	 cmp r3,#0
 972 003c 01D1     	 bne .L57
 973              	.L56:
 974              	 .loc 1 754 0 discriminator 3
 975 003e 0123     	 movs r3,#1
 976 0040 00E0     	 b .L58
 977              	.L57:
 978              	 .loc 1 754 0 discriminator 4
 979 0042 0023     	 movs r3,#0
 980              	.L58:
 981              	 .loc 1 754 0 discriminator 6
 982 0044 002B     	 cmp r3,#0
 983 0046 09D1     	 bne .L59
 984              	.LBB125:
 985              	.LBB126:
 986              	 .loc 2 195 0 is_stmt 1 discriminator 7
 987              	
 988 0048 4FF0FC03 	 mov r3,#252
 989 004c 83F31188 	 msr basepri,r3
 990 0050 BFF36F8F 	 isb 
 991 0054 BFF34F8F 	 dsb 
 992              	
 993              	
 994              	 .thumb
 995 0058 3B62     	 str r3,[r7,#32]
 996              	.L60:
 997              	.LBE126:
 998              	.LBE125:
 999              	 .loc 1 754 0 discriminator 2
 1000 005a FEE7     	 b .L60
 1001              	.L59:
 755:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1002              	 .loc 1 755 0
 1003 005c 3B68     	 ldr r3,[r7]
 1004 005e 022B     	 cmp r3,#2
 1005 0060 03D1     	 bne .L61
 1006              	 .loc 1 755 0 is_stmt 0 discriminator 2
 1007 0062 3B6B     	 ldr r3,[r7,#48]
 1008 0064 DB6B     	 ldr r3,[r3,#60]
 1009 0066 012B     	 cmp r3,#1
 1010 0068 01D1     	 bne .L62
 1011              	.L61:
 1012              	 .loc 1 755 0 discriminator 3
 1013 006a 0123     	 movs r3,#1
 1014 006c 00E0     	 b .L63
 1015              	.L62:
 1016              	 .loc 1 755 0 discriminator 4
 1017 006e 0023     	 movs r3,#0
 1018              	.L63:
 1019              	 .loc 1 755 0 discriminator 6
 1020 0070 002B     	 cmp r3,#0
 1021 0072 09D1     	 bne .L64
 1022              	.LBB127:
 1023              	.LBB128:
 1024              	 .loc 2 195 0 is_stmt 1 discriminator 7
 1025              	
 1026 0074 4FF0FC03 	 mov r3,#252
 1027 0078 83F31188 	 msr basepri,r3
 1028 007c BFF36F8F 	 isb 
 1029 0080 BFF34F8F 	 dsb 
 1030              	
 1031              	
 1032              	 .thumb
 1033 0084 FB61     	 str r3,[r7,#28]
 1034              	.L65:
 1035              	.LBE128:
 1036              	.LBE127:
 1037              	 .loc 1 755 0 discriminator 3
 1038 0086 FEE7     	 b .L65
 1039              	.L64:
 756:../Dave/Generated/FREERTOS/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 757:../Dave/Generated/FREERTOS/queue.c **** 	{
 758:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
 1040              	 .loc 1 758 0
 1041 0088 FFF7FEFF 	 bl xTaskGetSchedulerState
 1042 008c 0346     	 mov r3,r0
 1043 008e 002B     	 cmp r3,#0
 1044 0090 02D1     	 bne .L66
 1045              	 .loc 1 758 0 is_stmt 0 discriminator 2
 1046 0092 7B68     	 ldr r3,[r7,#4]
 1047 0094 002B     	 cmp r3,#0
 1048 0096 01D1     	 bne .L67
 1049              	.L66:
 1050              	 .loc 1 758 0 discriminator 3
 1051 0098 0123     	 movs r3,#1
 1052 009a 00E0     	 b .L68
 1053              	.L67:
 1054              	 .loc 1 758 0 discriminator 4
 1055 009c 0023     	 movs r3,#0
 1056              	.L68:
 1057              	 .loc 1 758 0 discriminator 6
 1058 009e 002B     	 cmp r3,#0
 1059 00a0 09D1     	 bne .L69
 1060              	.LBB129:
 1061              	.LBB130:
 1062              	 .loc 2 195 0 is_stmt 1 discriminator 7
 1063              	
 1064 00a2 4FF0FC03 	 mov r3,#252
 1065 00a6 83F31188 	 msr basepri,r3
 1066 00aa BFF36F8F 	 isb 
 1067 00ae BFF34F8F 	 dsb 
 1068              	
 1069              	
 1070              	 .thumb
 1071 00b2 BB61     	 str r3,[r7,#24]
 1072              	.L70:
 1073              	.LBE130:
 1074              	.LBE129:
 1075              	 .loc 1 758 0 discriminator 4
 1076 00b4 FEE7     	 b .L70
 1077              	.L69:
 759:../Dave/Generated/FREERTOS/queue.c **** 	}
 760:../Dave/Generated/FREERTOS/queue.c **** 	#endif
 761:../Dave/Generated/FREERTOS/queue.c **** 
 762:../Dave/Generated/FREERTOS/queue.c **** 
 763:../Dave/Generated/FREERTOS/queue.c **** 	/*lint -save -e904 This function relaxes the coding standard somewhat to
 764:../Dave/Generated/FREERTOS/queue.c **** 	allow return statements within the function itself.  This is done in the
 765:../Dave/Generated/FREERTOS/queue.c **** 	interest of execution time efficiency. */
 766:../Dave/Generated/FREERTOS/queue.c **** 	for( ;; )
 767:../Dave/Generated/FREERTOS/queue.c **** 	{
 768:../Dave/Generated/FREERTOS/queue.c **** 		taskENTER_CRITICAL();
 1078              	 .loc 1 768 0
 1079 00b6 FFF7FEFF 	 bl vPortEnterCritical
 769:../Dave/Generated/FREERTOS/queue.c **** 		{
 770:../Dave/Generated/FREERTOS/queue.c **** 			/* Is there room on the queue now?  The running task must be the
 771:../Dave/Generated/FREERTOS/queue.c **** 			highest priority task wanting to access the queue.  If the head item
 772:../Dave/Generated/FREERTOS/queue.c **** 			in the queue is to be overwritten then it does not matter if the
 773:../Dave/Generated/FREERTOS/queue.c **** 			queue is full. */
 774:../Dave/Generated/FREERTOS/queue.c **** 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 1080              	 .loc 1 774 0
 1081 00ba 3B6B     	 ldr r3,[r7,#48]
 1082 00bc 9A6B     	 ldr r2,[r3,#56]
 1083 00be 3B6B     	 ldr r3,[r7,#48]
 1084 00c0 DB6B     	 ldr r3,[r3,#60]
 1085 00c2 9A42     	 cmp r2,r3
 1086 00c4 02D3     	 bcc .L71
 1087              	 .loc 1 774 0 is_stmt 0 discriminator 1
 1088 00c6 3B68     	 ldr r3,[r7]
 1089 00c8 022B     	 cmp r3,#2
 1090 00ca 48D1     	 bne .L72
 1091              	.L71:
 1092              	.LBB131:
 775:../Dave/Generated/FREERTOS/queue.c **** 			{
 776:../Dave/Generated/FREERTOS/queue.c **** 				traceQUEUE_SEND( pxQueue );
 777:../Dave/Generated/FREERTOS/queue.c **** 
 778:../Dave/Generated/FREERTOS/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 779:../Dave/Generated/FREERTOS/queue.c **** 				{
 780:../Dave/Generated/FREERTOS/queue.c **** 				UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 1093              	 .loc 1 780 0 is_stmt 1
 1094 00cc 3B6B     	 ldr r3,[r7,#48]
 1095 00ce 9B6B     	 ldr r3,[r3,#56]
 1096 00d0 FB62     	 str r3,[r7,#44]
 781:../Dave/Generated/FREERTOS/queue.c **** 
 782:../Dave/Generated/FREERTOS/queue.c **** 					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 1097              	 .loc 1 782 0
 1098 00d2 386B     	 ldr r0,[r7,#48]
 1099 00d4 B968     	 ldr r1,[r7,#8]
 1100 00d6 3A68     	 ldr r2,[r7]
 1101 00d8 FFF7FEFF 	 bl prvCopyDataToQueue
 1102 00dc B862     	 str r0,[r7,#40]
 783:../Dave/Generated/FREERTOS/queue.c **** 
 784:../Dave/Generated/FREERTOS/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 1103              	 .loc 1 784 0
 1104 00de 3B6B     	 ldr r3,[r7,#48]
 1105 00e0 9B6C     	 ldr r3,[r3,#72]
 1106 00e2 002B     	 cmp r3,#0
 1107 00e4 17D0     	 beq .L73
 785:../Dave/Generated/FREERTOS/queue.c **** 					{
 786:../Dave/Generated/FREERTOS/queue.c **** 						if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 )
 1108              	 .loc 1 786 0
 1109 00e6 3B68     	 ldr r3,[r7]
 1110 00e8 022B     	 cmp r3,#2
 1111 00ea 04D1     	 bne .L74
 1112              	 .loc 1 786 0 is_stmt 0 discriminator 1
 1113 00ec FB6A     	 ldr r3,[r7,#44]
 1114 00ee 002B     	 cmp r3,#0
 1115 00f0 01D0     	 beq .L74
 1116              	 .loc 1 786 0
 1117 00f2 00BF     	 nop
 1118 00f4 2FE0     	 b .L76
 1119              	.L74:
 787:../Dave/Generated/FREERTOS/queue.c **** 						{
 788:../Dave/Generated/FREERTOS/queue.c **** 							/* Do not notify the queue set as an existing item
 789:../Dave/Generated/FREERTOS/queue.c **** 							was overwritten in the queue so the number of items
 790:../Dave/Generated/FREERTOS/queue.c **** 							in the queue has not changed. */
 791:../Dave/Generated/FREERTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 792:../Dave/Generated/FREERTOS/queue.c **** 						}
 793:../Dave/Generated/FREERTOS/queue.c **** 						else if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
 1120              	 .loc 1 793 0 is_stmt 1
 1121 00f6 386B     	 ldr r0,[r7,#48]
 1122 00f8 3968     	 ldr r1,[r7]
 1123 00fa FFF7FEFF 	 bl prvNotifyQueueSetContainer
 1124 00fe 0346     	 mov r3,r0
 1125 0100 002B     	 cmp r3,#0
 1126 0102 28D0     	 beq .L76
 794:../Dave/Generated/FREERTOS/queue.c **** 						{
 795:../Dave/Generated/FREERTOS/queue.c **** 							/* The queue is a member of a queue set, and posting
 796:../Dave/Generated/FREERTOS/queue.c **** 							to the queue set caused a higher priority task to
 797:../Dave/Generated/FREERTOS/queue.c **** 							unblock. A context switch is required. */
 798:../Dave/Generated/FREERTOS/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 1127              	 .loc 1 798 0
 1128 0104 4C4B     	 ldr r3,.L89
 1129 0106 4FF08052 	 mov r2,#268435456
 1130 010a 1A60     	 str r2,[r3]
 1131              	
 1132 010c BFF34F8F 	 dsb
 1133              	
 1134              	
 1135 0110 BFF36F8F 	 isb
 1136              	
 1137              	 .thumb
 1138 0114 1FE0     	 b .L76
 1139              	.L73:
 799:../Dave/Generated/FREERTOS/queue.c **** 						}
 800:../Dave/Generated/FREERTOS/queue.c **** 						else
 801:../Dave/Generated/FREERTOS/queue.c **** 						{
 802:../Dave/Generated/FREERTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 803:../Dave/Generated/FREERTOS/queue.c **** 						}
 804:../Dave/Generated/FREERTOS/queue.c **** 					}
 805:../Dave/Generated/FREERTOS/queue.c **** 					else
 806:../Dave/Generated/FREERTOS/queue.c **** 					{
 807:../Dave/Generated/FREERTOS/queue.c **** 						/* If there was a task waiting for data to arrive on the
 808:../Dave/Generated/FREERTOS/queue.c **** 						queue then unblock it now. */
 809:../Dave/Generated/FREERTOS/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1140              	 .loc 1 809 0
 1141 0116 3B6B     	 ldr r3,[r7,#48]
 1142 0118 5B6A     	 ldr r3,[r3,#36]
 1143 011a 002B     	 cmp r3,#0
 1144 011c 10D0     	 beq .L77
 810:../Dave/Generated/FREERTOS/queue.c **** 						{
 811:../Dave/Generated/FREERTOS/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1145              	 .loc 1 811 0
 1146 011e 3B6B     	 ldr r3,[r7,#48]
 1147 0120 2433     	 adds r3,r3,#36
 1148 0122 1846     	 mov r0,r3
 1149 0124 FFF7FEFF 	 bl xTaskRemoveFromEventList
 1150 0128 0346     	 mov r3,r0
 1151 012a 002B     	 cmp r3,#0
 1152 012c 13D0     	 beq .L76
 812:../Dave/Generated/FREERTOS/queue.c **** 							{
 813:../Dave/Generated/FREERTOS/queue.c **** 								/* The unblocked task has a priority higher than
 814:../Dave/Generated/FREERTOS/queue.c **** 								our own so yield immediately.  Yes it is ok to
 815:../Dave/Generated/FREERTOS/queue.c **** 								do this from within the critical section - the
 816:../Dave/Generated/FREERTOS/queue.c **** 								kernel takes care of that. */
 817:../Dave/Generated/FREERTOS/queue.c **** 								queueYIELD_IF_USING_PREEMPTION();
 1153              	 .loc 1 817 0
 1154 012e 424B     	 ldr r3,.L89
 1155 0130 4FF08052 	 mov r2,#268435456
 1156 0134 1A60     	 str r2,[r3]
 1157              	
 1158 0136 BFF34F8F 	 dsb
 1159              	
 1160              	
 1161 013a BFF36F8F 	 isb
 1162              	
 1163              	 .thumb
 1164 013e 0AE0     	 b .L76
 1165              	.L77:
 818:../Dave/Generated/FREERTOS/queue.c **** 							}
 819:../Dave/Generated/FREERTOS/queue.c **** 							else
 820:../Dave/Generated/FREERTOS/queue.c **** 							{
 821:../Dave/Generated/FREERTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 822:../Dave/Generated/FREERTOS/queue.c **** 							}
 823:../Dave/Generated/FREERTOS/queue.c **** 						}
 824:../Dave/Generated/FREERTOS/queue.c **** 						else if( xYieldRequired != pdFALSE )
 1166              	 .loc 1 824 0
 1167 0140 BB6A     	 ldr r3,[r7,#40]
 1168 0142 002B     	 cmp r3,#0
 1169 0144 07D0     	 beq .L76
 825:../Dave/Generated/FREERTOS/queue.c **** 						{
 826:../Dave/Generated/FREERTOS/queue.c **** 							/* This path is a special case that will only get
 827:../Dave/Generated/FREERTOS/queue.c **** 							executed if the task was holding multiple mutexes
 828:../Dave/Generated/FREERTOS/queue.c **** 							and the mutexes were given back in an order that is
 829:../Dave/Generated/FREERTOS/queue.c **** 							different to that in which they were taken. */
 830:../Dave/Generated/FREERTOS/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 1170              	 .loc 1 830 0
 1171 0146 3C4B     	 ldr r3,.L89
 1172 0148 4FF08052 	 mov r2,#268435456
 1173 014c 1A60     	 str r2,[r3]
 1174              	
 1175 014e BFF34F8F 	 dsb
 1176              	
 1177              	
 1178 0152 BFF36F8F 	 isb
 1179              	
 1180              	 .thumb
 1181              	.L76:
 1182              	.LBE131:
 831:../Dave/Generated/FREERTOS/queue.c **** 						}
 832:../Dave/Generated/FREERTOS/queue.c **** 						else
 833:../Dave/Generated/FREERTOS/queue.c **** 						{
 834:../Dave/Generated/FREERTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 835:../Dave/Generated/FREERTOS/queue.c **** 						}
 836:../Dave/Generated/FREERTOS/queue.c **** 					}
 837:../Dave/Generated/FREERTOS/queue.c **** 				}
 838:../Dave/Generated/FREERTOS/queue.c **** 				#else /* configUSE_QUEUE_SETS */
 839:../Dave/Generated/FREERTOS/queue.c **** 				{
 840:../Dave/Generated/FREERTOS/queue.c **** 					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 841:../Dave/Generated/FREERTOS/queue.c **** 
 842:../Dave/Generated/FREERTOS/queue.c **** 					/* If there was a task waiting for data to arrive on the
 843:../Dave/Generated/FREERTOS/queue.c **** 					queue then unblock it now. */
 844:../Dave/Generated/FREERTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 845:../Dave/Generated/FREERTOS/queue.c **** 					{
 846:../Dave/Generated/FREERTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 847:../Dave/Generated/FREERTOS/queue.c **** 						{
 848:../Dave/Generated/FREERTOS/queue.c **** 							/* The unblocked task has a priority higher than
 849:../Dave/Generated/FREERTOS/queue.c **** 							our own so yield immediately.  Yes it is ok to do
 850:../Dave/Generated/FREERTOS/queue.c **** 							this from within the critical section - the kernel
 851:../Dave/Generated/FREERTOS/queue.c **** 							takes care of that. */
 852:../Dave/Generated/FREERTOS/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 853:../Dave/Generated/FREERTOS/queue.c **** 						}
 854:../Dave/Generated/FREERTOS/queue.c **** 						else
 855:../Dave/Generated/FREERTOS/queue.c **** 						{
 856:../Dave/Generated/FREERTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 857:../Dave/Generated/FREERTOS/queue.c **** 						}
 858:../Dave/Generated/FREERTOS/queue.c **** 					}
 859:../Dave/Generated/FREERTOS/queue.c **** 					else if( xYieldRequired != pdFALSE )
 860:../Dave/Generated/FREERTOS/queue.c **** 					{
 861:../Dave/Generated/FREERTOS/queue.c **** 						/* This path is a special case that will only get
 862:../Dave/Generated/FREERTOS/queue.c **** 						executed if the task was holding multiple mutexes and
 863:../Dave/Generated/FREERTOS/queue.c **** 						the mutexes were given back in an order that is
 864:../Dave/Generated/FREERTOS/queue.c **** 						different to that in which they were taken. */
 865:../Dave/Generated/FREERTOS/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 866:../Dave/Generated/FREERTOS/queue.c **** 					}
 867:../Dave/Generated/FREERTOS/queue.c **** 					else
 868:../Dave/Generated/FREERTOS/queue.c **** 					{
 869:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
 870:../Dave/Generated/FREERTOS/queue.c **** 					}
 871:../Dave/Generated/FREERTOS/queue.c **** 				}
 872:../Dave/Generated/FREERTOS/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
 873:../Dave/Generated/FREERTOS/queue.c **** 
 874:../Dave/Generated/FREERTOS/queue.c **** 				taskEXIT_CRITICAL();
 1183              	 .loc 1 874 0
 1184 0156 FFF7FEFF 	 bl vPortExitCritical
 875:../Dave/Generated/FREERTOS/queue.c **** 				return pdPASS;
 1185              	 .loc 1 875 0
 1186 015a 0123     	 movs r3,#1
 1187 015c 67E0     	 b .L88
 1188              	.L72:
 876:../Dave/Generated/FREERTOS/queue.c **** 			}
 877:../Dave/Generated/FREERTOS/queue.c **** 			else
 878:../Dave/Generated/FREERTOS/queue.c **** 			{
 879:../Dave/Generated/FREERTOS/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 1189              	 .loc 1 879 0
 1190 015e 7B68     	 ldr r3,[r7,#4]
 1191 0160 002B     	 cmp r3,#0
 1192 0162 03D1     	 bne .L79
 880:../Dave/Generated/FREERTOS/queue.c **** 				{
 881:../Dave/Generated/FREERTOS/queue.c **** 					/* The queue was full and no block time is specified (or
 882:../Dave/Generated/FREERTOS/queue.c **** 					the block time has expired) so leave now. */
 883:../Dave/Generated/FREERTOS/queue.c **** 					taskEXIT_CRITICAL();
 1193              	 .loc 1 883 0
 1194 0164 FFF7FEFF 	 bl vPortExitCritical
 884:../Dave/Generated/FREERTOS/queue.c **** 
 885:../Dave/Generated/FREERTOS/queue.c **** 					/* Return to the original privilege level before exiting
 886:../Dave/Generated/FREERTOS/queue.c **** 					the function. */
 887:../Dave/Generated/FREERTOS/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 888:../Dave/Generated/FREERTOS/queue.c **** 					return errQUEUE_FULL;
 1195              	 .loc 1 888 0
 1196 0168 0023     	 movs r3,#0
 1197 016a 60E0     	 b .L88
 1198              	.L79:
 889:../Dave/Generated/FREERTOS/queue.c **** 				}
 890:../Dave/Generated/FREERTOS/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 1199              	 .loc 1 890 0
 1200 016c 7B6B     	 ldr r3,[r7,#52]
 1201 016e 002B     	 cmp r3,#0
 1202 0170 06D1     	 bne .L80
 891:../Dave/Generated/FREERTOS/queue.c **** 				{
 892:../Dave/Generated/FREERTOS/queue.c **** 					/* The queue was full and a block time was specified so
 893:../Dave/Generated/FREERTOS/queue.c **** 					configure the timeout structure. */
 894:../Dave/Generated/FREERTOS/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
 1203              	 .loc 1 894 0
 1204 0172 07F11003 	 add r3,r7,#16
 1205 0176 1846     	 mov r0,r3
 1206 0178 FFF7FEFF 	 bl vTaskInternalSetTimeOutState
 895:../Dave/Generated/FREERTOS/queue.c **** 					xEntryTimeSet = pdTRUE;
 1207              	 .loc 1 895 0
 1208 017c 0123     	 movs r3,#1
 1209 017e 7B63     	 str r3,[r7,#52]
 1210              	.L80:
 896:../Dave/Generated/FREERTOS/queue.c **** 				}
 897:../Dave/Generated/FREERTOS/queue.c **** 				else
 898:../Dave/Generated/FREERTOS/queue.c **** 				{
 899:../Dave/Generated/FREERTOS/queue.c **** 					/* Entry time was already set. */
 900:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 901:../Dave/Generated/FREERTOS/queue.c **** 				}
 902:../Dave/Generated/FREERTOS/queue.c **** 			}
 903:../Dave/Generated/FREERTOS/queue.c **** 		}
 904:../Dave/Generated/FREERTOS/queue.c **** 		taskEXIT_CRITICAL();
 1211              	 .loc 1 904 0
 1212 0180 FFF7FEFF 	 bl vPortExitCritical
 905:../Dave/Generated/FREERTOS/queue.c **** 
 906:../Dave/Generated/FREERTOS/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 907:../Dave/Generated/FREERTOS/queue.c **** 		now the critical section has been exited. */
 908:../Dave/Generated/FREERTOS/queue.c **** 
 909:../Dave/Generated/FREERTOS/queue.c **** 		vTaskSuspendAll();
 1213              	 .loc 1 909 0
 1214 0184 FFF7FEFF 	 bl vTaskSuspendAll
 910:../Dave/Generated/FREERTOS/queue.c **** 		prvLockQueue( pxQueue );
 1215              	 .loc 1 910 0
 1216 0188 FFF7FEFF 	 bl vPortEnterCritical
 1217 018c 3B6B     	 ldr r3,[r7,#48]
 1218 018e 93F84430 	 ldrb r3,[r3,#68]
 1219 0192 DBB2     	 uxtb r3,r3
 1220 0194 5BB2     	 sxtb r3,r3
 1221 0196 B3F1FF3F 	 cmp r3,#-1
 1222 019a 03D1     	 bne .L81
 1223              	 .loc 1 910 0 is_stmt 0 discriminator 1
 1224 019c 3B6B     	 ldr r3,[r7,#48]
 1225 019e 0022     	 movs r2,#0
 1226 01a0 83F84420 	 strb r2,[r3,#68]
 1227              	.L81:
 1228              	 .loc 1 910 0 discriminator 3
 1229 01a4 3B6B     	 ldr r3,[r7,#48]
 1230 01a6 93F84530 	 ldrb r3,[r3,#69]
 1231 01aa DBB2     	 uxtb r3,r3
 1232 01ac 5BB2     	 sxtb r3,r3
 1233 01ae B3F1FF3F 	 cmp r3,#-1
 1234 01b2 03D1     	 bne .L82
 1235              	 .loc 1 910 0 discriminator 4
 1236 01b4 3B6B     	 ldr r3,[r7,#48]
 1237 01b6 0022     	 movs r2,#0
 1238 01b8 83F84520 	 strb r2,[r3,#69]
 1239              	.L82:
 1240              	 .loc 1 910 0 discriminator 6
 1241 01bc FFF7FEFF 	 bl vPortExitCritical
 911:../Dave/Generated/FREERTOS/queue.c **** 
 912:../Dave/Generated/FREERTOS/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 913:../Dave/Generated/FREERTOS/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1242              	 .loc 1 913 0 is_stmt 1 discriminator 6
 1243 01c0 07F11002 	 add r2,r7,#16
 1244 01c4 3B1D     	 adds r3,r7,#4
 1245 01c6 1046     	 mov r0,r2
 1246 01c8 1946     	 mov r1,r3
 1247 01ca FFF7FEFF 	 bl xTaskCheckForTimeOut
 1248 01ce 0346     	 mov r3,r0
 1249 01d0 002B     	 cmp r3,#0
 1250 01d2 24D1     	 bne .L83
 914:../Dave/Generated/FREERTOS/queue.c **** 		{
 915:../Dave/Generated/FREERTOS/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 1251              	 .loc 1 915 0
 1252 01d4 386B     	 ldr r0,[r7,#48]
 1253 01d6 FFF7FEFF 	 bl prvIsQueueFull
 1254 01da 0346     	 mov r3,r0
 1255 01dc 002B     	 cmp r3,#0
 1256 01de 18D0     	 beq .L84
 916:../Dave/Generated/FREERTOS/queue.c **** 			{
 917:../Dave/Generated/FREERTOS/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 918:../Dave/Generated/FREERTOS/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 1257              	 .loc 1 918 0
 1258 01e0 3B6B     	 ldr r3,[r7,#48]
 1259 01e2 03F11002 	 add r2,r3,#16
 1260 01e6 7B68     	 ldr r3,[r7,#4]
 1261 01e8 1046     	 mov r0,r2
 1262 01ea 1946     	 mov r1,r3
 1263 01ec FFF7FEFF 	 bl vTaskPlaceOnEventList
 919:../Dave/Generated/FREERTOS/queue.c **** 
 920:../Dave/Generated/FREERTOS/queue.c **** 				/* Unlocking the queue means queue events can effect the
 921:../Dave/Generated/FREERTOS/queue.c **** 				event list.  It is possible that interrupts occurring now
 922:../Dave/Generated/FREERTOS/queue.c **** 				remove this task from the event list again - but as the
 923:../Dave/Generated/FREERTOS/queue.c **** 				scheduler is suspended the task will go onto the pending
 924:../Dave/Generated/FREERTOS/queue.c **** 				ready last instead of the actual ready list. */
 925:../Dave/Generated/FREERTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 1264              	 .loc 1 925 0
 1265 01f0 386B     	 ldr r0,[r7,#48]
 1266 01f2 FFF7FEFF 	 bl prvUnlockQueue
 926:../Dave/Generated/FREERTOS/queue.c **** 
 927:../Dave/Generated/FREERTOS/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 928:../Dave/Generated/FREERTOS/queue.c **** 				ready list into the ready list - so it is feasible that this
 929:../Dave/Generated/FREERTOS/queue.c **** 				task is already in a ready list before it yields - in which
 930:../Dave/Generated/FREERTOS/queue.c **** 				case the yield will not cause a context switch unless there
 931:../Dave/Generated/FREERTOS/queue.c **** 				is also a higher priority task in the pending ready list. */
 932:../Dave/Generated/FREERTOS/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1267              	 .loc 1 932 0
 1268 01f6 FFF7FEFF 	 bl xTaskResumeAll
 1269 01fa 0346     	 mov r3,r0
 1270 01fc 002B     	 cmp r3,#0
 1271 01fe 15D1     	 bne .L87
 933:../Dave/Generated/FREERTOS/queue.c **** 				{
 934:../Dave/Generated/FREERTOS/queue.c **** 					portYIELD_WITHIN_API();
 1272              	 .loc 1 934 0
 1273 0200 0D4B     	 ldr r3,.L89
 1274 0202 4FF08052 	 mov r2,#268435456
 1275 0206 1A60     	 str r2,[r3]
 1276              	
 1277 0208 BFF34F8F 	 dsb
 1278              	
 1279              	
 1280 020c BFF36F8F 	 isb
 1281              	
 1282              	 .thumb
 1283 0210 0CE0     	 b .L87
 1284              	.L84:
 935:../Dave/Generated/FREERTOS/queue.c **** 				}
 936:../Dave/Generated/FREERTOS/queue.c **** 			}
 937:../Dave/Generated/FREERTOS/queue.c **** 			else
 938:../Dave/Generated/FREERTOS/queue.c **** 			{
 939:../Dave/Generated/FREERTOS/queue.c **** 				/* Try again. */
 940:../Dave/Generated/FREERTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 1285              	 .loc 1 940 0
 1286 0212 386B     	 ldr r0,[r7,#48]
 1287 0214 FFF7FEFF 	 bl prvUnlockQueue
 941:../Dave/Generated/FREERTOS/queue.c **** 				( void ) xTaskResumeAll();
 1288              	 .loc 1 941 0
 1289 0218 FFF7FEFF 	 bl xTaskResumeAll
 1290 021c 4BE7     	 b .L69
 1291              	.L83:
 942:../Dave/Generated/FREERTOS/queue.c **** 			}
 943:../Dave/Generated/FREERTOS/queue.c **** 		}
 944:../Dave/Generated/FREERTOS/queue.c **** 		else
 945:../Dave/Generated/FREERTOS/queue.c **** 		{
 946:../Dave/Generated/FREERTOS/queue.c **** 			/* The timeout has expired. */
 947:../Dave/Generated/FREERTOS/queue.c **** 			prvUnlockQueue( pxQueue );
 1292              	 .loc 1 947 0
 1293 021e 386B     	 ldr r0,[r7,#48]
 1294 0220 FFF7FEFF 	 bl prvUnlockQueue
 948:../Dave/Generated/FREERTOS/queue.c **** 			( void ) xTaskResumeAll();
 1295              	 .loc 1 948 0
 1296 0224 FFF7FEFF 	 bl xTaskResumeAll
 949:../Dave/Generated/FREERTOS/queue.c **** 
 950:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 951:../Dave/Generated/FREERTOS/queue.c **** 			return errQUEUE_FULL;
 1297              	 .loc 1 951 0
 1298 0228 0023     	 movs r3,#0
 1299 022a 00E0     	 b .L88
 1300              	.L87:
 952:../Dave/Generated/FREERTOS/queue.c **** 		}
 953:../Dave/Generated/FREERTOS/queue.c **** 	} /*lint -restore */
 1301              	 .loc 1 953 0 discriminator 7
 1302 022c 43E7     	 b .L69
 1303              	.L88:
 954:../Dave/Generated/FREERTOS/queue.c **** }
 1304              	 .loc 1 954 0 discriminator 8
 1305 022e 1846     	 mov r0,r3
 1306 0230 3837     	 adds r7,r7,#56
 1307              	.LCFI54:
 1308              	 .cfi_def_cfa_offset 8
 1309 0232 BD46     	 mov sp,r7
 1310              	.LCFI55:
 1311              	 .cfi_def_cfa_register 13
 1312              	 
 1313 0234 80BD     	 pop {r7,pc}
 1314              	.L90:
 1315 0236 00BF     	 .align 2
 1316              	.L89:
 1317 0238 04ED00E0 	 .word -536810236
 1318              	 .cfi_endproc
 1319              	.LFE147:
 1321              	 .section .text.xQueueGenericSendFromISR,"ax",%progbits
 1322              	 .align 2
 1323              	 .global xQueueGenericSendFromISR
 1324              	 .thumb
 1325              	 .thumb_func
 1327              	xQueueGenericSendFromISR:
 1328              	.LFB148:
 955:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
 956:../Dave/Generated/FREERTOS/queue.c **** 
 957:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseTy
 958:../Dave/Generated/FREERTOS/queue.c **** {
 1329              	 .loc 1 958 0
 1330              	 .cfi_startproc
 1331              	 
 1332              	 
 1333 0000 80B5     	 push {r7,lr}
 1334              	.LCFI56:
 1335              	 .cfi_def_cfa_offset 8
 1336              	 .cfi_offset 7,-8
 1337              	 .cfi_offset 14,-4
 1338 0002 8EB0     	 sub sp,sp,#56
 1339              	.LCFI57:
 1340              	 .cfi_def_cfa_offset 64
 1341 0004 00AF     	 add r7,sp,#0
 1342              	.LCFI58:
 1343              	 .cfi_def_cfa_register 7
 1344 0006 F860     	 str r0,[r7,#12]
 1345 0008 B960     	 str r1,[r7,#8]
 1346 000a 7A60     	 str r2,[r7,#4]
 1347 000c 3B60     	 str r3,[r7]
 959:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xReturn;
 960:../Dave/Generated/FREERTOS/queue.c **** UBaseType_t uxSavedInterruptStatus;
 961:../Dave/Generated/FREERTOS/queue.c **** Queue_t * const pxQueue = xQueue;
 1348              	 .loc 1 961 0
 1349 000e FB68     	 ldr r3,[r7,#12]
 1350 0010 3B63     	 str r3,[r7,#48]
 962:../Dave/Generated/FREERTOS/queue.c **** 
 963:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue );
 1351              	 .loc 1 963 0
 1352 0012 3B6B     	 ldr r3,[r7,#48]
 1353 0014 002B     	 cmp r3,#0
 1354 0016 09D1     	 bne .L92
 1355              	.LBB132:
 1356              	.LBB133:
 1357              	 .loc 2 195 0 discriminator 1
 1358              	
 1359 0018 4FF0FC03 	 mov r3,#252
 1360 001c 83F31188 	 msr basepri,r3
 1361 0020 BFF36F8F 	 isb 
 1362 0024 BFF34F8F 	 dsb 
 1363              	
 1364              	
 1365              	 .thumb
 1366 0028 7B62     	 str r3,[r7,#36]
 1367              	.L93:
 1368              	.LBE133:
 1369              	.LBE132:
 1370              	 .loc 1 963 0 discriminator 1
 1371 002a FEE7     	 b .L93
 1372              	.L92:
 964:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 1373              	 .loc 1 964 0
 1374 002c BB68     	 ldr r3,[r7,#8]
 1375 002e 002B     	 cmp r3,#0
 1376 0030 03D1     	 bne .L94
 1377              	 .loc 1 964 0 is_stmt 0 discriminator 2
 1378 0032 3B6B     	 ldr r3,[r7,#48]
 1379 0034 1B6C     	 ldr r3,[r3,#64]
 1380 0036 002B     	 cmp r3,#0
 1381 0038 01D1     	 bne .L95
 1382              	.L94:
 1383              	 .loc 1 964 0 discriminator 3
 1384 003a 0123     	 movs r3,#1
 1385 003c 00E0     	 b .L96
 1386              	.L95:
 1387              	 .loc 1 964 0 discriminator 4
 1388 003e 0023     	 movs r3,#0
 1389              	.L96:
 1390              	 .loc 1 964 0 discriminator 6
 1391 0040 002B     	 cmp r3,#0
 1392 0042 09D1     	 bne .L97
 1393              	.LBB134:
 1394              	.LBB135:
 1395              	 .loc 2 195 0 is_stmt 1 discriminator 7
 1396              	
 1397 0044 4FF0FC03 	 mov r3,#252
 1398 0048 83F31188 	 msr basepri,r3
 1399 004c BFF36F8F 	 isb 
 1400 0050 BFF34F8F 	 dsb 
 1401              	
 1402              	
 1403              	 .thumb
 1404 0054 3B62     	 str r3,[r7,#32]
 1405              	.L98:
 1406              	.LBE135:
 1407              	.LBE134:
 1408              	 .loc 1 964 0 discriminator 2
 1409 0056 FEE7     	 b .L98
 1410              	.L97:
 965:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1411              	 .loc 1 965 0
 1412 0058 3B68     	 ldr r3,[r7]
 1413 005a 022B     	 cmp r3,#2
 1414 005c 03D1     	 bne .L99
 1415              	 .loc 1 965 0 is_stmt 0 discriminator 2
 1416 005e 3B6B     	 ldr r3,[r7,#48]
 1417 0060 DB6B     	 ldr r3,[r3,#60]
 1418 0062 012B     	 cmp r3,#1
 1419 0064 01D1     	 bne .L100
 1420              	.L99:
 1421              	 .loc 1 965 0 discriminator 3
 1422 0066 0123     	 movs r3,#1
 1423 0068 00E0     	 b .L101
 1424              	.L100:
 1425              	 .loc 1 965 0 discriminator 4
 1426 006a 0023     	 movs r3,#0
 1427              	.L101:
 1428              	 .loc 1 965 0 discriminator 6
 1429 006c 002B     	 cmp r3,#0
 1430 006e 09D1     	 bne .L102
 1431              	.LBB136:
 1432              	.LBB137:
 1433              	 .loc 2 195 0 is_stmt 1 discriminator 7
 1434              	
 1435 0070 4FF0FC03 	 mov r3,#252
 1436 0074 83F31188 	 msr basepri,r3
 1437 0078 BFF36F8F 	 isb 
 1438 007c BFF34F8F 	 dsb 
 1439              	
 1440              	
 1441              	 .thumb
 1442 0080 FB61     	 str r3,[r7,#28]
 1443              	.L103:
 1444              	.LBE137:
 1445              	.LBE136:
 1446              	 .loc 1 965 0 discriminator 3
 1447 0082 FEE7     	 b .L103
 1448              	.L102:
 966:../Dave/Generated/FREERTOS/queue.c **** 
 967:../Dave/Generated/FREERTOS/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
 968:../Dave/Generated/FREERTOS/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
 969:../Dave/Generated/FREERTOS/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
 970:../Dave/Generated/FREERTOS/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
 971:../Dave/Generated/FREERTOS/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
 972:../Dave/Generated/FREERTOS/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
 973:../Dave/Generated/FREERTOS/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
 974:../Dave/Generated/FREERTOS/queue.c **** 	assigned a priority above the configured maximum system call priority.
 975:../Dave/Generated/FREERTOS/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
 976:../Dave/Generated/FREERTOS/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
 977:../Dave/Generated/FREERTOS/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
 978:../Dave/Generated/FREERTOS/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
 979:../Dave/Generated/FREERTOS/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
 980:../Dave/Generated/FREERTOS/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
 981:../Dave/Generated/FREERTOS/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 1449              	 .loc 1 981 0
 1450 0084 FFF7FEFF 	 bl vPortValidateInterruptPriority
 1451              	.LBB138:
 1452              	.LBB139:
 196:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 197:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		"	mov %0, %1												\n"	\
 198:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		"	msr basepri, %0											\n" \
 199:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		"	isb														\n" \
 200:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		"	dsb														\n" \
 201:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		:"=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
 202:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	);
 203:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** }
 204:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 205:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*-----------------------------------------------------------*/
 206:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 207:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
 208:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** {
 209:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** uint32_t ulOriginalBASEPRI, ulNewBASEPRI;
 210:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 211:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	__asm volatile
 1453              	 .loc 2 211 0
 1454              	
 1455 0088 EFF31182 	 mrs r2,basepri
 1456 008c 4FF0FC03 	 mov r3,#252
 1457 0090 83F31188 	 msr basepri,r3
 1458 0094 BFF36F8F 	 isb 
 1459 0098 BFF34F8F 	 dsb 
 1460              	
 1461              	
 1462              	 .thumb
 1463 009c BA61     	 str r2,[r7,#24]
 1464 009e 7B61     	 str r3,[r7,#20]
 212:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 213:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		"	mrs %0, basepri											\n" \
 214:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		"	mov %1, %2												\n"	\
 215:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		"	msr basepri, %1											\n" \
 216:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		"	isb														\n" \
 217:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		"	dsb														\n" \
 218:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "
 219:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	);
 220:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 221:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	/* This return will not be reached but is necessary to prevent compiler
 222:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	warnings. */
 223:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	return ulOriginalBASEPRI;
 1465              	 .loc 2 223 0
 1466 00a0 BB69     	 ldr r3,[r7,#24]
 1467              	.LBE139:
 1468              	.LBE138:
 982:../Dave/Generated/FREERTOS/queue.c **** 
 983:../Dave/Generated/FREERTOS/queue.c **** 	/* Similar to xQueueGenericSend, except without blocking if there is no room
 984:../Dave/Generated/FREERTOS/queue.c **** 	in the queue.  Also don't directly wake a task that was blocked on a queue
 985:../Dave/Generated/FREERTOS/queue.c **** 	read, instead return a flag to say whether a context switch is required or
 986:../Dave/Generated/FREERTOS/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
 987:../Dave/Generated/FREERTOS/queue.c **** 	post). */
 988:../Dave/Generated/FREERTOS/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1469              	 .loc 1 988 0
 1470 00a2 FB62     	 str r3,[r7,#44]
 989:../Dave/Generated/FREERTOS/queue.c **** 	{
 990:../Dave/Generated/FREERTOS/queue.c **** 		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 1471              	 .loc 1 990 0
 1472 00a4 3B6B     	 ldr r3,[r7,#48]
 1473 00a6 9A6B     	 ldr r2,[r3,#56]
 1474 00a8 3B6B     	 ldr r3,[r7,#48]
 1475 00aa DB6B     	 ldr r3,[r3,#60]
 1476 00ac 9A42     	 cmp r2,r3
 1477 00ae 02D3     	 bcc .L105
 1478              	 .loc 1 990 0 is_stmt 0 discriminator 1
 1479 00b0 3B68     	 ldr r3,[r7]
 1480 00b2 022B     	 cmp r3,#2
 1481 00b4 3ED1     	 bne .L106
 1482              	.L105:
 1483              	.LBB140:
 991:../Dave/Generated/FREERTOS/queue.c **** 		{
 992:../Dave/Generated/FREERTOS/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 1484              	 .loc 1 992 0 is_stmt 1
 1485 00b6 3B6B     	 ldr r3,[r7,#48]
 1486 00b8 93F84530 	 ldrb r3,[r3,#69]
 1487 00bc 87F82B30 	 strb r3,[r7,#43]
 993:../Dave/Generated/FREERTOS/queue.c **** 
 994:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
 995:../Dave/Generated/FREERTOS/queue.c **** 
 996:../Dave/Generated/FREERTOS/queue.c **** 			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
 997:../Dave/Generated/FREERTOS/queue.c **** 			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
 998:../Dave/Generated/FREERTOS/queue.c **** 			in a task disinheriting a priority and prvCopyDataToQueue() can be
 999:../Dave/Generated/FREERTOS/queue.c **** 			called here even though the disinherit function does not check if
1000:../Dave/Generated/FREERTOS/queue.c **** 			the scheduler is suspended before accessing the ready lists. */
1001:../Dave/Generated/FREERTOS/queue.c **** 			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 1488              	 .loc 1 1001 0
 1489 00c0 386B     	 ldr r0,[r7,#48]
 1490 00c2 B968     	 ldr r1,[r7,#8]
 1491 00c4 3A68     	 ldr r2,[r7]
 1492 00c6 FFF7FEFF 	 bl prvCopyDataToQueue
1002:../Dave/Generated/FREERTOS/queue.c **** 
1003:../Dave/Generated/FREERTOS/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
1004:../Dave/Generated/FREERTOS/queue.c **** 			be done when the queue is unlocked later. */
1005:../Dave/Generated/FREERTOS/queue.c **** 			if( cTxLock == queueUNLOCKED )
 1493              	 .loc 1 1005 0
 1494 00ca 97F92B30 	 ldrsb r3,[r7,#43]
 1495 00ce B3F1FF3F 	 cmp r3,#-1
 1496 00d2 24D1     	 bne .L107
1006:../Dave/Generated/FREERTOS/queue.c **** 			{
1007:../Dave/Generated/FREERTOS/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
1008:../Dave/Generated/FREERTOS/queue.c **** 				{
1009:../Dave/Generated/FREERTOS/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 1497              	 .loc 1 1009 0
 1498 00d4 3B6B     	 ldr r3,[r7,#48]
 1499 00d6 9B6C     	 ldr r3,[r3,#72]
 1500 00d8 002B     	 cmp r3,#0
 1501 00da 0DD0     	 beq .L108
1010:../Dave/Generated/FREERTOS/queue.c **** 					{
1011:../Dave/Generated/FREERTOS/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
 1502              	 .loc 1 1011 0
 1503 00dc 386B     	 ldr r0,[r7,#48]
 1504 00de 3968     	 ldr r1,[r7]
 1505 00e0 FFF7FEFF 	 bl prvNotifyQueueSetContainer
 1506 00e4 0346     	 mov r3,r0
 1507 00e6 002B     	 cmp r3,#0
 1508 00e8 21D0     	 beq .L109
1012:../Dave/Generated/FREERTOS/queue.c **** 						{
1013:../Dave/Generated/FREERTOS/queue.c **** 							/* The queue is a member of a queue set, and posting
1014:../Dave/Generated/FREERTOS/queue.c **** 							to the queue set caused a higher priority task to
1015:../Dave/Generated/FREERTOS/queue.c **** 							unblock.  A context switch is required. */
1016:../Dave/Generated/FREERTOS/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 1509              	 .loc 1 1016 0
 1510 00ea 7B68     	 ldr r3,[r7,#4]
 1511 00ec 002B     	 cmp r3,#0
 1512 00ee 1ED0     	 beq .L109
1017:../Dave/Generated/FREERTOS/queue.c **** 							{
1018:../Dave/Generated/FREERTOS/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 1513              	 .loc 1 1018 0
 1514 00f0 7B68     	 ldr r3,[r7,#4]
 1515 00f2 0122     	 movs r2,#1
 1516 00f4 1A60     	 str r2,[r3]
 1517 00f6 1AE0     	 b .L109
 1518              	.L108:
1019:../Dave/Generated/FREERTOS/queue.c **** 							}
1020:../Dave/Generated/FREERTOS/queue.c **** 							else
1021:../Dave/Generated/FREERTOS/queue.c **** 							{
1022:../Dave/Generated/FREERTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1023:../Dave/Generated/FREERTOS/queue.c **** 							}
1024:../Dave/Generated/FREERTOS/queue.c **** 						}
1025:../Dave/Generated/FREERTOS/queue.c **** 						else
1026:../Dave/Generated/FREERTOS/queue.c **** 						{
1027:../Dave/Generated/FREERTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1028:../Dave/Generated/FREERTOS/queue.c **** 						}
1029:../Dave/Generated/FREERTOS/queue.c **** 					}
1030:../Dave/Generated/FREERTOS/queue.c **** 					else
1031:../Dave/Generated/FREERTOS/queue.c **** 					{
1032:../Dave/Generated/FREERTOS/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1519              	 .loc 1 1032 0
 1520 00f8 3B6B     	 ldr r3,[r7,#48]
 1521 00fa 5B6A     	 ldr r3,[r3,#36]
 1522 00fc 002B     	 cmp r3,#0
 1523 00fe 16D0     	 beq .L109
1033:../Dave/Generated/FREERTOS/queue.c **** 						{
1034:../Dave/Generated/FREERTOS/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1524              	 .loc 1 1034 0
 1525 0100 3B6B     	 ldr r3,[r7,#48]
 1526 0102 2433     	 adds r3,r3,#36
 1527 0104 1846     	 mov r0,r3
 1528 0106 FFF7FEFF 	 bl xTaskRemoveFromEventList
 1529 010a 0346     	 mov r3,r0
 1530 010c 002B     	 cmp r3,#0
 1531 010e 0ED0     	 beq .L109
1035:../Dave/Generated/FREERTOS/queue.c **** 							{
1036:../Dave/Generated/FREERTOS/queue.c **** 								/* The task waiting has a higher priority so
1037:../Dave/Generated/FREERTOS/queue.c **** 								record that a context switch is required. */
1038:../Dave/Generated/FREERTOS/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
 1532              	 .loc 1 1038 0
 1533 0110 7B68     	 ldr r3,[r7,#4]
 1534 0112 002B     	 cmp r3,#0
 1535 0114 0BD0     	 beq .L109
1039:../Dave/Generated/FREERTOS/queue.c **** 								{
1040:../Dave/Generated/FREERTOS/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
 1536              	 .loc 1 1040 0
 1537 0116 7B68     	 ldr r3,[r7,#4]
 1538 0118 0122     	 movs r2,#1
 1539 011a 1A60     	 str r2,[r3]
 1540 011c 07E0     	 b .L109
 1541              	.L107:
1041:../Dave/Generated/FREERTOS/queue.c **** 								}
1042:../Dave/Generated/FREERTOS/queue.c **** 								else
1043:../Dave/Generated/FREERTOS/queue.c **** 								{
1044:../Dave/Generated/FREERTOS/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1045:../Dave/Generated/FREERTOS/queue.c **** 								}
1046:../Dave/Generated/FREERTOS/queue.c **** 							}
1047:../Dave/Generated/FREERTOS/queue.c **** 							else
1048:../Dave/Generated/FREERTOS/queue.c **** 							{
1049:../Dave/Generated/FREERTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1050:../Dave/Generated/FREERTOS/queue.c **** 							}
1051:../Dave/Generated/FREERTOS/queue.c **** 						}
1052:../Dave/Generated/FREERTOS/queue.c **** 						else
1053:../Dave/Generated/FREERTOS/queue.c **** 						{
1054:../Dave/Generated/FREERTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1055:../Dave/Generated/FREERTOS/queue.c **** 						}
1056:../Dave/Generated/FREERTOS/queue.c **** 					}
1057:../Dave/Generated/FREERTOS/queue.c **** 				}
1058:../Dave/Generated/FREERTOS/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1059:../Dave/Generated/FREERTOS/queue.c **** 				{
1060:../Dave/Generated/FREERTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1061:../Dave/Generated/FREERTOS/queue.c **** 					{
1062:../Dave/Generated/FREERTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1063:../Dave/Generated/FREERTOS/queue.c **** 						{
1064:../Dave/Generated/FREERTOS/queue.c **** 							/* The task waiting has a higher priority so record that a
1065:../Dave/Generated/FREERTOS/queue.c **** 							context	switch is required. */
1066:../Dave/Generated/FREERTOS/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1067:../Dave/Generated/FREERTOS/queue.c **** 							{
1068:../Dave/Generated/FREERTOS/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1069:../Dave/Generated/FREERTOS/queue.c **** 							}
1070:../Dave/Generated/FREERTOS/queue.c **** 							else
1071:../Dave/Generated/FREERTOS/queue.c **** 							{
1072:../Dave/Generated/FREERTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1073:../Dave/Generated/FREERTOS/queue.c **** 							}
1074:../Dave/Generated/FREERTOS/queue.c **** 						}
1075:../Dave/Generated/FREERTOS/queue.c **** 						else
1076:../Dave/Generated/FREERTOS/queue.c **** 						{
1077:../Dave/Generated/FREERTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1078:../Dave/Generated/FREERTOS/queue.c **** 						}
1079:../Dave/Generated/FREERTOS/queue.c **** 					}
1080:../Dave/Generated/FREERTOS/queue.c **** 					else
1081:../Dave/Generated/FREERTOS/queue.c **** 					{
1082:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1083:../Dave/Generated/FREERTOS/queue.c **** 					}
1084:../Dave/Generated/FREERTOS/queue.c **** 				}
1085:../Dave/Generated/FREERTOS/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1086:../Dave/Generated/FREERTOS/queue.c **** 			}
1087:../Dave/Generated/FREERTOS/queue.c **** 			else
1088:../Dave/Generated/FREERTOS/queue.c **** 			{
1089:../Dave/Generated/FREERTOS/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1090:../Dave/Generated/FREERTOS/queue.c **** 				knows that data was posted while it was locked. */
1091:../Dave/Generated/FREERTOS/queue.c **** 				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 1542              	 .loc 1 1091 0
 1543 011e 97F82B30 	 ldrb r3,[r7,#43]
 1544 0122 0133     	 adds r3,r3,#1
 1545 0124 DBB2     	 uxtb r3,r3
 1546 0126 DAB2     	 uxtb r2,r3
 1547 0128 3B6B     	 ldr r3,[r7,#48]
 1548 012a 83F84520 	 strb r2,[r3,#69]
 1549              	.L109:
1092:../Dave/Generated/FREERTOS/queue.c **** 			}
1093:../Dave/Generated/FREERTOS/queue.c **** 
1094:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdPASS;
 1550              	 .loc 1 1094 0
 1551 012e 0123     	 movs r3,#1
 1552 0130 7B63     	 str r3,[r7,#52]
 1553              	.LBE140:
 991:../Dave/Generated/FREERTOS/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 1554              	 .loc 1 991 0
 1555 0132 01E0     	 b .L110
 1556              	.L106:
1095:../Dave/Generated/FREERTOS/queue.c **** 		}
1096:../Dave/Generated/FREERTOS/queue.c **** 		else
1097:../Dave/Generated/FREERTOS/queue.c **** 		{
1098:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1099:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = errQUEUE_FULL;
 1557              	 .loc 1 1099 0
 1558 0134 0023     	 movs r3,#0
 1559 0136 7B63     	 str r3,[r7,#52]
 1560              	.L110:
 1561 0138 FB6A     	 ldr r3,[r7,#44]
 1562 013a 3B61     	 str r3,[r7,#16]
 1563              	.LBB141:
 1564              	.LBB142:
 224:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** }
 225:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** /*-----------------------------------------------------------*/
 226:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 
 227:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
 228:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** {
 229:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	__asm volatile
 1565              	 .loc 2 229 0
 1566 013c 3B69     	 ldr r3,[r7,#16]
 1567              	
 1568 013e 83F31188 	 msr basepri,r3
 1569              	
 1570              	 .thumb
 1571              	.LBE142:
 1572              	.LBE141:
1100:../Dave/Generated/FREERTOS/queue.c **** 		}
1101:../Dave/Generated/FREERTOS/queue.c **** 	}
1102:../Dave/Generated/FREERTOS/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1103:../Dave/Generated/FREERTOS/queue.c **** 
1104:../Dave/Generated/FREERTOS/queue.c **** 	return xReturn;
 1573              	 .loc 1 1104 0
 1574 0142 7B6B     	 ldr r3,[r7,#52]
1105:../Dave/Generated/FREERTOS/queue.c **** }
 1575              	 .loc 1 1105 0
 1576 0144 1846     	 mov r0,r3
 1577 0146 3837     	 adds r7,r7,#56
 1578              	.LCFI59:
 1579              	 .cfi_def_cfa_offset 8
 1580 0148 BD46     	 mov sp,r7
 1581              	.LCFI60:
 1582              	 .cfi_def_cfa_register 13
 1583              	 
 1584 014a 80BD     	 pop {r7,pc}
 1585              	 .cfi_endproc
 1586              	.LFE148:
 1588              	 .section .text.xQueueGiveFromISR,"ax",%progbits
 1589              	 .align 2
 1590              	 .global xQueueGiveFromISR
 1591              	 .thumb
 1592              	 .thumb_func
 1594              	xQueueGiveFromISR:
 1595              	.LFB149:
1106:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
1107:../Dave/Generated/FREERTOS/queue.c **** 
1108:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
1109:../Dave/Generated/FREERTOS/queue.c **** {
 1596              	 .loc 1 1109 0
 1597              	 .cfi_startproc
 1598              	 
 1599              	 
 1600 0000 80B5     	 push {r7,lr}
 1601              	.LCFI61:
 1602              	 .cfi_def_cfa_offset 8
 1603              	 .cfi_offset 7,-8
 1604              	 .cfi_offset 14,-4
 1605 0002 8EB0     	 sub sp,sp,#56
 1606              	.LCFI62:
 1607              	 .cfi_def_cfa_offset 64
 1608 0004 00AF     	 add r7,sp,#0
 1609              	.LCFI63:
 1610              	 .cfi_def_cfa_register 7
 1611 0006 7860     	 str r0,[r7,#4]
 1612 0008 3960     	 str r1,[r7]
1110:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xReturn;
1111:../Dave/Generated/FREERTOS/queue.c **** UBaseType_t uxSavedInterruptStatus;
1112:../Dave/Generated/FREERTOS/queue.c **** Queue_t * const pxQueue = xQueue;
 1613              	 .loc 1 1112 0
 1614 000a 7B68     	 ldr r3,[r7,#4]
 1615 000c 3B63     	 str r3,[r7,#48]
1113:../Dave/Generated/FREERTOS/queue.c **** 
1114:../Dave/Generated/FREERTOS/queue.c **** 	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
1115:../Dave/Generated/FREERTOS/queue.c **** 	item size is 0.  Don't directly wake a task that was blocked on a queue
1116:../Dave/Generated/FREERTOS/queue.c **** 	read, instead return a flag to say whether a context switch is required or
1117:../Dave/Generated/FREERTOS/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
1118:../Dave/Generated/FREERTOS/queue.c **** 	post). */
1119:../Dave/Generated/FREERTOS/queue.c **** 
1120:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue );
 1616              	 .loc 1 1120 0
 1617 000e 3B6B     	 ldr r3,[r7,#48]
 1618 0010 002B     	 cmp r3,#0
 1619 0012 09D1     	 bne .L113
 1620              	.LBB143:
 1621              	.LBB144:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 1622              	 .loc 2 195 0 discriminator 1
 1623              	
 1624 0014 4FF0FC03 	 mov r3,#252
 1625 0018 83F31188 	 msr basepri,r3
 1626 001c BFF36F8F 	 isb 
 1627 0020 BFF34F8F 	 dsb 
 1628              	
 1629              	
 1630              	 .thumb
 1631 0024 3B62     	 str r3,[r7,#32]
 1632              	.L114:
 1633              	.LBE144:
 1634              	.LBE143:
 1635              	 .loc 1 1120 0 discriminator 1
 1636 0026 FEE7     	 b .L114
 1637              	.L113:
1121:../Dave/Generated/FREERTOS/queue.c **** 
1122:../Dave/Generated/FREERTOS/queue.c **** 	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
1123:../Dave/Generated/FREERTOS/queue.c **** 	if the item size is not 0. */
1124:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue->uxItemSize == 0 );
 1638              	 .loc 1 1124 0
 1639 0028 3B6B     	 ldr r3,[r7,#48]
 1640 002a 1B6C     	 ldr r3,[r3,#64]
 1641 002c 002B     	 cmp r3,#0
 1642 002e 09D0     	 beq .L115
 1643              	.LBB145:
 1644              	.LBB146:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 1645              	 .loc 2 195 0 discriminator 1
 1646              	
 1647 0030 4FF0FC03 	 mov r3,#252
 1648 0034 83F31188 	 msr basepri,r3
 1649 0038 BFF36F8F 	 isb 
 1650 003c BFF34F8F 	 dsb 
 1651              	
 1652              	
 1653              	 .thumb
 1654 0040 FB61     	 str r3,[r7,#28]
 1655              	.L116:
 1656              	.LBE146:
 1657              	.LBE145:
 1658              	 .loc 1 1124 0 discriminator 2
 1659 0042 FEE7     	 b .L116
 1660              	.L115:
1125:../Dave/Generated/FREERTOS/queue.c **** 
1126:../Dave/Generated/FREERTOS/queue.c **** 	/* Normally a mutex would not be given from an interrupt, especially if
1127:../Dave/Generated/FREERTOS/queue.c **** 	there is a mutex holder, as priority inheritance makes no sense for an
1128:../Dave/Generated/FREERTOS/queue.c **** 	interrupts, only tasks. */
1129:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutex
 1661              	 .loc 1 1129 0
 1662 0044 3B6B     	 ldr r3,[r7,#48]
 1663 0046 1B68     	 ldr r3,[r3]
 1664 0048 002B     	 cmp r3,#0
 1665 004a 03D1     	 bne .L117
 1666              	 .loc 1 1129 0 is_stmt 0 discriminator 2
 1667 004c 3B6B     	 ldr r3,[r7,#48]
 1668 004e 9B68     	 ldr r3,[r3,#8]
 1669 0050 002B     	 cmp r3,#0
 1670 0052 01D1     	 bne .L118
 1671              	.L117:
 1672              	 .loc 1 1129 0 discriminator 3
 1673 0054 0123     	 movs r3,#1
 1674 0056 00E0     	 b .L119
 1675              	.L118:
 1676              	 .loc 1 1129 0 discriminator 4
 1677 0058 0023     	 movs r3,#0
 1678              	.L119:
 1679              	 .loc 1 1129 0 discriminator 6
 1680 005a 002B     	 cmp r3,#0
 1681 005c 09D1     	 bne .L120
 1682              	.LBB147:
 1683              	.LBB148:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 1684              	 .loc 2 195 0 is_stmt 1 discriminator 7
 1685              	
 1686 005e 4FF0FC03 	 mov r3,#252
 1687 0062 83F31188 	 msr basepri,r3
 1688 0066 BFF36F8F 	 isb 
 1689 006a BFF34F8F 	 dsb 
 1690              	
 1691              	
 1692              	 .thumb
 1693 006e BB61     	 str r3,[r7,#24]
 1694              	.L121:
 1695              	.LBE148:
 1696              	.LBE147:
 1697              	 .loc 1 1129 0 discriminator 3
 1698 0070 FEE7     	 b .L121
 1699              	.L120:
1130:../Dave/Generated/FREERTOS/queue.c **** 
1131:../Dave/Generated/FREERTOS/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1132:../Dave/Generated/FREERTOS/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1133:../Dave/Generated/FREERTOS/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1134:../Dave/Generated/FREERTOS/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1135:../Dave/Generated/FREERTOS/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1136:../Dave/Generated/FREERTOS/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1137:../Dave/Generated/FREERTOS/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1138:../Dave/Generated/FREERTOS/queue.c **** 	assigned a priority above the configured maximum system call priority.
1139:../Dave/Generated/FREERTOS/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1140:../Dave/Generated/FREERTOS/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1141:../Dave/Generated/FREERTOS/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1142:../Dave/Generated/FREERTOS/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1143:../Dave/Generated/FREERTOS/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1144:../Dave/Generated/FREERTOS/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1145:../Dave/Generated/FREERTOS/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 1700              	 .loc 1 1145 0
 1701 0072 FFF7FEFF 	 bl vPortValidateInterruptPriority
 1702              	.LBB149:
 1703              	.LBB150:
 211:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 1704              	 .loc 2 211 0
 1705              	
 1706 0076 EFF31182 	 mrs r2,basepri
 1707 007a 4FF0FC03 	 mov r3,#252
 1708 007e 83F31188 	 msr basepri,r3
 1709 0082 BFF36F8F 	 isb 
 1710 0086 BFF34F8F 	 dsb 
 1711              	
 1712              	
 1713              	 .thumb
 1714 008a 7A61     	 str r2,[r7,#20]
 1715 008c 3B61     	 str r3,[r7,#16]
 223:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** }
 1716              	 .loc 2 223 0
 1717 008e 7B69     	 ldr r3,[r7,#20]
 1718              	.LBE150:
 1719              	.LBE149:
1146:../Dave/Generated/FREERTOS/queue.c **** 
1147:../Dave/Generated/FREERTOS/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1720              	 .loc 1 1147 0
 1721 0090 FB62     	 str r3,[r7,#44]
 1722              	.LBB151:
1148:../Dave/Generated/FREERTOS/queue.c **** 	{
1149:../Dave/Generated/FREERTOS/queue.c **** 		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1723              	 .loc 1 1149 0
 1724 0092 3B6B     	 ldr r3,[r7,#48]
 1725 0094 9B6B     	 ldr r3,[r3,#56]
 1726 0096 BB62     	 str r3,[r7,#40]
1150:../Dave/Generated/FREERTOS/queue.c **** 
1151:../Dave/Generated/FREERTOS/queue.c **** 		/* When the queue is used to implement a semaphore no data is ever
1152:../Dave/Generated/FREERTOS/queue.c **** 		moved through the queue but it is still valid to see if the queue 'has
1153:../Dave/Generated/FREERTOS/queue.c **** 		space'. */
1154:../Dave/Generated/FREERTOS/queue.c **** 		if( uxMessagesWaiting < pxQueue->uxLength )
 1727              	 .loc 1 1154 0
 1728 0098 3B6B     	 ldr r3,[r7,#48]
 1729 009a DA6B     	 ldr r2,[r3,#60]
 1730 009c BB6A     	 ldr r3,[r7,#40]
 1731 009e 9A42     	 cmp r2,r3
 1732 00a0 3DD9     	 bls .L123
 1733              	.LBB152:
1155:../Dave/Generated/FREERTOS/queue.c **** 		{
1156:../Dave/Generated/FREERTOS/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 1734              	 .loc 1 1156 0
 1735 00a2 3B6B     	 ldr r3,[r7,#48]
 1736 00a4 93F84530 	 ldrb r3,[r3,#69]
 1737 00a8 87F82730 	 strb r3,[r7,#39]
1157:../Dave/Generated/FREERTOS/queue.c **** 
1158:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
1159:../Dave/Generated/FREERTOS/queue.c **** 
1160:../Dave/Generated/FREERTOS/queue.c **** 			/* A task can only have an inherited priority if it is a mutex
1161:../Dave/Generated/FREERTOS/queue.c **** 			holder - and if there is a mutex holder then the mutex cannot be
1162:../Dave/Generated/FREERTOS/queue.c **** 			given from an ISR.  As this is the ISR version of the function it
1163:../Dave/Generated/FREERTOS/queue.c **** 			can be assumed there is no mutex holder and no need to determine if
1164:../Dave/Generated/FREERTOS/queue.c **** 			priority disinheritance is needed.  Simply increase the count of
1165:../Dave/Generated/FREERTOS/queue.c **** 			messages (semaphores) available. */
1166:../Dave/Generated/FREERTOS/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 1738              	 .loc 1 1166 0
 1739 00ac BB6A     	 ldr r3,[r7,#40]
 1740 00ae 5A1C     	 adds r2,r3,#1
 1741 00b0 3B6B     	 ldr r3,[r7,#48]
 1742 00b2 9A63     	 str r2,[r3,#56]
1167:../Dave/Generated/FREERTOS/queue.c **** 
1168:../Dave/Generated/FREERTOS/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
1169:../Dave/Generated/FREERTOS/queue.c **** 			be done when the queue is unlocked later. */
1170:../Dave/Generated/FREERTOS/queue.c **** 			if( cTxLock == queueUNLOCKED )
 1743              	 .loc 1 1170 0
 1744 00b4 97F92730 	 ldrsb r3,[r7,#39]
 1745 00b8 B3F1FF3F 	 cmp r3,#-1
 1746 00bc 24D1     	 bne .L124
1171:../Dave/Generated/FREERTOS/queue.c **** 			{
1172:../Dave/Generated/FREERTOS/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
1173:../Dave/Generated/FREERTOS/queue.c **** 				{
1174:../Dave/Generated/FREERTOS/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 1747              	 .loc 1 1174 0
 1748 00be 3B6B     	 ldr r3,[r7,#48]
 1749 00c0 9B6C     	 ldr r3,[r3,#72]
 1750 00c2 002B     	 cmp r3,#0
 1751 00c4 0DD0     	 beq .L125
1175:../Dave/Generated/FREERTOS/queue.c **** 					{
1176:../Dave/Generated/FREERTOS/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
 1752              	 .loc 1 1176 0
 1753 00c6 386B     	 ldr r0,[r7,#48]
 1754 00c8 0021     	 movs r1,#0
 1755 00ca FFF7FEFF 	 bl prvNotifyQueueSetContainer
 1756 00ce 0346     	 mov r3,r0
 1757 00d0 002B     	 cmp r3,#0
 1758 00d2 21D0     	 beq .L126
1177:../Dave/Generated/FREERTOS/queue.c **** 						{
1178:../Dave/Generated/FREERTOS/queue.c **** 							/* The semaphore is a member of a queue set, and
1179:../Dave/Generated/FREERTOS/queue.c **** 							posting	to the queue set caused a higher priority
1180:../Dave/Generated/FREERTOS/queue.c **** 							task to	unblock.  A context switch is required. */
1181:../Dave/Generated/FREERTOS/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 1759              	 .loc 1 1181 0
 1760 00d4 3B68     	 ldr r3,[r7]
 1761 00d6 002B     	 cmp r3,#0
 1762 00d8 1ED0     	 beq .L126
1182:../Dave/Generated/FREERTOS/queue.c **** 							{
1183:../Dave/Generated/FREERTOS/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 1763              	 .loc 1 1183 0
 1764 00da 3B68     	 ldr r3,[r7]
 1765 00dc 0122     	 movs r2,#1
 1766 00de 1A60     	 str r2,[r3]
 1767 00e0 1AE0     	 b .L126
 1768              	.L125:
1184:../Dave/Generated/FREERTOS/queue.c **** 							}
1185:../Dave/Generated/FREERTOS/queue.c **** 							else
1186:../Dave/Generated/FREERTOS/queue.c **** 							{
1187:../Dave/Generated/FREERTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1188:../Dave/Generated/FREERTOS/queue.c **** 							}
1189:../Dave/Generated/FREERTOS/queue.c **** 						}
1190:../Dave/Generated/FREERTOS/queue.c **** 						else
1191:../Dave/Generated/FREERTOS/queue.c **** 						{
1192:../Dave/Generated/FREERTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1193:../Dave/Generated/FREERTOS/queue.c **** 						}
1194:../Dave/Generated/FREERTOS/queue.c **** 					}
1195:../Dave/Generated/FREERTOS/queue.c **** 					else
1196:../Dave/Generated/FREERTOS/queue.c **** 					{
1197:../Dave/Generated/FREERTOS/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1769              	 .loc 1 1197 0
 1770 00e2 3B6B     	 ldr r3,[r7,#48]
 1771 00e4 5B6A     	 ldr r3,[r3,#36]
 1772 00e6 002B     	 cmp r3,#0
 1773 00e8 16D0     	 beq .L126
1198:../Dave/Generated/FREERTOS/queue.c **** 						{
1199:../Dave/Generated/FREERTOS/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1774              	 .loc 1 1199 0
 1775 00ea 3B6B     	 ldr r3,[r7,#48]
 1776 00ec 2433     	 adds r3,r3,#36
 1777 00ee 1846     	 mov r0,r3
 1778 00f0 FFF7FEFF 	 bl xTaskRemoveFromEventList
 1779 00f4 0346     	 mov r3,r0
 1780 00f6 002B     	 cmp r3,#0
 1781 00f8 0ED0     	 beq .L126
1200:../Dave/Generated/FREERTOS/queue.c **** 							{
1201:../Dave/Generated/FREERTOS/queue.c **** 								/* The task waiting has a higher priority so
1202:../Dave/Generated/FREERTOS/queue.c **** 								record that a context switch is required. */
1203:../Dave/Generated/FREERTOS/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
 1782              	 .loc 1 1203 0
 1783 00fa 3B68     	 ldr r3,[r7]
 1784 00fc 002B     	 cmp r3,#0
 1785 00fe 0BD0     	 beq .L126
1204:../Dave/Generated/FREERTOS/queue.c **** 								{
1205:../Dave/Generated/FREERTOS/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
 1786              	 .loc 1 1205 0
 1787 0100 3B68     	 ldr r3,[r7]
 1788 0102 0122     	 movs r2,#1
 1789 0104 1A60     	 str r2,[r3]
 1790 0106 07E0     	 b .L126
 1791              	.L124:
1206:../Dave/Generated/FREERTOS/queue.c **** 								}
1207:../Dave/Generated/FREERTOS/queue.c **** 								else
1208:../Dave/Generated/FREERTOS/queue.c **** 								{
1209:../Dave/Generated/FREERTOS/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1210:../Dave/Generated/FREERTOS/queue.c **** 								}
1211:../Dave/Generated/FREERTOS/queue.c **** 							}
1212:../Dave/Generated/FREERTOS/queue.c **** 							else
1213:../Dave/Generated/FREERTOS/queue.c **** 							{
1214:../Dave/Generated/FREERTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1215:../Dave/Generated/FREERTOS/queue.c **** 							}
1216:../Dave/Generated/FREERTOS/queue.c **** 						}
1217:../Dave/Generated/FREERTOS/queue.c **** 						else
1218:../Dave/Generated/FREERTOS/queue.c **** 						{
1219:../Dave/Generated/FREERTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1220:../Dave/Generated/FREERTOS/queue.c **** 						}
1221:../Dave/Generated/FREERTOS/queue.c **** 					}
1222:../Dave/Generated/FREERTOS/queue.c **** 				}
1223:../Dave/Generated/FREERTOS/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1224:../Dave/Generated/FREERTOS/queue.c **** 				{
1225:../Dave/Generated/FREERTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1226:../Dave/Generated/FREERTOS/queue.c **** 					{
1227:../Dave/Generated/FREERTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1228:../Dave/Generated/FREERTOS/queue.c **** 						{
1229:../Dave/Generated/FREERTOS/queue.c **** 							/* The task waiting has a higher priority so record that a
1230:../Dave/Generated/FREERTOS/queue.c **** 							context	switch is required. */
1231:../Dave/Generated/FREERTOS/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1232:../Dave/Generated/FREERTOS/queue.c **** 							{
1233:../Dave/Generated/FREERTOS/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1234:../Dave/Generated/FREERTOS/queue.c **** 							}
1235:../Dave/Generated/FREERTOS/queue.c **** 							else
1236:../Dave/Generated/FREERTOS/queue.c **** 							{
1237:../Dave/Generated/FREERTOS/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1238:../Dave/Generated/FREERTOS/queue.c **** 							}
1239:../Dave/Generated/FREERTOS/queue.c **** 						}
1240:../Dave/Generated/FREERTOS/queue.c **** 						else
1241:../Dave/Generated/FREERTOS/queue.c **** 						{
1242:../Dave/Generated/FREERTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1243:../Dave/Generated/FREERTOS/queue.c **** 						}
1244:../Dave/Generated/FREERTOS/queue.c **** 					}
1245:../Dave/Generated/FREERTOS/queue.c **** 					else
1246:../Dave/Generated/FREERTOS/queue.c **** 					{
1247:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1248:../Dave/Generated/FREERTOS/queue.c **** 					}
1249:../Dave/Generated/FREERTOS/queue.c **** 				}
1250:../Dave/Generated/FREERTOS/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1251:../Dave/Generated/FREERTOS/queue.c **** 			}
1252:../Dave/Generated/FREERTOS/queue.c **** 			else
1253:../Dave/Generated/FREERTOS/queue.c **** 			{
1254:../Dave/Generated/FREERTOS/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1255:../Dave/Generated/FREERTOS/queue.c **** 				knows that data was posted while it was locked. */
1256:../Dave/Generated/FREERTOS/queue.c **** 				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 1792              	 .loc 1 1256 0
 1793 0108 97F82730 	 ldrb r3,[r7,#39]
 1794 010c 0133     	 adds r3,r3,#1
 1795 010e DBB2     	 uxtb r3,r3
 1796 0110 DAB2     	 uxtb r2,r3
 1797 0112 3B6B     	 ldr r3,[r7,#48]
 1798 0114 83F84520 	 strb r2,[r3,#69]
 1799              	.L126:
1257:../Dave/Generated/FREERTOS/queue.c **** 			}
1258:../Dave/Generated/FREERTOS/queue.c **** 
1259:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdPASS;
 1800              	 .loc 1 1259 0
 1801 0118 0123     	 movs r3,#1
 1802 011a 7B63     	 str r3,[r7,#52]
 1803              	.LBE152:
 1804 011c 01E0     	 b .L127
 1805              	.L123:
1260:../Dave/Generated/FREERTOS/queue.c **** 		}
1261:../Dave/Generated/FREERTOS/queue.c **** 		else
1262:../Dave/Generated/FREERTOS/queue.c **** 		{
1263:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1264:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = errQUEUE_FULL;
 1806              	 .loc 1 1264 0
 1807 011e 0023     	 movs r3,#0
 1808 0120 7B63     	 str r3,[r7,#52]
 1809              	.L127:
 1810 0122 FB6A     	 ldr r3,[r7,#44]
 1811 0124 FB60     	 str r3,[r7,#12]
 1812              	.LBE151:
 1813              	.LBB153:
 1814              	.LBB154:
 1815              	 .loc 2 229 0
 1816 0126 FB68     	 ldr r3,[r7,#12]
 1817              	
 1818 0128 83F31188 	 msr basepri,r3
 1819              	
 1820              	 .thumb
 1821              	.LBE154:
 1822              	.LBE153:
1265:../Dave/Generated/FREERTOS/queue.c **** 		}
1266:../Dave/Generated/FREERTOS/queue.c **** 	}
1267:../Dave/Generated/FREERTOS/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1268:../Dave/Generated/FREERTOS/queue.c **** 
1269:../Dave/Generated/FREERTOS/queue.c **** 	return xReturn;
 1823              	 .loc 1 1269 0
 1824 012c 7B6B     	 ldr r3,[r7,#52]
1270:../Dave/Generated/FREERTOS/queue.c **** }
 1825              	 .loc 1 1270 0
 1826 012e 1846     	 mov r0,r3
 1827 0130 3837     	 adds r7,r7,#56
 1828              	.LCFI64:
 1829              	 .cfi_def_cfa_offset 8
 1830 0132 BD46     	 mov sp,r7
 1831              	.LCFI65:
 1832              	 .cfi_def_cfa_register 13
 1833              	 
 1834 0134 80BD     	 pop {r7,pc}
 1835              	 .cfi_endproc
 1836              	.LFE149:
 1838 0136 00BF     	 .section .text.xQueueReceive,"ax",%progbits
 1839              	 .align 2
 1840              	 .global xQueueReceive
 1841              	 .thumb
 1842              	 .thumb_func
 1844              	xQueueReceive:
 1845              	.LFB150:
1271:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
1272:../Dave/Generated/FREERTOS/queue.c **** 
1273:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
1274:../Dave/Generated/FREERTOS/queue.c **** {
 1846              	 .loc 1 1274 0
 1847              	 .cfi_startproc
 1848              	 
 1849              	 
 1850 0000 80B5     	 push {r7,lr}
 1851              	.LCFI66:
 1852              	 .cfi_def_cfa_offset 8
 1853              	 .cfi_offset 7,-8
 1854              	 .cfi_offset 14,-4
 1855 0002 8CB0     	 sub sp,sp,#48
 1856              	.LCFI67:
 1857              	 .cfi_def_cfa_offset 56
 1858 0004 00AF     	 add r7,sp,#0
 1859              	.LCFI68:
 1860              	 .cfi_def_cfa_register 7
 1861 0006 F860     	 str r0,[r7,#12]
 1862 0008 B960     	 str r1,[r7,#8]
 1863 000a 7A60     	 str r2,[r7,#4]
1275:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1864              	 .loc 1 1275 0
 1865 000c 0023     	 movs r3,#0
 1866 000e FB62     	 str r3,[r7,#44]
1276:../Dave/Generated/FREERTOS/queue.c **** TimeOut_t xTimeOut;
1277:../Dave/Generated/FREERTOS/queue.c **** Queue_t * const pxQueue = xQueue;
 1867              	 .loc 1 1277 0
 1868 0010 FB68     	 ldr r3,[r7,#12]
 1869 0012 BB62     	 str r3,[r7,#40]
1278:../Dave/Generated/FREERTOS/queue.c **** 
1279:../Dave/Generated/FREERTOS/queue.c **** 	/* Check the pointer is not NULL. */
1280:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( ( pxQueue ) );
 1870              	 .loc 1 1280 0
 1871 0014 BB6A     	 ldr r3,[r7,#40]
 1872 0016 002B     	 cmp r3,#0
 1873 0018 09D1     	 bne .L130
 1874              	.LBB155:
 1875              	.LBB156:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 1876              	 .loc 2 195 0 discriminator 1
 1877              	
 1878 001a 4FF0FC03 	 mov r3,#252
 1879 001e 83F31188 	 msr basepri,r3
 1880 0022 BFF36F8F 	 isb 
 1881 0026 BFF34F8F 	 dsb 
 1882              	
 1883              	
 1884              	 .thumb
 1885 002a 3B62     	 str r3,[r7,#32]
 1886              	.L131:
 1887              	.LBE156:
 1888              	.LBE155:
 1889              	 .loc 1 1280 0 discriminator 1
 1890 002c FEE7     	 b .L131
 1891              	.L130:
1281:../Dave/Generated/FREERTOS/queue.c **** 
1282:../Dave/Generated/FREERTOS/queue.c **** 	/* The buffer into which data is received can only be NULL if the data size
1283:../Dave/Generated/FREERTOS/queue.c **** 	is zero (so no data is copied into the buffer. */
1284:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) )
 1892              	 .loc 1 1284 0
 1893 002e BB68     	 ldr r3,[r7,#8]
 1894 0030 002B     	 cmp r3,#0
 1895 0032 03D1     	 bne .L132
 1896              	 .loc 1 1284 0 is_stmt 0 discriminator 2
 1897 0034 BB6A     	 ldr r3,[r7,#40]
 1898 0036 1B6C     	 ldr r3,[r3,#64]
 1899 0038 002B     	 cmp r3,#0
 1900 003a 01D1     	 bne .L133
 1901              	.L132:
 1902              	 .loc 1 1284 0 discriminator 3
 1903 003c 0123     	 movs r3,#1
 1904 003e 00E0     	 b .L134
 1905              	.L133:
 1906              	 .loc 1 1284 0 discriminator 4
 1907 0040 0023     	 movs r3,#0
 1908              	.L134:
 1909              	 .loc 1 1284 0 discriminator 6
 1910 0042 002B     	 cmp r3,#0
 1911 0044 09D1     	 bne .L135
 1912              	.LBB157:
 1913              	.LBB158:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 1914              	 .loc 2 195 0 is_stmt 1 discriminator 7
 1915              	
 1916 0046 4FF0FC03 	 mov r3,#252
 1917 004a 83F31188 	 msr basepri,r3
 1918 004e BFF36F8F 	 isb 
 1919 0052 BFF34F8F 	 dsb 
 1920              	
 1921              	
 1922              	 .thumb
 1923 0056 FB61     	 str r3,[r7,#28]
 1924              	.L136:
 1925              	.LBE158:
 1926              	.LBE157:
 1927              	 .loc 1 1284 0 discriminator 2
 1928 0058 FEE7     	 b .L136
 1929              	.L135:
1285:../Dave/Generated/FREERTOS/queue.c **** 
1286:../Dave/Generated/FREERTOS/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1287:../Dave/Generated/FREERTOS/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1288:../Dave/Generated/FREERTOS/queue.c **** 	{
1289:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
 1930              	 .loc 1 1289 0
 1931 005a FFF7FEFF 	 bl xTaskGetSchedulerState
 1932 005e 0346     	 mov r3,r0
 1933 0060 002B     	 cmp r3,#0
 1934 0062 02D1     	 bne .L137
 1935              	 .loc 1 1289 0 is_stmt 0 discriminator 2
 1936 0064 7B68     	 ldr r3,[r7,#4]
 1937 0066 002B     	 cmp r3,#0
 1938 0068 01D1     	 bne .L138
 1939              	.L137:
 1940              	 .loc 1 1289 0 discriminator 3
 1941 006a 0123     	 movs r3,#1
 1942 006c 00E0     	 b .L139
 1943              	.L138:
 1944              	 .loc 1 1289 0 discriminator 4
 1945 006e 0023     	 movs r3,#0
 1946              	.L139:
 1947              	 .loc 1 1289 0 discriminator 6
 1948 0070 002B     	 cmp r3,#0
 1949 0072 09D1     	 bne .L140
 1950              	.LBB159:
 1951              	.LBB160:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 1952              	 .loc 2 195 0 is_stmt 1 discriminator 7
 1953              	
 1954 0074 4FF0FC03 	 mov r3,#252
 1955 0078 83F31188 	 msr basepri,r3
 1956 007c BFF36F8F 	 isb 
 1957 0080 BFF34F8F 	 dsb 
 1958              	
 1959              	
 1960              	 .thumb
 1961 0084 BB61     	 str r3,[r7,#24]
 1962              	.L141:
 1963              	.LBE160:
 1964              	.LBE159:
 1965              	 .loc 1 1289 0 discriminator 3
 1966 0086 FEE7     	 b .L141
 1967              	.L140:
1290:../Dave/Generated/FREERTOS/queue.c **** 	}
1291:../Dave/Generated/FREERTOS/queue.c **** 	#endif
1292:../Dave/Generated/FREERTOS/queue.c **** 
1293:../Dave/Generated/FREERTOS/queue.c **** 
1294:../Dave/Generated/FREERTOS/queue.c **** 	/*lint -save -e904  This function relaxes the coding standard somewhat to
1295:../Dave/Generated/FREERTOS/queue.c **** 	allow return statements within the function itself.  This is done in the
1296:../Dave/Generated/FREERTOS/queue.c **** 	interest of execution time efficiency. */
1297:../Dave/Generated/FREERTOS/queue.c **** 	for( ;; )
1298:../Dave/Generated/FREERTOS/queue.c **** 	{
1299:../Dave/Generated/FREERTOS/queue.c **** 		taskENTER_CRITICAL();
 1968              	 .loc 1 1299 0
 1969 0088 FFF7FEFF 	 bl vPortEnterCritical
 1970              	.LBB161:
1300:../Dave/Generated/FREERTOS/queue.c **** 		{
1301:../Dave/Generated/FREERTOS/queue.c **** 			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1971              	 .loc 1 1301 0
 1972 008c BB6A     	 ldr r3,[r7,#40]
 1973 008e 9B6B     	 ldr r3,[r3,#56]
 1974 0090 7B62     	 str r3,[r7,#36]
1302:../Dave/Generated/FREERTOS/queue.c **** 
1303:../Dave/Generated/FREERTOS/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1304:../Dave/Generated/FREERTOS/queue.c **** 			must be the highest priority task wanting to access the queue. */
1305:../Dave/Generated/FREERTOS/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 1975              	 .loc 1 1305 0
 1976 0092 7B6A     	 ldr r3,[r7,#36]
 1977 0094 002B     	 cmp r3,#0
 1978 0096 1FD0     	 beq .L142
1306:../Dave/Generated/FREERTOS/queue.c **** 			{
1307:../Dave/Generated/FREERTOS/queue.c **** 				/* Data available, remove one item. */
1308:../Dave/Generated/FREERTOS/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 1979              	 .loc 1 1308 0
 1980 0098 B86A     	 ldr r0,[r7,#40]
 1981 009a B968     	 ldr r1,[r7,#8]
 1982 009c FFF7FEFF 	 bl prvCopyDataFromQueue
1309:../Dave/Generated/FREERTOS/queue.c **** 				traceQUEUE_RECEIVE( pxQueue );
1310:../Dave/Generated/FREERTOS/queue.c **** 				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 1983              	 .loc 1 1310 0
 1984 00a0 7B6A     	 ldr r3,[r7,#36]
 1985 00a2 5A1E     	 subs r2,r3,#1
 1986 00a4 BB6A     	 ldr r3,[r7,#40]
 1987 00a6 9A63     	 str r2,[r3,#56]
1311:../Dave/Generated/FREERTOS/queue.c **** 
1312:../Dave/Generated/FREERTOS/queue.c **** 				/* There is now space in the queue, were any tasks waiting to
1313:../Dave/Generated/FREERTOS/queue.c **** 				post to the queue?  If so, unblock the highest priority waiting
1314:../Dave/Generated/FREERTOS/queue.c **** 				task. */
1315:../Dave/Generated/FREERTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1988              	 .loc 1 1315 0
 1989 00a8 BB6A     	 ldr r3,[r7,#40]
 1990 00aa 1B69     	 ldr r3,[r3,#16]
 1991 00ac 002B     	 cmp r3,#0
 1992 00ae 0FD0     	 beq .L143
1316:../Dave/Generated/FREERTOS/queue.c **** 				{
1317:../Dave/Generated/FREERTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1993              	 .loc 1 1317 0
 1994 00b0 BB6A     	 ldr r3,[r7,#40]
 1995 00b2 1033     	 adds r3,r3,#16
 1996 00b4 1846     	 mov r0,r3
 1997 00b6 FFF7FEFF 	 bl xTaskRemoveFromEventList
 1998 00ba 0346     	 mov r3,r0
 1999 00bc 002B     	 cmp r3,#0
 2000 00be 07D0     	 beq .L143
1318:../Dave/Generated/FREERTOS/queue.c **** 					{
1319:../Dave/Generated/FREERTOS/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 2001              	 .loc 1 1319 0
 2002 00c0 3E4B     	 ldr r3,.L154
 2003 00c2 4FF08052 	 mov r2,#268435456
 2004 00c6 1A60     	 str r2,[r3]
 2005              	
 2006 00c8 BFF34F8F 	 dsb
 2007              	
 2008              	
 2009 00cc BFF36F8F 	 isb
 2010              	
 2011              	 .thumb
 2012              	.L143:
1320:../Dave/Generated/FREERTOS/queue.c **** 					}
1321:../Dave/Generated/FREERTOS/queue.c **** 					else
1322:../Dave/Generated/FREERTOS/queue.c **** 					{
1323:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1324:../Dave/Generated/FREERTOS/queue.c **** 					}
1325:../Dave/Generated/FREERTOS/queue.c **** 				}
1326:../Dave/Generated/FREERTOS/queue.c **** 				else
1327:../Dave/Generated/FREERTOS/queue.c **** 				{
1328:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1329:../Dave/Generated/FREERTOS/queue.c **** 				}
1330:../Dave/Generated/FREERTOS/queue.c **** 
1331:../Dave/Generated/FREERTOS/queue.c **** 				taskEXIT_CRITICAL();
 2013              	 .loc 1 1331 0
 2014 00d0 FFF7FEFF 	 bl vPortExitCritical
1332:../Dave/Generated/FREERTOS/queue.c **** 				return pdPASS;
 2015              	 .loc 1 1332 0
 2016 00d4 0123     	 movs r3,#1
 2017 00d6 6DE0     	 b .L153
 2018              	.L142:
1333:../Dave/Generated/FREERTOS/queue.c **** 			}
1334:../Dave/Generated/FREERTOS/queue.c **** 			else
1335:../Dave/Generated/FREERTOS/queue.c **** 			{
1336:../Dave/Generated/FREERTOS/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 2019              	 .loc 1 1336 0
 2020 00d8 7B68     	 ldr r3,[r7,#4]
 2021 00da 002B     	 cmp r3,#0
 2022 00dc 03D1     	 bne .L145
1337:../Dave/Generated/FREERTOS/queue.c **** 				{
1338:../Dave/Generated/FREERTOS/queue.c **** 					/* The queue was empty and no block time is specified (or
1339:../Dave/Generated/FREERTOS/queue.c **** 					the block time has expired) so leave now. */
1340:../Dave/Generated/FREERTOS/queue.c **** 					taskEXIT_CRITICAL();
 2023              	 .loc 1 1340 0
 2024 00de FFF7FEFF 	 bl vPortExitCritical
1341:../Dave/Generated/FREERTOS/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1342:../Dave/Generated/FREERTOS/queue.c **** 					return errQUEUE_EMPTY;
 2025              	 .loc 1 1342 0
 2026 00e2 0023     	 movs r3,#0
 2027 00e4 66E0     	 b .L153
 2028              	.L145:
1343:../Dave/Generated/FREERTOS/queue.c **** 				}
1344:../Dave/Generated/FREERTOS/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 2029              	 .loc 1 1344 0
 2030 00e6 FB6A     	 ldr r3,[r7,#44]
 2031 00e8 002B     	 cmp r3,#0
 2032 00ea 06D1     	 bne .L146
1345:../Dave/Generated/FREERTOS/queue.c **** 				{
1346:../Dave/Generated/FREERTOS/queue.c **** 					/* The queue was empty and a block time was specified so
1347:../Dave/Generated/FREERTOS/queue.c **** 					configure the timeout structure. */
1348:../Dave/Generated/FREERTOS/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
 2033              	 .loc 1 1348 0
 2034 00ec 07F11003 	 add r3,r7,#16
 2035 00f0 1846     	 mov r0,r3
 2036 00f2 FFF7FEFF 	 bl vTaskInternalSetTimeOutState
1349:../Dave/Generated/FREERTOS/queue.c **** 					xEntryTimeSet = pdTRUE;
 2037              	 .loc 1 1349 0
 2038 00f6 0123     	 movs r3,#1
 2039 00f8 FB62     	 str r3,[r7,#44]
 2040              	.L146:
 2041              	.LBE161:
1350:../Dave/Generated/FREERTOS/queue.c **** 				}
1351:../Dave/Generated/FREERTOS/queue.c **** 				else
1352:../Dave/Generated/FREERTOS/queue.c **** 				{
1353:../Dave/Generated/FREERTOS/queue.c **** 					/* Entry time was already set. */
1354:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1355:../Dave/Generated/FREERTOS/queue.c **** 				}
1356:../Dave/Generated/FREERTOS/queue.c **** 			}
1357:../Dave/Generated/FREERTOS/queue.c **** 		}
1358:../Dave/Generated/FREERTOS/queue.c **** 		taskEXIT_CRITICAL();
 2042              	 .loc 1 1358 0
 2043 00fa FFF7FEFF 	 bl vPortExitCritical
1359:../Dave/Generated/FREERTOS/queue.c **** 
1360:../Dave/Generated/FREERTOS/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1361:../Dave/Generated/FREERTOS/queue.c **** 		now the critical section has been exited. */
1362:../Dave/Generated/FREERTOS/queue.c **** 
1363:../Dave/Generated/FREERTOS/queue.c **** 		vTaskSuspendAll();
 2044              	 .loc 1 1363 0
 2045 00fe FFF7FEFF 	 bl vTaskSuspendAll
1364:../Dave/Generated/FREERTOS/queue.c **** 		prvLockQueue( pxQueue );
 2046              	 .loc 1 1364 0
 2047 0102 FFF7FEFF 	 bl vPortEnterCritical
 2048 0106 BB6A     	 ldr r3,[r7,#40]
 2049 0108 93F84430 	 ldrb r3,[r3,#68]
 2050 010c DBB2     	 uxtb r3,r3
 2051 010e 5BB2     	 sxtb r3,r3
 2052 0110 B3F1FF3F 	 cmp r3,#-1
 2053 0114 03D1     	 bne .L147
 2054              	 .loc 1 1364 0 is_stmt 0 discriminator 1
 2055 0116 BB6A     	 ldr r3,[r7,#40]
 2056 0118 0022     	 movs r2,#0
 2057 011a 83F84420 	 strb r2,[r3,#68]
 2058              	.L147:
 2059              	 .loc 1 1364 0 discriminator 3
 2060 011e BB6A     	 ldr r3,[r7,#40]
 2061 0120 93F84530 	 ldrb r3,[r3,#69]
 2062 0124 DBB2     	 uxtb r3,r3
 2063 0126 5BB2     	 sxtb r3,r3
 2064 0128 B3F1FF3F 	 cmp r3,#-1
 2065 012c 03D1     	 bne .L148
 2066              	 .loc 1 1364 0 discriminator 4
 2067 012e BB6A     	 ldr r3,[r7,#40]
 2068 0130 0022     	 movs r2,#0
 2069 0132 83F84520 	 strb r2,[r3,#69]
 2070              	.L148:
 2071              	 .loc 1 1364 0 discriminator 6
 2072 0136 FFF7FEFF 	 bl vPortExitCritical
1365:../Dave/Generated/FREERTOS/queue.c **** 
1366:../Dave/Generated/FREERTOS/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1367:../Dave/Generated/FREERTOS/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 2073              	 .loc 1 1367 0 is_stmt 1 discriminator 6
 2074 013a 07F11002 	 add r2,r7,#16
 2075 013e 3B1D     	 adds r3,r7,#4
 2076 0140 1046     	 mov r0,r2
 2077 0142 1946     	 mov r1,r3
 2078 0144 FFF7FEFF 	 bl xTaskCheckForTimeOut
 2079 0148 0346     	 mov r3,r0
 2080 014a 002B     	 cmp r3,#0
 2081 014c 24D1     	 bne .L149
1368:../Dave/Generated/FREERTOS/queue.c **** 		{
1369:../Dave/Generated/FREERTOS/queue.c **** 			/* The timeout has not expired.  If the queue is still empty place
1370:../Dave/Generated/FREERTOS/queue.c **** 			the task on the list of tasks waiting to receive from the queue. */
1371:../Dave/Generated/FREERTOS/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 2082              	 .loc 1 1371 0
 2083 014e B86A     	 ldr r0,[r7,#40]
 2084 0150 FFF7FEFF 	 bl prvIsQueueEmpty
 2085 0154 0346     	 mov r3,r0
 2086 0156 002B     	 cmp r3,#0
 2087 0158 18D0     	 beq .L150
1372:../Dave/Generated/FREERTOS/queue.c **** 			{
1373:../Dave/Generated/FREERTOS/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1374:../Dave/Generated/FREERTOS/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 2088              	 .loc 1 1374 0
 2089 015a BB6A     	 ldr r3,[r7,#40]
 2090 015c 03F12402 	 add r2,r3,#36
 2091 0160 7B68     	 ldr r3,[r7,#4]
 2092 0162 1046     	 mov r0,r2
 2093 0164 1946     	 mov r1,r3
 2094 0166 FFF7FEFF 	 bl vTaskPlaceOnEventList
1375:../Dave/Generated/FREERTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 2095              	 .loc 1 1375 0
 2096 016a B86A     	 ldr r0,[r7,#40]
 2097 016c FFF7FEFF 	 bl prvUnlockQueue
1376:../Dave/Generated/FREERTOS/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 2098              	 .loc 1 1376 0
 2099 0170 FFF7FEFF 	 bl xTaskResumeAll
 2100 0174 0346     	 mov r3,r0
 2101 0176 002B     	 cmp r3,#0
 2102 0178 1BD1     	 bne .L152
1377:../Dave/Generated/FREERTOS/queue.c **** 				{
1378:../Dave/Generated/FREERTOS/queue.c **** 					portYIELD_WITHIN_API();
 2103              	 .loc 1 1378 0
 2104 017a 104B     	 ldr r3,.L154
 2105 017c 4FF08052 	 mov r2,#268435456
 2106 0180 1A60     	 str r2,[r3]
 2107              	
 2108 0182 BFF34F8F 	 dsb
 2109              	
 2110              	
 2111 0186 BFF36F8F 	 isb
 2112              	
 2113              	 .thumb
 2114 018a 12E0     	 b .L152
 2115              	.L150:
1379:../Dave/Generated/FREERTOS/queue.c **** 				}
1380:../Dave/Generated/FREERTOS/queue.c **** 				else
1381:../Dave/Generated/FREERTOS/queue.c **** 				{
1382:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1383:../Dave/Generated/FREERTOS/queue.c **** 				}
1384:../Dave/Generated/FREERTOS/queue.c **** 			}
1385:../Dave/Generated/FREERTOS/queue.c **** 			else
1386:../Dave/Generated/FREERTOS/queue.c **** 			{
1387:../Dave/Generated/FREERTOS/queue.c **** 				/* The queue contains data again.  Loop back to try and read the
1388:../Dave/Generated/FREERTOS/queue.c **** 				data. */
1389:../Dave/Generated/FREERTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 2116              	 .loc 1 1389 0
 2117 018c B86A     	 ldr r0,[r7,#40]
 2118 018e FFF7FEFF 	 bl prvUnlockQueue
1390:../Dave/Generated/FREERTOS/queue.c **** 				( void ) xTaskResumeAll();
 2119              	 .loc 1 1390 0
 2120 0192 FFF7FEFF 	 bl xTaskResumeAll
 2121 0196 77E7     	 b .L140
 2122              	.L149:
1391:../Dave/Generated/FREERTOS/queue.c **** 			}
1392:../Dave/Generated/FREERTOS/queue.c **** 		}
1393:../Dave/Generated/FREERTOS/queue.c **** 		else
1394:../Dave/Generated/FREERTOS/queue.c **** 		{
1395:../Dave/Generated/FREERTOS/queue.c **** 			/* Timed out.  If there is no data in the queue exit, otherwise loop
1396:../Dave/Generated/FREERTOS/queue.c **** 			back and attempt to read the data. */
1397:../Dave/Generated/FREERTOS/queue.c **** 			prvUnlockQueue( pxQueue );
 2123              	 .loc 1 1397 0
 2124 0198 B86A     	 ldr r0,[r7,#40]
 2125 019a FFF7FEFF 	 bl prvUnlockQueue
1398:../Dave/Generated/FREERTOS/queue.c **** 			( void ) xTaskResumeAll();
 2126              	 .loc 1 1398 0
 2127 019e FFF7FEFF 	 bl xTaskResumeAll
1399:../Dave/Generated/FREERTOS/queue.c **** 
1400:../Dave/Generated/FREERTOS/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 2128              	 .loc 1 1400 0
 2129 01a2 B86A     	 ldr r0,[r7,#40]
 2130 01a4 FFF7FEFF 	 bl prvIsQueueEmpty
 2131 01a8 0346     	 mov r3,r0
 2132 01aa 002B     	 cmp r3,#0
 2133 01ac 01D0     	 beq .L152
1401:../Dave/Generated/FREERTOS/queue.c **** 			{
1402:../Dave/Generated/FREERTOS/queue.c **** 				traceQUEUE_RECEIVE_FAILED( pxQueue );
1403:../Dave/Generated/FREERTOS/queue.c **** 				return errQUEUE_EMPTY;
 2134              	 .loc 1 1403 0
 2135 01ae 0023     	 movs r3,#0
 2136 01b0 00E0     	 b .L153
 2137              	.L152:
1404:../Dave/Generated/FREERTOS/queue.c **** 			}
1405:../Dave/Generated/FREERTOS/queue.c **** 			else
1406:../Dave/Generated/FREERTOS/queue.c **** 			{
1407:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1408:../Dave/Generated/FREERTOS/queue.c **** 			}
1409:../Dave/Generated/FREERTOS/queue.c **** 		}
1410:../Dave/Generated/FREERTOS/queue.c **** 	} /*lint -restore */
 2138              	 .loc 1 1410 0 discriminator 5
 2139 01b2 69E7     	 b .L140
 2140              	.L153:
1411:../Dave/Generated/FREERTOS/queue.c **** }
 2141              	 .loc 1 1411 0 discriminator 6
 2142 01b4 1846     	 mov r0,r3
 2143 01b6 3037     	 adds r7,r7,#48
 2144              	.LCFI69:
 2145              	 .cfi_def_cfa_offset 8
 2146 01b8 BD46     	 mov sp,r7
 2147              	.LCFI70:
 2148              	 .cfi_def_cfa_register 13
 2149              	 
 2150 01ba 80BD     	 pop {r7,pc}
 2151              	.L155:
 2152              	 .align 2
 2153              	.L154:
 2154 01bc 04ED00E0 	 .word -536810236
 2155              	 .cfi_endproc
 2156              	.LFE150:
 2158              	 .section .text.xQueueSemaphoreTake,"ax",%progbits
 2159              	 .align 2
 2160              	 .global xQueueSemaphoreTake
 2161              	 .thumb
 2162              	 .thumb_func
 2164              	xQueueSemaphoreTake:
 2165              	.LFB151:
1412:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
1413:../Dave/Generated/FREERTOS/queue.c **** 
1414:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
1415:../Dave/Generated/FREERTOS/queue.c **** {
 2166              	 .loc 1 1415 0
 2167              	 .cfi_startproc
 2168              	 
 2169              	 
 2170 0000 80B5     	 push {r7,lr}
 2171              	.LCFI71:
 2172              	 .cfi_def_cfa_offset 8
 2173              	 .cfi_offset 7,-8
 2174              	 .cfi_offset 14,-4
 2175 0002 8EB0     	 sub sp,sp,#56
 2176              	.LCFI72:
 2177              	 .cfi_def_cfa_offset 64
 2178 0004 00AF     	 add r7,sp,#0
 2179              	.LCFI73:
 2180              	 .cfi_def_cfa_register 7
 2181 0006 7860     	 str r0,[r7,#4]
 2182 0008 3960     	 str r1,[r7]
1416:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 2183              	 .loc 1 1416 0
 2184 000a 0023     	 movs r3,#0
 2185 000c 7B63     	 str r3,[r7,#52]
1417:../Dave/Generated/FREERTOS/queue.c **** TimeOut_t xTimeOut;
1418:../Dave/Generated/FREERTOS/queue.c **** Queue_t * const pxQueue = xQueue;
 2186              	 .loc 1 1418 0
 2187 000e 7B68     	 ldr r3,[r7,#4]
 2188 0010 FB62     	 str r3,[r7,#44]
1419:../Dave/Generated/FREERTOS/queue.c **** 
1420:../Dave/Generated/FREERTOS/queue.c **** #if( configUSE_MUTEXES == 1 )
1421:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xInheritanceOccurred = pdFALSE;
 2189              	 .loc 1 1421 0
 2190 0012 0023     	 movs r3,#0
 2191 0014 3B63     	 str r3,[r7,#48]
1422:../Dave/Generated/FREERTOS/queue.c **** #endif
1423:../Dave/Generated/FREERTOS/queue.c **** 
1424:../Dave/Generated/FREERTOS/queue.c **** 	/* Check the queue pointer is not NULL. */
1425:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( ( pxQueue ) );
 2192              	 .loc 1 1425 0
 2193 0016 FB6A     	 ldr r3,[r7,#44]
 2194 0018 002B     	 cmp r3,#0
 2195 001a 09D1     	 bne .L157
 2196              	.LBB162:
 2197              	.LBB163:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 2198              	 .loc 2 195 0 discriminator 1
 2199              	
 2200 001c 4FF0FC03 	 mov r3,#252
 2201 0020 83F31188 	 msr basepri,r3
 2202 0024 BFF36F8F 	 isb 
 2203 0028 BFF34F8F 	 dsb 
 2204              	
 2205              	
 2206              	 .thumb
 2207 002c 3B62     	 str r3,[r7,#32]
 2208              	.L158:
 2209              	.LBE163:
 2210              	.LBE162:
 2211              	 .loc 1 1425 0 discriminator 1
 2212 002e FEE7     	 b .L158
 2213              	.L157:
1426:../Dave/Generated/FREERTOS/queue.c **** 
1427:../Dave/Generated/FREERTOS/queue.c **** 	/* Check this really is a semaphore, in which case the item size will be
1428:../Dave/Generated/FREERTOS/queue.c **** 	0. */
1429:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue->uxItemSize == 0 );
 2214              	 .loc 1 1429 0
 2215 0030 FB6A     	 ldr r3,[r7,#44]
 2216 0032 1B6C     	 ldr r3,[r3,#64]
 2217 0034 002B     	 cmp r3,#0
 2218 0036 09D0     	 beq .L159
 2219              	.LBB164:
 2220              	.LBB165:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 2221              	 .loc 2 195 0 discriminator 1
 2222              	
 2223 0038 4FF0FC03 	 mov r3,#252
 2224 003c 83F31188 	 msr basepri,r3
 2225 0040 BFF36F8F 	 isb 
 2226 0044 BFF34F8F 	 dsb 
 2227              	
 2228              	
 2229              	 .thumb
 2230 0048 FB61     	 str r3,[r7,#28]
 2231              	.L160:
 2232              	.LBE165:
 2233              	.LBE164:
 2234              	 .loc 1 1429 0 discriminator 2
 2235 004a FEE7     	 b .L160
 2236              	.L159:
1430:../Dave/Generated/FREERTOS/queue.c **** 
1431:../Dave/Generated/FREERTOS/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1432:../Dave/Generated/FREERTOS/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1433:../Dave/Generated/FREERTOS/queue.c **** 	{
1434:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
 2237              	 .loc 1 1434 0
 2238 004c FFF7FEFF 	 bl xTaskGetSchedulerState
 2239 0050 0346     	 mov r3,r0
 2240 0052 002B     	 cmp r3,#0
 2241 0054 02D1     	 bne .L161
 2242              	 .loc 1 1434 0 is_stmt 0 discriminator 2
 2243 0056 3B68     	 ldr r3,[r7]
 2244 0058 002B     	 cmp r3,#0
 2245 005a 01D1     	 bne .L162
 2246              	.L161:
 2247              	 .loc 1 1434 0 discriminator 3
 2248 005c 0123     	 movs r3,#1
 2249 005e 00E0     	 b .L163
 2250              	.L162:
 2251              	 .loc 1 1434 0 discriminator 4
 2252 0060 0023     	 movs r3,#0
 2253              	.L163:
 2254              	 .loc 1 1434 0 discriminator 6
 2255 0062 002B     	 cmp r3,#0
 2256 0064 09D1     	 bne .L164
 2257              	.LBB166:
 2258              	.LBB167:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 2259              	 .loc 2 195 0 is_stmt 1 discriminator 7
 2260              	
 2261 0066 4FF0FC03 	 mov r3,#252
 2262 006a 83F31188 	 msr basepri,r3
 2263 006e BFF36F8F 	 isb 
 2264 0072 BFF34F8F 	 dsb 
 2265              	
 2266              	
 2267              	 .thumb
 2268 0076 BB61     	 str r3,[r7,#24]
 2269              	.L165:
 2270              	.LBE167:
 2271              	.LBE166:
 2272              	 .loc 1 1434 0 discriminator 3
 2273 0078 FEE7     	 b .L165
 2274              	.L164:
1435:../Dave/Generated/FREERTOS/queue.c **** 	}
1436:../Dave/Generated/FREERTOS/queue.c **** 	#endif
1437:../Dave/Generated/FREERTOS/queue.c **** 
1438:../Dave/Generated/FREERTOS/queue.c **** 
1439:../Dave/Generated/FREERTOS/queue.c **** 	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
1440:../Dave/Generated/FREERTOS/queue.c **** 	statements within the function itself.  This is done in the interest
1441:../Dave/Generated/FREERTOS/queue.c **** 	of execution time efficiency. */
1442:../Dave/Generated/FREERTOS/queue.c **** 	for( ;; )
1443:../Dave/Generated/FREERTOS/queue.c **** 	{
1444:../Dave/Generated/FREERTOS/queue.c **** 		taskENTER_CRITICAL();
 2275              	 .loc 1 1444 0
 2276 007a FFF7FEFF 	 bl vPortEnterCritical
 2277              	.LBB168:
1445:../Dave/Generated/FREERTOS/queue.c **** 		{
1446:../Dave/Generated/FREERTOS/queue.c **** 			/* Semaphores are queues with an item size of 0, and where the
1447:../Dave/Generated/FREERTOS/queue.c **** 			number of messages in the queue is the semaphore's count value. */
1448:../Dave/Generated/FREERTOS/queue.c **** 			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 2278              	 .loc 1 1448 0
 2279 007e FB6A     	 ldr r3,[r7,#44]
 2280 0080 9B6B     	 ldr r3,[r3,#56]
 2281 0082 BB62     	 str r3,[r7,#40]
1449:../Dave/Generated/FREERTOS/queue.c **** 
1450:../Dave/Generated/FREERTOS/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1451:../Dave/Generated/FREERTOS/queue.c **** 			must be the highest priority task wanting to access the queue. */
1452:../Dave/Generated/FREERTOS/queue.c **** 			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 2282              	 .loc 1 1452 0
 2283 0084 BB6A     	 ldr r3,[r7,#40]
 2284 0086 002B     	 cmp r3,#0
 2285 0088 24D0     	 beq .L166
1453:../Dave/Generated/FREERTOS/queue.c **** 			{
1454:../Dave/Generated/FREERTOS/queue.c **** 				traceQUEUE_RECEIVE( pxQueue );
1455:../Dave/Generated/FREERTOS/queue.c **** 
1456:../Dave/Generated/FREERTOS/queue.c **** 				/* Semaphores are queues with a data size of zero and where the
1457:../Dave/Generated/FREERTOS/queue.c **** 				messages waiting is the semaphore's count.  Reduce the count. */
1458:../Dave/Generated/FREERTOS/queue.c **** 				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 2286              	 .loc 1 1458 0
 2287 008a BB6A     	 ldr r3,[r7,#40]
 2288 008c 5A1E     	 subs r2,r3,#1
 2289 008e FB6A     	 ldr r3,[r7,#44]
 2290 0090 9A63     	 str r2,[r3,#56]
1459:../Dave/Generated/FREERTOS/queue.c **** 
1460:../Dave/Generated/FREERTOS/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1461:../Dave/Generated/FREERTOS/queue.c **** 				{
1462:../Dave/Generated/FREERTOS/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 2291              	 .loc 1 1462 0
 2292 0092 FB6A     	 ldr r3,[r7,#44]
 2293 0094 1B68     	 ldr r3,[r3]
 2294 0096 002B     	 cmp r3,#0
 2295 0098 04D1     	 bne .L167
1463:../Dave/Generated/FREERTOS/queue.c **** 					{
1464:../Dave/Generated/FREERTOS/queue.c **** 						/* Record the information required to implement
1465:../Dave/Generated/FREERTOS/queue.c **** 						priority inheritance should it become necessary. */
1466:../Dave/Generated/FREERTOS/queue.c **** 						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
 2296              	 .loc 1 1466 0
 2297 009a FFF7FEFF 	 bl pvTaskIncrementMutexHeldCount
 2298 009e 0246     	 mov r2,r0
 2299 00a0 FB6A     	 ldr r3,[r7,#44]
 2300 00a2 9A60     	 str r2,[r3,#8]
 2301              	.L167:
1467:../Dave/Generated/FREERTOS/queue.c **** 					}
1468:../Dave/Generated/FREERTOS/queue.c **** 					else
1469:../Dave/Generated/FREERTOS/queue.c **** 					{
1470:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1471:../Dave/Generated/FREERTOS/queue.c **** 					}
1472:../Dave/Generated/FREERTOS/queue.c **** 				}
1473:../Dave/Generated/FREERTOS/queue.c **** 				#endif /* configUSE_MUTEXES */
1474:../Dave/Generated/FREERTOS/queue.c **** 
1475:../Dave/Generated/FREERTOS/queue.c **** 				/* Check to see if other tasks are blocked waiting to give the
1476:../Dave/Generated/FREERTOS/queue.c **** 				semaphore, and if so, unblock the highest priority such task. */
1477:../Dave/Generated/FREERTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 2302              	 .loc 1 1477 0
 2303 00a4 FB6A     	 ldr r3,[r7,#44]
 2304 00a6 1B69     	 ldr r3,[r3,#16]
 2305 00a8 002B     	 cmp r3,#0
 2306 00aa 0FD0     	 beq .L168
1478:../Dave/Generated/FREERTOS/queue.c **** 				{
1479:../Dave/Generated/FREERTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 2307              	 .loc 1 1479 0
 2308 00ac FB6A     	 ldr r3,[r7,#44]
 2309 00ae 1033     	 adds r3,r3,#16
 2310 00b0 1846     	 mov r0,r3
 2311 00b2 FFF7FEFF 	 bl xTaskRemoveFromEventList
 2312 00b6 0346     	 mov r3,r0
 2313 00b8 002B     	 cmp r3,#0
 2314 00ba 07D0     	 beq .L168
1480:../Dave/Generated/FREERTOS/queue.c **** 					{
1481:../Dave/Generated/FREERTOS/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 2315              	 .loc 1 1481 0
 2316 00bc 544B     	 ldr r3,.L183
 2317 00be 4FF08052 	 mov r2,#268435456
 2318 00c2 1A60     	 str r2,[r3]
 2319              	
 2320 00c4 BFF34F8F 	 dsb
 2321              	
 2322              	
 2323 00c8 BFF36F8F 	 isb
 2324              	
 2325              	 .thumb
 2326              	.L168:
1482:../Dave/Generated/FREERTOS/queue.c **** 					}
1483:../Dave/Generated/FREERTOS/queue.c **** 					else
1484:../Dave/Generated/FREERTOS/queue.c **** 					{
1485:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1486:../Dave/Generated/FREERTOS/queue.c **** 					}
1487:../Dave/Generated/FREERTOS/queue.c **** 				}
1488:../Dave/Generated/FREERTOS/queue.c **** 				else
1489:../Dave/Generated/FREERTOS/queue.c **** 				{
1490:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1491:../Dave/Generated/FREERTOS/queue.c **** 				}
1492:../Dave/Generated/FREERTOS/queue.c **** 
1493:../Dave/Generated/FREERTOS/queue.c **** 				taskEXIT_CRITICAL();
 2327              	 .loc 1 1493 0
 2328 00cc FFF7FEFF 	 bl vPortExitCritical
1494:../Dave/Generated/FREERTOS/queue.c **** 				return pdPASS;
 2329              	 .loc 1 1494 0
 2330 00d0 0123     	 movs r3,#1
 2331 00d2 99E0     	 b .L182
 2332              	.L166:
1495:../Dave/Generated/FREERTOS/queue.c **** 			}
1496:../Dave/Generated/FREERTOS/queue.c **** 			else
1497:../Dave/Generated/FREERTOS/queue.c **** 			{
1498:../Dave/Generated/FREERTOS/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 2333              	 .loc 1 1498 0
 2334 00d4 3B68     	 ldr r3,[r7]
 2335 00d6 002B     	 cmp r3,#0
 2336 00d8 10D1     	 bne .L170
1499:../Dave/Generated/FREERTOS/queue.c **** 				{
1500:../Dave/Generated/FREERTOS/queue.c **** 					/* For inheritance to have occurred there must have been an
1501:../Dave/Generated/FREERTOS/queue.c **** 					initial timeout, and an adjusted timeout cannot become 0, as
1502:../Dave/Generated/FREERTOS/queue.c **** 					if it were 0 the function would have exited. */
1503:../Dave/Generated/FREERTOS/queue.c **** 					#if( configUSE_MUTEXES == 1 )
1504:../Dave/Generated/FREERTOS/queue.c **** 					{
1505:../Dave/Generated/FREERTOS/queue.c **** 						configASSERT( xInheritanceOccurred == pdFALSE );
 2337              	 .loc 1 1505 0
 2338 00da 3B6B     	 ldr r3,[r7,#48]
 2339 00dc 002B     	 cmp r3,#0
 2340 00de 09D0     	 beq .L171
 2341              	.LBB169:
 2342              	.LBB170:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 2343              	 .loc 2 195 0 discriminator 1
 2344              	
 2345 00e0 4FF0FC03 	 mov r3,#252
 2346 00e4 83F31188 	 msr basepri,r3
 2347 00e8 BFF36F8F 	 isb 
 2348 00ec BFF34F8F 	 dsb 
 2349              	
 2350              	
 2351              	 .thumb
 2352 00f0 7B61     	 str r3,[r7,#20]
 2353              	.L172:
 2354              	.LBE170:
 2355              	.LBE169:
 2356              	 .loc 1 1505 0 discriminator 4
 2357 00f2 FEE7     	 b .L172
 2358              	.L171:
1506:../Dave/Generated/FREERTOS/queue.c **** 					}
1507:../Dave/Generated/FREERTOS/queue.c **** 					#endif /* configUSE_MUTEXES */
1508:../Dave/Generated/FREERTOS/queue.c **** 
1509:../Dave/Generated/FREERTOS/queue.c **** 					/* The semaphore count was 0 and no block time is specified
1510:../Dave/Generated/FREERTOS/queue.c **** 					(or the block time has expired) so exit now. */
1511:../Dave/Generated/FREERTOS/queue.c **** 					taskEXIT_CRITICAL();
 2359              	 .loc 1 1511 0
 2360 00f4 FFF7FEFF 	 bl vPortExitCritical
1512:../Dave/Generated/FREERTOS/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1513:../Dave/Generated/FREERTOS/queue.c **** 					return errQUEUE_EMPTY;
 2361              	 .loc 1 1513 0
 2362 00f8 0023     	 movs r3,#0
 2363 00fa 85E0     	 b .L182
 2364              	.L170:
1514:../Dave/Generated/FREERTOS/queue.c **** 				}
1515:../Dave/Generated/FREERTOS/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 2365              	 .loc 1 1515 0
 2366 00fc 7B6B     	 ldr r3,[r7,#52]
 2367 00fe 002B     	 cmp r3,#0
 2368 0100 06D1     	 bne .L173
1516:../Dave/Generated/FREERTOS/queue.c **** 				{
1517:../Dave/Generated/FREERTOS/queue.c **** 					/* The semaphore count was 0 and a block time was specified
1518:../Dave/Generated/FREERTOS/queue.c **** 					so configure the timeout structure ready to block. */
1519:../Dave/Generated/FREERTOS/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
 2369              	 .loc 1 1519 0
 2370 0102 07F10C03 	 add r3,r7,#12
 2371 0106 1846     	 mov r0,r3
 2372 0108 FFF7FEFF 	 bl vTaskInternalSetTimeOutState
1520:../Dave/Generated/FREERTOS/queue.c **** 					xEntryTimeSet = pdTRUE;
 2373              	 .loc 1 1520 0
 2374 010c 0123     	 movs r3,#1
 2375 010e 7B63     	 str r3,[r7,#52]
 2376              	.L173:
 2377              	.LBE168:
1521:../Dave/Generated/FREERTOS/queue.c **** 				}
1522:../Dave/Generated/FREERTOS/queue.c **** 				else
1523:../Dave/Generated/FREERTOS/queue.c **** 				{
1524:../Dave/Generated/FREERTOS/queue.c **** 					/* Entry time was already set. */
1525:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1526:../Dave/Generated/FREERTOS/queue.c **** 				}
1527:../Dave/Generated/FREERTOS/queue.c **** 			}
1528:../Dave/Generated/FREERTOS/queue.c **** 		}
1529:../Dave/Generated/FREERTOS/queue.c **** 		taskEXIT_CRITICAL();
 2378              	 .loc 1 1529 0
 2379 0110 FFF7FEFF 	 bl vPortExitCritical
1530:../Dave/Generated/FREERTOS/queue.c **** 
1531:../Dave/Generated/FREERTOS/queue.c **** 		/* Interrupts and other tasks can give to and take from the semaphore
1532:../Dave/Generated/FREERTOS/queue.c **** 		now the critical section has been exited. */
1533:../Dave/Generated/FREERTOS/queue.c **** 
1534:../Dave/Generated/FREERTOS/queue.c **** 		vTaskSuspendAll();
 2380              	 .loc 1 1534 0
 2381 0114 FFF7FEFF 	 bl vTaskSuspendAll
1535:../Dave/Generated/FREERTOS/queue.c **** 		prvLockQueue( pxQueue );
 2382              	 .loc 1 1535 0
 2383 0118 FFF7FEFF 	 bl vPortEnterCritical
 2384 011c FB6A     	 ldr r3,[r7,#44]
 2385 011e 93F84430 	 ldrb r3,[r3,#68]
 2386 0122 DBB2     	 uxtb r3,r3
 2387 0124 5BB2     	 sxtb r3,r3
 2388 0126 B3F1FF3F 	 cmp r3,#-1
 2389 012a 03D1     	 bne .L174
 2390              	 .loc 1 1535 0 is_stmt 0 discriminator 1
 2391 012c FB6A     	 ldr r3,[r7,#44]
 2392 012e 0022     	 movs r2,#0
 2393 0130 83F84420 	 strb r2,[r3,#68]
 2394              	.L174:
 2395              	 .loc 1 1535 0 discriminator 3
 2396 0134 FB6A     	 ldr r3,[r7,#44]
 2397 0136 93F84530 	 ldrb r3,[r3,#69]
 2398 013a DBB2     	 uxtb r3,r3
 2399 013c 5BB2     	 sxtb r3,r3
 2400 013e B3F1FF3F 	 cmp r3,#-1
 2401 0142 03D1     	 bne .L175
 2402              	 .loc 1 1535 0 discriminator 4
 2403 0144 FB6A     	 ldr r3,[r7,#44]
 2404 0146 0022     	 movs r2,#0
 2405 0148 83F84520 	 strb r2,[r3,#69]
 2406              	.L175:
 2407              	 .loc 1 1535 0 discriminator 6
 2408 014c FFF7FEFF 	 bl vPortExitCritical
1536:../Dave/Generated/FREERTOS/queue.c **** 
1537:../Dave/Generated/FREERTOS/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1538:../Dave/Generated/FREERTOS/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 2409              	 .loc 1 1538 0 is_stmt 1 discriminator 6
 2410 0150 07F10C02 	 add r2,r7,#12
 2411 0154 3B46     	 mov r3,r7
 2412 0156 1046     	 mov r0,r2
 2413 0158 1946     	 mov r1,r3
 2414 015a FFF7FEFF 	 bl xTaskCheckForTimeOut
 2415 015e 0346     	 mov r3,r0
 2416 0160 002B     	 cmp r3,#0
 2417 0162 32D1     	 bne .L176
1539:../Dave/Generated/FREERTOS/queue.c **** 		{
1540:../Dave/Generated/FREERTOS/queue.c **** 			/* A block time is specified and not expired.  If the semaphore
1541:../Dave/Generated/FREERTOS/queue.c **** 			count is 0 then enter the Blocked state to wait for a semaphore to
1542:../Dave/Generated/FREERTOS/queue.c **** 			become available.  As semaphores are implemented with queues the
1543:../Dave/Generated/FREERTOS/queue.c **** 			queue being empty is equivalent to the semaphore count being 0. */
1544:../Dave/Generated/FREERTOS/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 2418              	 .loc 1 1544 0
 2419 0164 F86A     	 ldr r0,[r7,#44]
 2420 0166 FFF7FEFF 	 bl prvIsQueueEmpty
 2421 016a 0346     	 mov r3,r0
 2422 016c 002B     	 cmp r3,#0
 2423 016e 26D0     	 beq .L177
1545:../Dave/Generated/FREERTOS/queue.c **** 			{
1546:../Dave/Generated/FREERTOS/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1547:../Dave/Generated/FREERTOS/queue.c **** 
1548:../Dave/Generated/FREERTOS/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1549:../Dave/Generated/FREERTOS/queue.c **** 				{
1550:../Dave/Generated/FREERTOS/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 2424              	 .loc 1 1550 0
 2425 0170 FB6A     	 ldr r3,[r7,#44]
 2426 0172 1B68     	 ldr r3,[r3]
 2427 0174 002B     	 cmp r3,#0
 2428 0176 09D1     	 bne .L178
1551:../Dave/Generated/FREERTOS/queue.c **** 					{
1552:../Dave/Generated/FREERTOS/queue.c **** 						taskENTER_CRITICAL();
 2429              	 .loc 1 1552 0
 2430 0178 FFF7FEFF 	 bl vPortEnterCritical
1553:../Dave/Generated/FREERTOS/queue.c **** 						{
1554:../Dave/Generated/FREERTOS/queue.c **** 							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
 2431              	 .loc 1 1554 0
 2432 017c FB6A     	 ldr r3,[r7,#44]
 2433 017e 9B68     	 ldr r3,[r3,#8]
 2434 0180 1846     	 mov r0,r3
 2435 0182 FFF7FEFF 	 bl xTaskPriorityInherit
 2436 0186 3863     	 str r0,[r7,#48]
1555:../Dave/Generated/FREERTOS/queue.c **** 						}
1556:../Dave/Generated/FREERTOS/queue.c **** 						taskEXIT_CRITICAL();
 2437              	 .loc 1 1556 0
 2438 0188 FFF7FEFF 	 bl vPortExitCritical
 2439              	.L178:
1557:../Dave/Generated/FREERTOS/queue.c **** 					}
1558:../Dave/Generated/FREERTOS/queue.c **** 					else
1559:../Dave/Generated/FREERTOS/queue.c **** 					{
1560:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1561:../Dave/Generated/FREERTOS/queue.c **** 					}
1562:../Dave/Generated/FREERTOS/queue.c **** 				}
1563:../Dave/Generated/FREERTOS/queue.c **** 				#endif
1564:../Dave/Generated/FREERTOS/queue.c **** 
1565:../Dave/Generated/FREERTOS/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 2440              	 .loc 1 1565 0
 2441 018c FB6A     	 ldr r3,[r7,#44]
 2442 018e 03F12402 	 add r2,r3,#36
 2443 0192 3B68     	 ldr r3,[r7]
 2444 0194 1046     	 mov r0,r2
 2445 0196 1946     	 mov r1,r3
 2446 0198 FFF7FEFF 	 bl vTaskPlaceOnEventList
1566:../Dave/Generated/FREERTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 2447              	 .loc 1 1566 0
 2448 019c F86A     	 ldr r0,[r7,#44]
 2449 019e FFF7FEFF 	 bl prvUnlockQueue
1567:../Dave/Generated/FREERTOS/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 2450              	 .loc 1 1567 0
 2451 01a2 FFF7FEFF 	 bl xTaskResumeAll
 2452 01a6 0346     	 mov r3,r0
 2453 01a8 002B     	 cmp r3,#0
 2454 01aa 2CD1     	 bne .L180
1568:../Dave/Generated/FREERTOS/queue.c **** 				{
1569:../Dave/Generated/FREERTOS/queue.c **** 					portYIELD_WITHIN_API();
 2455              	 .loc 1 1569 0
 2456 01ac 184B     	 ldr r3,.L183
 2457 01ae 4FF08052 	 mov r2,#268435456
 2458 01b2 1A60     	 str r2,[r3]
 2459              	
 2460 01b4 BFF34F8F 	 dsb
 2461              	
 2462              	
 2463 01b8 BFF36F8F 	 isb
 2464              	
 2465              	 .thumb
 2466 01bc 23E0     	 b .L180
 2467              	.L177:
1570:../Dave/Generated/FREERTOS/queue.c **** 				}
1571:../Dave/Generated/FREERTOS/queue.c **** 				else
1572:../Dave/Generated/FREERTOS/queue.c **** 				{
1573:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1574:../Dave/Generated/FREERTOS/queue.c **** 				}
1575:../Dave/Generated/FREERTOS/queue.c **** 			}
1576:../Dave/Generated/FREERTOS/queue.c **** 			else
1577:../Dave/Generated/FREERTOS/queue.c **** 			{
1578:../Dave/Generated/FREERTOS/queue.c **** 				/* There was no timeout and the semaphore count was not 0, so
1579:../Dave/Generated/FREERTOS/queue.c **** 				attempt to take the semaphore again. */
1580:../Dave/Generated/FREERTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 2468              	 .loc 1 1580 0
 2469 01be F86A     	 ldr r0,[r7,#44]
 2470 01c0 FFF7FEFF 	 bl prvUnlockQueue
1581:../Dave/Generated/FREERTOS/queue.c **** 				( void ) xTaskResumeAll();
 2471              	 .loc 1 1581 0
 2472 01c4 FFF7FEFF 	 bl xTaskResumeAll
 2473 01c8 57E7     	 b .L164
 2474              	.L176:
1582:../Dave/Generated/FREERTOS/queue.c **** 			}
1583:../Dave/Generated/FREERTOS/queue.c **** 		}
1584:../Dave/Generated/FREERTOS/queue.c **** 		else
1585:../Dave/Generated/FREERTOS/queue.c **** 		{
1586:../Dave/Generated/FREERTOS/queue.c **** 			/* Timed out. */
1587:../Dave/Generated/FREERTOS/queue.c **** 			prvUnlockQueue( pxQueue );
 2475              	 .loc 1 1587 0
 2476 01ca F86A     	 ldr r0,[r7,#44]
 2477 01cc FFF7FEFF 	 bl prvUnlockQueue
1588:../Dave/Generated/FREERTOS/queue.c **** 			( void ) xTaskResumeAll();
 2478              	 .loc 1 1588 0
 2479 01d0 FFF7FEFF 	 bl xTaskResumeAll
1589:../Dave/Generated/FREERTOS/queue.c **** 
1590:../Dave/Generated/FREERTOS/queue.c **** 			/* If the semaphore count is 0 exit now as the timeout has
1591:../Dave/Generated/FREERTOS/queue.c **** 			expired.  Otherwise return to attempt to take the semaphore that is
1592:../Dave/Generated/FREERTOS/queue.c **** 			known to be available.  As semaphores are implemented by queues the
1593:../Dave/Generated/FREERTOS/queue.c **** 			queue being empty is equivalent to the semaphore count being 0. */
1594:../Dave/Generated/FREERTOS/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 2480              	 .loc 1 1594 0
 2481 01d4 F86A     	 ldr r0,[r7,#44]
 2482 01d6 FFF7FEFF 	 bl prvIsQueueEmpty
 2483 01da 0346     	 mov r3,r0
 2484 01dc 002B     	 cmp r3,#0
 2485 01de 12D0     	 beq .L180
1595:../Dave/Generated/FREERTOS/queue.c **** 			{
1596:../Dave/Generated/FREERTOS/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1597:../Dave/Generated/FREERTOS/queue.c **** 				{
1598:../Dave/Generated/FREERTOS/queue.c **** 					/* xInheritanceOccurred could only have be set if
1599:../Dave/Generated/FREERTOS/queue.c **** 					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
1600:../Dave/Generated/FREERTOS/queue.c **** 					test the mutex type again to check it is actually a mutex. */
1601:../Dave/Generated/FREERTOS/queue.c **** 					if( xInheritanceOccurred != pdFALSE )
 2486              	 .loc 1 1601 0
 2487 01e0 3B6B     	 ldr r3,[r7,#48]
 2488 01e2 002B     	 cmp r3,#0
 2489 01e4 0DD0     	 beq .L181
1602:../Dave/Generated/FREERTOS/queue.c **** 					{
1603:../Dave/Generated/FREERTOS/queue.c **** 						taskENTER_CRITICAL();
 2490              	 .loc 1 1603 0
 2491 01e6 FFF7FEFF 	 bl vPortEnterCritical
 2492              	.LBB171:
1604:../Dave/Generated/FREERTOS/queue.c **** 						{
1605:../Dave/Generated/FREERTOS/queue.c **** 							UBaseType_t uxHighestWaitingPriority;
1606:../Dave/Generated/FREERTOS/queue.c **** 
1607:../Dave/Generated/FREERTOS/queue.c **** 							/* This task blocking on the mutex caused another
1608:../Dave/Generated/FREERTOS/queue.c **** 							task to inherit this task's priority.  Now this task
1609:../Dave/Generated/FREERTOS/queue.c **** 							has timed out the priority should be disinherited
1610:../Dave/Generated/FREERTOS/queue.c **** 							again, but only as low as the next highest priority
1611:../Dave/Generated/FREERTOS/queue.c **** 							task that is waiting for the same mutex. */
1612:../Dave/Generated/FREERTOS/queue.c **** 							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
 2493              	 .loc 1 1612 0
 2494 01ea F86A     	 ldr r0,[r7,#44]
 2495 01ec FFF7FEFF 	 bl prvGetDisinheritPriorityAfterTimeout
 2496 01f0 7862     	 str r0,[r7,#36]
1613:../Dave/Generated/FREERTOS/queue.c **** 							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPri
 2497              	 .loc 1 1613 0
 2498 01f2 FB6A     	 ldr r3,[r7,#44]
 2499 01f4 9B68     	 ldr r3,[r3,#8]
 2500 01f6 1846     	 mov r0,r3
 2501 01f8 796A     	 ldr r1,[r7,#36]
 2502 01fa FFF7FEFF 	 bl vTaskPriorityDisinheritAfterTimeout
 2503              	.LBE171:
1614:../Dave/Generated/FREERTOS/queue.c **** 						}
1615:../Dave/Generated/FREERTOS/queue.c **** 						taskEXIT_CRITICAL();
 2504              	 .loc 1 1615 0
 2505 01fe FFF7FEFF 	 bl vPortExitCritical
 2506              	.L181:
1616:../Dave/Generated/FREERTOS/queue.c **** 					}
1617:../Dave/Generated/FREERTOS/queue.c **** 				}
1618:../Dave/Generated/FREERTOS/queue.c **** 				#endif /* configUSE_MUTEXES */
1619:../Dave/Generated/FREERTOS/queue.c **** 
1620:../Dave/Generated/FREERTOS/queue.c **** 				traceQUEUE_RECEIVE_FAILED( pxQueue );
1621:../Dave/Generated/FREERTOS/queue.c **** 				return errQUEUE_EMPTY;
 2507              	 .loc 1 1621 0
 2508 0202 0023     	 movs r3,#0
 2509 0204 00E0     	 b .L182
 2510              	.L180:
1622:../Dave/Generated/FREERTOS/queue.c **** 			}
1623:../Dave/Generated/FREERTOS/queue.c **** 			else
1624:../Dave/Generated/FREERTOS/queue.c **** 			{
1625:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1626:../Dave/Generated/FREERTOS/queue.c **** 			}
1627:../Dave/Generated/FREERTOS/queue.c **** 		}
1628:../Dave/Generated/FREERTOS/queue.c **** 	} /*lint -restore */
 2511              	 .loc 1 1628 0 discriminator 6
 2512 0206 38E7     	 b .L164
 2513              	.L182:
1629:../Dave/Generated/FREERTOS/queue.c **** }
 2514              	 .loc 1 1629 0 discriminator 7
 2515 0208 1846     	 mov r0,r3
 2516 020a 3837     	 adds r7,r7,#56
 2517              	.LCFI74:
 2518              	 .cfi_def_cfa_offset 8
 2519 020c BD46     	 mov sp,r7
 2520              	.LCFI75:
 2521              	 .cfi_def_cfa_register 13
 2522              	 
 2523 020e 80BD     	 pop {r7,pc}
 2524              	.L184:
 2525              	 .align 2
 2526              	.L183:
 2527 0210 04ED00E0 	 .word -536810236
 2528              	 .cfi_endproc
 2529              	.LFE151:
 2531              	 .section .text.xQueuePeek,"ax",%progbits
 2532              	 .align 2
 2533              	 .global xQueuePeek
 2534              	 .thumb
 2535              	 .thumb_func
 2537              	xQueuePeek:
 2538              	.LFB152:
1630:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
1631:../Dave/Generated/FREERTOS/queue.c **** 
1632:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
1633:../Dave/Generated/FREERTOS/queue.c **** {
 2539              	 .loc 1 1633 0
 2540              	 .cfi_startproc
 2541              	 
 2542              	 
 2543 0000 80B5     	 push {r7,lr}
 2544              	.LCFI76:
 2545              	 .cfi_def_cfa_offset 8
 2546              	 .cfi_offset 7,-8
 2547              	 .cfi_offset 14,-4
 2548 0002 8EB0     	 sub sp,sp,#56
 2549              	.LCFI77:
 2550              	 .cfi_def_cfa_offset 64
 2551 0004 00AF     	 add r7,sp,#0
 2552              	.LCFI78:
 2553              	 .cfi_def_cfa_register 7
 2554 0006 F860     	 str r0,[r7,#12]
 2555 0008 B960     	 str r1,[r7,#8]
 2556 000a 7A60     	 str r2,[r7,#4]
1634:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 2557              	 .loc 1 1634 0
 2558 000c 0023     	 movs r3,#0
 2559 000e 7B63     	 str r3,[r7,#52]
1635:../Dave/Generated/FREERTOS/queue.c **** TimeOut_t xTimeOut;
1636:../Dave/Generated/FREERTOS/queue.c **** int8_t *pcOriginalReadPosition;
1637:../Dave/Generated/FREERTOS/queue.c **** Queue_t * const pxQueue = xQueue;
 2560              	 .loc 1 1637 0
 2561 0010 FB68     	 ldr r3,[r7,#12]
 2562 0012 3B63     	 str r3,[r7,#48]
1638:../Dave/Generated/FREERTOS/queue.c **** 
1639:../Dave/Generated/FREERTOS/queue.c **** 	/* Check the pointer is not NULL. */
1640:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( ( pxQueue ) );
 2563              	 .loc 1 1640 0
 2564 0014 3B6B     	 ldr r3,[r7,#48]
 2565 0016 002B     	 cmp r3,#0
 2566 0018 09D1     	 bne .L186
 2567              	.LBB172:
 2568              	.LBB173:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 2569              	 .loc 2 195 0 discriminator 1
 2570              	
 2571 001a 4FF0FC03 	 mov r3,#252
 2572 001e 83F31188 	 msr basepri,r3
 2573 0022 BFF36F8F 	 isb 
 2574 0026 BFF34F8F 	 dsb 
 2575              	
 2576              	
 2577              	 .thumb
 2578 002a 7B62     	 str r3,[r7,#36]
 2579              	.L187:
 2580              	.LBE173:
 2581              	.LBE172:
 2582              	 .loc 1 1640 0 discriminator 1
 2583 002c FEE7     	 b .L187
 2584              	.L186:
1641:../Dave/Generated/FREERTOS/queue.c **** 
1642:../Dave/Generated/FREERTOS/queue.c **** 	/* The buffer into which data is received can only be NULL if the data size
1643:../Dave/Generated/FREERTOS/queue.c **** 	is zero (so no data is copied into the buffer. */
1644:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) )
 2585              	 .loc 1 1644 0
 2586 002e BB68     	 ldr r3,[r7,#8]
 2587 0030 002B     	 cmp r3,#0
 2588 0032 03D1     	 bne .L188
 2589              	 .loc 1 1644 0 is_stmt 0 discriminator 2
 2590 0034 3B6B     	 ldr r3,[r7,#48]
 2591 0036 1B6C     	 ldr r3,[r3,#64]
 2592 0038 002B     	 cmp r3,#0
 2593 003a 01D1     	 bne .L189
 2594              	.L188:
 2595              	 .loc 1 1644 0 discriminator 3
 2596 003c 0123     	 movs r3,#1
 2597 003e 00E0     	 b .L190
 2598              	.L189:
 2599              	 .loc 1 1644 0 discriminator 4
 2600 0040 0023     	 movs r3,#0
 2601              	.L190:
 2602              	 .loc 1 1644 0 discriminator 6
 2603 0042 002B     	 cmp r3,#0
 2604 0044 09D1     	 bne .L191
 2605              	.LBB174:
 2606              	.LBB175:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 2607              	 .loc 2 195 0 is_stmt 1 discriminator 7
 2608              	
 2609 0046 4FF0FC03 	 mov r3,#252
 2610 004a 83F31188 	 msr basepri,r3
 2611 004e BFF36F8F 	 isb 
 2612 0052 BFF34F8F 	 dsb 
 2613              	
 2614              	
 2615              	 .thumb
 2616 0056 3B62     	 str r3,[r7,#32]
 2617              	.L192:
 2618              	.LBE175:
 2619              	.LBE174:
 2620              	 .loc 1 1644 0 discriminator 2
 2621 0058 FEE7     	 b .L192
 2622              	.L191:
1645:../Dave/Generated/FREERTOS/queue.c **** 
1646:../Dave/Generated/FREERTOS/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1647:../Dave/Generated/FREERTOS/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1648:../Dave/Generated/FREERTOS/queue.c **** 	{
1649:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
 2623              	 .loc 1 1649 0
 2624 005a FFF7FEFF 	 bl xTaskGetSchedulerState
 2625 005e 0346     	 mov r3,r0
 2626 0060 002B     	 cmp r3,#0
 2627 0062 02D1     	 bne .L193
 2628              	 .loc 1 1649 0 is_stmt 0 discriminator 2
 2629 0064 7B68     	 ldr r3,[r7,#4]
 2630 0066 002B     	 cmp r3,#0
 2631 0068 01D1     	 bne .L194
 2632              	.L193:
 2633              	 .loc 1 1649 0 discriminator 3
 2634 006a 0123     	 movs r3,#1
 2635 006c 00E0     	 b .L195
 2636              	.L194:
 2637              	 .loc 1 1649 0 discriminator 4
 2638 006e 0023     	 movs r3,#0
 2639              	.L195:
 2640              	 .loc 1 1649 0 discriminator 6
 2641 0070 002B     	 cmp r3,#0
 2642 0072 09D1     	 bne .L196
 2643              	.LBB176:
 2644              	.LBB177:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 2645              	 .loc 2 195 0 is_stmt 1 discriminator 7
 2646              	
 2647 0074 4FF0FC03 	 mov r3,#252
 2648 0078 83F31188 	 msr basepri,r3
 2649 007c BFF36F8F 	 isb 
 2650 0080 BFF34F8F 	 dsb 
 2651              	
 2652              	
 2653              	 .thumb
 2654 0084 FB61     	 str r3,[r7,#28]
 2655              	.L197:
 2656              	.LBE177:
 2657              	.LBE176:
 2658              	 .loc 1 1649 0 discriminator 3
 2659 0086 FEE7     	 b .L197
 2660              	.L196:
1650:../Dave/Generated/FREERTOS/queue.c **** 	}
1651:../Dave/Generated/FREERTOS/queue.c **** 	#endif
1652:../Dave/Generated/FREERTOS/queue.c **** 
1653:../Dave/Generated/FREERTOS/queue.c **** 
1654:../Dave/Generated/FREERTOS/queue.c **** 	/*lint -save -e904  This function relaxes the coding standard somewhat to
1655:../Dave/Generated/FREERTOS/queue.c **** 	allow return statements within the function itself.  This is done in the
1656:../Dave/Generated/FREERTOS/queue.c **** 	interest of execution time efficiency. */
1657:../Dave/Generated/FREERTOS/queue.c **** 	for( ;; )
1658:../Dave/Generated/FREERTOS/queue.c **** 	{
1659:../Dave/Generated/FREERTOS/queue.c **** 		taskENTER_CRITICAL();
 2661              	 .loc 1 1659 0
 2662 0088 FFF7FEFF 	 bl vPortEnterCritical
 2663              	.LBB178:
1660:../Dave/Generated/FREERTOS/queue.c **** 		{
1661:../Dave/Generated/FREERTOS/queue.c **** 			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 2664              	 .loc 1 1661 0
 2665 008c 3B6B     	 ldr r3,[r7,#48]
 2666 008e 9B6B     	 ldr r3,[r3,#56]
 2667 0090 FB62     	 str r3,[r7,#44]
1662:../Dave/Generated/FREERTOS/queue.c **** 
1663:../Dave/Generated/FREERTOS/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1664:../Dave/Generated/FREERTOS/queue.c **** 			must be the highest priority task wanting to access the queue. */
1665:../Dave/Generated/FREERTOS/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 2668              	 .loc 1 1665 0
 2669 0092 FB6A     	 ldr r3,[r7,#44]
 2670 0094 002B     	 cmp r3,#0
 2671 0096 21D0     	 beq .L198
1666:../Dave/Generated/FREERTOS/queue.c **** 			{
1667:../Dave/Generated/FREERTOS/queue.c **** 				/* Remember the read position so it can be reset after the data
1668:../Dave/Generated/FREERTOS/queue.c **** 				is read from the queue as this function is only peeking the
1669:../Dave/Generated/FREERTOS/queue.c **** 				data, not removing it. */
1670:../Dave/Generated/FREERTOS/queue.c **** 				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 2672              	 .loc 1 1670 0
 2673 0098 3B6B     	 ldr r3,[r7,#48]
 2674 009a DB68     	 ldr r3,[r3,#12]
 2675 009c BB62     	 str r3,[r7,#40]
1671:../Dave/Generated/FREERTOS/queue.c **** 
1672:../Dave/Generated/FREERTOS/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 2676              	 .loc 1 1672 0
 2677 009e 386B     	 ldr r0,[r7,#48]
 2678 00a0 B968     	 ldr r1,[r7,#8]
 2679 00a2 FFF7FEFF 	 bl prvCopyDataFromQueue
1673:../Dave/Generated/FREERTOS/queue.c **** 				traceQUEUE_PEEK( pxQueue );
1674:../Dave/Generated/FREERTOS/queue.c **** 
1675:../Dave/Generated/FREERTOS/queue.c **** 				/* The data is not being removed, so reset the read pointer. */
1676:../Dave/Generated/FREERTOS/queue.c **** 				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 2680              	 .loc 1 1676 0
 2681 00a6 3B6B     	 ldr r3,[r7,#48]
 2682 00a8 BA6A     	 ldr r2,[r7,#40]
 2683 00aa DA60     	 str r2,[r3,#12]
1677:../Dave/Generated/FREERTOS/queue.c **** 
1678:../Dave/Generated/FREERTOS/queue.c **** 				/* The data is being left in the queue, so see if there are
1679:../Dave/Generated/FREERTOS/queue.c **** 				any other tasks waiting for the data. */
1680:../Dave/Generated/FREERTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 2684              	 .loc 1 1680 0
 2685 00ac 3B6B     	 ldr r3,[r7,#48]
 2686 00ae 5B6A     	 ldr r3,[r3,#36]
 2687 00b0 002B     	 cmp r3,#0
 2688 00b2 0FD0     	 beq .L199
1681:../Dave/Generated/FREERTOS/queue.c **** 				{
1682:../Dave/Generated/FREERTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 2689              	 .loc 1 1682 0
 2690 00b4 3B6B     	 ldr r3,[r7,#48]
 2691 00b6 2433     	 adds r3,r3,#36
 2692 00b8 1846     	 mov r0,r3
 2693 00ba FFF7FEFF 	 bl xTaskRemoveFromEventList
 2694 00be 0346     	 mov r3,r0
 2695 00c0 002B     	 cmp r3,#0
 2696 00c2 07D0     	 beq .L199
1683:../Dave/Generated/FREERTOS/queue.c **** 					{
1684:../Dave/Generated/FREERTOS/queue.c **** 						/* The task waiting has a higher priority than this task. */
1685:../Dave/Generated/FREERTOS/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 2697              	 .loc 1 1685 0
 2698 00c4 3E4B     	 ldr r3,.L210
 2699 00c6 4FF08052 	 mov r2,#268435456
 2700 00ca 1A60     	 str r2,[r3]
 2701              	
 2702 00cc BFF34F8F 	 dsb
 2703              	
 2704              	
 2705 00d0 BFF36F8F 	 isb
 2706              	
 2707              	 .thumb
 2708              	.L199:
1686:../Dave/Generated/FREERTOS/queue.c **** 					}
1687:../Dave/Generated/FREERTOS/queue.c **** 					else
1688:../Dave/Generated/FREERTOS/queue.c **** 					{
1689:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1690:../Dave/Generated/FREERTOS/queue.c **** 					}
1691:../Dave/Generated/FREERTOS/queue.c **** 				}
1692:../Dave/Generated/FREERTOS/queue.c **** 				else
1693:../Dave/Generated/FREERTOS/queue.c **** 				{
1694:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1695:../Dave/Generated/FREERTOS/queue.c **** 				}
1696:../Dave/Generated/FREERTOS/queue.c **** 
1697:../Dave/Generated/FREERTOS/queue.c **** 				taskEXIT_CRITICAL();
 2709              	 .loc 1 1697 0
 2710 00d4 FFF7FEFF 	 bl vPortExitCritical
1698:../Dave/Generated/FREERTOS/queue.c **** 				return pdPASS;
 2711              	 .loc 1 1698 0
 2712 00d8 0123     	 movs r3,#1
 2713 00da 6DE0     	 b .L209
 2714              	.L198:
1699:../Dave/Generated/FREERTOS/queue.c **** 			}
1700:../Dave/Generated/FREERTOS/queue.c **** 			else
1701:../Dave/Generated/FREERTOS/queue.c **** 			{
1702:../Dave/Generated/FREERTOS/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 2715              	 .loc 1 1702 0
 2716 00dc 7B68     	 ldr r3,[r7,#4]
 2717 00de 002B     	 cmp r3,#0
 2718 00e0 03D1     	 bne .L201
1703:../Dave/Generated/FREERTOS/queue.c **** 				{
1704:../Dave/Generated/FREERTOS/queue.c **** 					/* The queue was empty and no block time is specified (or
1705:../Dave/Generated/FREERTOS/queue.c **** 					the block time has expired) so leave now. */
1706:../Dave/Generated/FREERTOS/queue.c **** 					taskEXIT_CRITICAL();
 2719              	 .loc 1 1706 0
 2720 00e2 FFF7FEFF 	 bl vPortExitCritical
1707:../Dave/Generated/FREERTOS/queue.c **** 					traceQUEUE_PEEK_FAILED( pxQueue );
1708:../Dave/Generated/FREERTOS/queue.c **** 					return errQUEUE_EMPTY;
 2721              	 .loc 1 1708 0
 2722 00e6 0023     	 movs r3,#0
 2723 00e8 66E0     	 b .L209
 2724              	.L201:
1709:../Dave/Generated/FREERTOS/queue.c **** 				}
1710:../Dave/Generated/FREERTOS/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 2725              	 .loc 1 1710 0
 2726 00ea 7B6B     	 ldr r3,[r7,#52]
 2727 00ec 002B     	 cmp r3,#0
 2728 00ee 06D1     	 bne .L202
1711:../Dave/Generated/FREERTOS/queue.c **** 				{
1712:../Dave/Generated/FREERTOS/queue.c **** 					/* The queue was empty and a block time was specified so
1713:../Dave/Generated/FREERTOS/queue.c **** 					configure the timeout structure ready to enter the blocked
1714:../Dave/Generated/FREERTOS/queue.c **** 					state. */
1715:../Dave/Generated/FREERTOS/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
 2729              	 .loc 1 1715 0
 2730 00f0 07F11403 	 add r3,r7,#20
 2731 00f4 1846     	 mov r0,r3
 2732 00f6 FFF7FEFF 	 bl vTaskInternalSetTimeOutState
1716:../Dave/Generated/FREERTOS/queue.c **** 					xEntryTimeSet = pdTRUE;
 2733              	 .loc 1 1716 0
 2734 00fa 0123     	 movs r3,#1
 2735 00fc 7B63     	 str r3,[r7,#52]
 2736              	.L202:
 2737              	.LBE178:
1717:../Dave/Generated/FREERTOS/queue.c **** 				}
1718:../Dave/Generated/FREERTOS/queue.c **** 				else
1719:../Dave/Generated/FREERTOS/queue.c **** 				{
1720:../Dave/Generated/FREERTOS/queue.c **** 					/* Entry time was already set. */
1721:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1722:../Dave/Generated/FREERTOS/queue.c **** 				}
1723:../Dave/Generated/FREERTOS/queue.c **** 			}
1724:../Dave/Generated/FREERTOS/queue.c **** 		}
1725:../Dave/Generated/FREERTOS/queue.c **** 		taskEXIT_CRITICAL();
 2738              	 .loc 1 1725 0
 2739 00fe FFF7FEFF 	 bl vPortExitCritical
1726:../Dave/Generated/FREERTOS/queue.c **** 
1727:../Dave/Generated/FREERTOS/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1728:../Dave/Generated/FREERTOS/queue.c **** 		now the critical section has been exited. */
1729:../Dave/Generated/FREERTOS/queue.c **** 
1730:../Dave/Generated/FREERTOS/queue.c **** 		vTaskSuspendAll();
 2740              	 .loc 1 1730 0
 2741 0102 FFF7FEFF 	 bl vTaskSuspendAll
1731:../Dave/Generated/FREERTOS/queue.c **** 		prvLockQueue( pxQueue );
 2742              	 .loc 1 1731 0
 2743 0106 FFF7FEFF 	 bl vPortEnterCritical
 2744 010a 3B6B     	 ldr r3,[r7,#48]
 2745 010c 93F84430 	 ldrb r3,[r3,#68]
 2746 0110 DBB2     	 uxtb r3,r3
 2747 0112 5BB2     	 sxtb r3,r3
 2748 0114 B3F1FF3F 	 cmp r3,#-1
 2749 0118 03D1     	 bne .L203
 2750              	 .loc 1 1731 0 is_stmt 0 discriminator 1
 2751 011a 3B6B     	 ldr r3,[r7,#48]
 2752 011c 0022     	 movs r2,#0
 2753 011e 83F84420 	 strb r2,[r3,#68]
 2754              	.L203:
 2755              	 .loc 1 1731 0 discriminator 3
 2756 0122 3B6B     	 ldr r3,[r7,#48]
 2757 0124 93F84530 	 ldrb r3,[r3,#69]
 2758 0128 DBB2     	 uxtb r3,r3
 2759 012a 5BB2     	 sxtb r3,r3
 2760 012c B3F1FF3F 	 cmp r3,#-1
 2761 0130 03D1     	 bne .L204
 2762              	 .loc 1 1731 0 discriminator 4
 2763 0132 3B6B     	 ldr r3,[r7,#48]
 2764 0134 0022     	 movs r2,#0
 2765 0136 83F84520 	 strb r2,[r3,#69]
 2766              	.L204:
 2767              	 .loc 1 1731 0 discriminator 6
 2768 013a FFF7FEFF 	 bl vPortExitCritical
1732:../Dave/Generated/FREERTOS/queue.c **** 
1733:../Dave/Generated/FREERTOS/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1734:../Dave/Generated/FREERTOS/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 2769              	 .loc 1 1734 0 is_stmt 1 discriminator 6
 2770 013e 07F11402 	 add r2,r7,#20
 2771 0142 3B1D     	 adds r3,r7,#4
 2772 0144 1046     	 mov r0,r2
 2773 0146 1946     	 mov r1,r3
 2774 0148 FFF7FEFF 	 bl xTaskCheckForTimeOut
 2775 014c 0346     	 mov r3,r0
 2776 014e 002B     	 cmp r3,#0
 2777 0150 24D1     	 bne .L205
1735:../Dave/Generated/FREERTOS/queue.c **** 		{
1736:../Dave/Generated/FREERTOS/queue.c **** 			/* Timeout has not expired yet, check to see if there is data in the
1737:../Dave/Generated/FREERTOS/queue.c **** 			queue now, and if not enter the Blocked state to wait for data. */
1738:../Dave/Generated/FREERTOS/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 2778              	 .loc 1 1738 0
 2779 0152 386B     	 ldr r0,[r7,#48]
 2780 0154 FFF7FEFF 	 bl prvIsQueueEmpty
 2781 0158 0346     	 mov r3,r0
 2782 015a 002B     	 cmp r3,#0
 2783 015c 18D0     	 beq .L206
1739:../Dave/Generated/FREERTOS/queue.c **** 			{
1740:../Dave/Generated/FREERTOS/queue.c **** 				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
1741:../Dave/Generated/FREERTOS/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 2784              	 .loc 1 1741 0
 2785 015e 3B6B     	 ldr r3,[r7,#48]
 2786 0160 03F12402 	 add r2,r3,#36
 2787 0164 7B68     	 ldr r3,[r7,#4]
 2788 0166 1046     	 mov r0,r2
 2789 0168 1946     	 mov r1,r3
 2790 016a FFF7FEFF 	 bl vTaskPlaceOnEventList
1742:../Dave/Generated/FREERTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 2791              	 .loc 1 1742 0
 2792 016e 386B     	 ldr r0,[r7,#48]
 2793 0170 FFF7FEFF 	 bl prvUnlockQueue
1743:../Dave/Generated/FREERTOS/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 2794              	 .loc 1 1743 0
 2795 0174 FFF7FEFF 	 bl xTaskResumeAll
 2796 0178 0346     	 mov r3,r0
 2797 017a 002B     	 cmp r3,#0
 2798 017c 1BD1     	 bne .L208
1744:../Dave/Generated/FREERTOS/queue.c **** 				{
1745:../Dave/Generated/FREERTOS/queue.c **** 					portYIELD_WITHIN_API();
 2799              	 .loc 1 1745 0
 2800 017e 104B     	 ldr r3,.L210
 2801 0180 4FF08052 	 mov r2,#268435456
 2802 0184 1A60     	 str r2,[r3]
 2803              	
 2804 0186 BFF34F8F 	 dsb
 2805              	
 2806              	
 2807 018a BFF36F8F 	 isb
 2808              	
 2809              	 .thumb
 2810 018e 12E0     	 b .L208
 2811              	.L206:
1746:../Dave/Generated/FREERTOS/queue.c **** 				}
1747:../Dave/Generated/FREERTOS/queue.c **** 				else
1748:../Dave/Generated/FREERTOS/queue.c **** 				{
1749:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1750:../Dave/Generated/FREERTOS/queue.c **** 				}
1751:../Dave/Generated/FREERTOS/queue.c **** 			}
1752:../Dave/Generated/FREERTOS/queue.c **** 			else
1753:../Dave/Generated/FREERTOS/queue.c **** 			{
1754:../Dave/Generated/FREERTOS/queue.c **** 				/* There is data in the queue now, so don't enter the blocked
1755:../Dave/Generated/FREERTOS/queue.c **** 				state, instead return to try and obtain the data. */
1756:../Dave/Generated/FREERTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 2812              	 .loc 1 1756 0
 2813 0190 386B     	 ldr r0,[r7,#48]
 2814 0192 FFF7FEFF 	 bl prvUnlockQueue
1757:../Dave/Generated/FREERTOS/queue.c **** 				( void ) xTaskResumeAll();
 2815              	 .loc 1 1757 0
 2816 0196 FFF7FEFF 	 bl xTaskResumeAll
 2817 019a 75E7     	 b .L196
 2818              	.L205:
1758:../Dave/Generated/FREERTOS/queue.c **** 			}
1759:../Dave/Generated/FREERTOS/queue.c **** 		}
1760:../Dave/Generated/FREERTOS/queue.c **** 		else
1761:../Dave/Generated/FREERTOS/queue.c **** 		{
1762:../Dave/Generated/FREERTOS/queue.c **** 			/* The timeout has expired.  If there is still no data in the queue
1763:../Dave/Generated/FREERTOS/queue.c **** 			exit, otherwise go back and try to read the data again. */
1764:../Dave/Generated/FREERTOS/queue.c **** 			prvUnlockQueue( pxQueue );
 2819              	 .loc 1 1764 0
 2820 019c 386B     	 ldr r0,[r7,#48]
 2821 019e FFF7FEFF 	 bl prvUnlockQueue
1765:../Dave/Generated/FREERTOS/queue.c **** 			( void ) xTaskResumeAll();
 2822              	 .loc 1 1765 0
 2823 01a2 FFF7FEFF 	 bl xTaskResumeAll
1766:../Dave/Generated/FREERTOS/queue.c **** 
1767:../Dave/Generated/FREERTOS/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 2824              	 .loc 1 1767 0
 2825 01a6 386B     	 ldr r0,[r7,#48]
 2826 01a8 FFF7FEFF 	 bl prvIsQueueEmpty
 2827 01ac 0346     	 mov r3,r0
 2828 01ae 002B     	 cmp r3,#0
 2829 01b0 01D0     	 beq .L208
1768:../Dave/Generated/FREERTOS/queue.c **** 			{
1769:../Dave/Generated/FREERTOS/queue.c **** 				traceQUEUE_PEEK_FAILED( pxQueue );
1770:../Dave/Generated/FREERTOS/queue.c **** 				return errQUEUE_EMPTY;
 2830              	 .loc 1 1770 0
 2831 01b2 0023     	 movs r3,#0
 2832 01b4 00E0     	 b .L209
 2833              	.L208:
1771:../Dave/Generated/FREERTOS/queue.c **** 			}
1772:../Dave/Generated/FREERTOS/queue.c **** 			else
1773:../Dave/Generated/FREERTOS/queue.c **** 			{
1774:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1775:../Dave/Generated/FREERTOS/queue.c **** 			}
1776:../Dave/Generated/FREERTOS/queue.c **** 		}
1777:../Dave/Generated/FREERTOS/queue.c **** 	} /*lint -restore */
 2834              	 .loc 1 1777 0 discriminator 5
 2835 01b6 67E7     	 b .L196
 2836              	.L209:
1778:../Dave/Generated/FREERTOS/queue.c **** }
 2837              	 .loc 1 1778 0 discriminator 6
 2838 01b8 1846     	 mov r0,r3
 2839 01ba 3837     	 adds r7,r7,#56
 2840              	.LCFI79:
 2841              	 .cfi_def_cfa_offset 8
 2842 01bc BD46     	 mov sp,r7
 2843              	.LCFI80:
 2844              	 .cfi_def_cfa_register 13
 2845              	 
 2846 01be 80BD     	 pop {r7,pc}
 2847              	.L211:
 2848              	 .align 2
 2849              	.L210:
 2850 01c0 04ED00E0 	 .word -536810236
 2851              	 .cfi_endproc
 2852              	.LFE152:
 2854              	 .section .text.xQueueReceiveFromISR,"ax",%progbits
 2855              	 .align 2
 2856              	 .global xQueueReceiveFromISR
 2857              	 .thumb
 2858              	 .thumb_func
 2860              	xQueueReceiveFromISR:
 2861              	.LFB153:
1779:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
1780:../Dave/Generated/FREERTOS/queue.c **** 
1781:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const px
1782:../Dave/Generated/FREERTOS/queue.c **** {
 2862              	 .loc 1 1782 0
 2863              	 .cfi_startproc
 2864              	 
 2865              	 
 2866 0000 80B5     	 push {r7,lr}
 2867              	.LCFI81:
 2868              	 .cfi_def_cfa_offset 8
 2869              	 .cfi_offset 7,-8
 2870              	 .cfi_offset 14,-4
 2871 0002 8EB0     	 sub sp,sp,#56
 2872              	.LCFI82:
 2873              	 .cfi_def_cfa_offset 64
 2874 0004 00AF     	 add r7,sp,#0
 2875              	.LCFI83:
 2876              	 .cfi_def_cfa_register 7
 2877 0006 F860     	 str r0,[r7,#12]
 2878 0008 B960     	 str r1,[r7,#8]
 2879 000a 7A60     	 str r2,[r7,#4]
1783:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xReturn;
1784:../Dave/Generated/FREERTOS/queue.c **** UBaseType_t uxSavedInterruptStatus;
1785:../Dave/Generated/FREERTOS/queue.c **** Queue_t * const pxQueue = xQueue;
 2880              	 .loc 1 1785 0
 2881 000c FB68     	 ldr r3,[r7,#12]
 2882 000e 3B63     	 str r3,[r7,#48]
1786:../Dave/Generated/FREERTOS/queue.c **** 
1787:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue );
 2883              	 .loc 1 1787 0
 2884 0010 3B6B     	 ldr r3,[r7,#48]
 2885 0012 002B     	 cmp r3,#0
 2886 0014 09D1     	 bne .L213
 2887              	.LBB179:
 2888              	.LBB180:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 2889              	 .loc 2 195 0 discriminator 1
 2890              	
 2891 0016 4FF0FC03 	 mov r3,#252
 2892 001a 83F31188 	 msr basepri,r3
 2893 001e BFF36F8F 	 isb 
 2894 0022 BFF34F8F 	 dsb 
 2895              	
 2896              	
 2897              	 .thumb
 2898 0026 3B62     	 str r3,[r7,#32]
 2899              	.L214:
 2900              	.LBE180:
 2901              	.LBE179:
 2902              	 .loc 1 1787 0 discriminator 1
 2903 0028 FEE7     	 b .L214
 2904              	.L213:
1788:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 2905              	 .loc 1 1788 0
 2906 002a BB68     	 ldr r3,[r7,#8]
 2907 002c 002B     	 cmp r3,#0
 2908 002e 03D1     	 bne .L215
 2909              	 .loc 1 1788 0 is_stmt 0 discriminator 2
 2910 0030 3B6B     	 ldr r3,[r7,#48]
 2911 0032 1B6C     	 ldr r3,[r3,#64]
 2912 0034 002B     	 cmp r3,#0
 2913 0036 01D1     	 bne .L216
 2914              	.L215:
 2915              	 .loc 1 1788 0 discriminator 3
 2916 0038 0123     	 movs r3,#1
 2917 003a 00E0     	 b .L217
 2918              	.L216:
 2919              	 .loc 1 1788 0 discriminator 4
 2920 003c 0023     	 movs r3,#0
 2921              	.L217:
 2922              	 .loc 1 1788 0 discriminator 6
 2923 003e 002B     	 cmp r3,#0
 2924 0040 09D1     	 bne .L218
 2925              	.LBB181:
 2926              	.LBB182:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 2927              	 .loc 2 195 0 is_stmt 1 discriminator 7
 2928              	
 2929 0042 4FF0FC03 	 mov r3,#252
 2930 0046 83F31188 	 msr basepri,r3
 2931 004a BFF36F8F 	 isb 
 2932 004e BFF34F8F 	 dsb 
 2933              	
 2934              	
 2935              	 .thumb
 2936 0052 FB61     	 str r3,[r7,#28]
 2937              	.L219:
 2938              	.LBE182:
 2939              	.LBE181:
 2940              	 .loc 1 1788 0 discriminator 2
 2941 0054 FEE7     	 b .L219
 2942              	.L218:
1789:../Dave/Generated/FREERTOS/queue.c **** 
1790:../Dave/Generated/FREERTOS/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1791:../Dave/Generated/FREERTOS/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1792:../Dave/Generated/FREERTOS/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1793:../Dave/Generated/FREERTOS/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1794:../Dave/Generated/FREERTOS/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1795:../Dave/Generated/FREERTOS/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1796:../Dave/Generated/FREERTOS/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1797:../Dave/Generated/FREERTOS/queue.c **** 	assigned a priority above the configured maximum system call priority.
1798:../Dave/Generated/FREERTOS/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1799:../Dave/Generated/FREERTOS/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1800:../Dave/Generated/FREERTOS/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1801:../Dave/Generated/FREERTOS/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1802:../Dave/Generated/FREERTOS/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1803:../Dave/Generated/FREERTOS/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1804:../Dave/Generated/FREERTOS/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 2943              	 .loc 1 1804 0
 2944 0056 FFF7FEFF 	 bl vPortValidateInterruptPriority
 2945              	.LBB183:
 2946              	.LBB184:
 211:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 2947              	 .loc 2 211 0
 2948              	
 2949 005a EFF31182 	 mrs r2,basepri
 2950 005e 4FF0FC03 	 mov r3,#252
 2951 0062 83F31188 	 msr basepri,r3
 2952 0066 BFF36F8F 	 isb 
 2953 006a BFF34F8F 	 dsb 
 2954              	
 2955              	
 2956              	 .thumb
 2957 006e BA61     	 str r2,[r7,#24]
 2958 0070 7B61     	 str r3,[r7,#20]
 223:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** }
 2959              	 .loc 2 223 0
 2960 0072 BB69     	 ldr r3,[r7,#24]
 2961              	.LBE184:
 2962              	.LBE183:
1805:../Dave/Generated/FREERTOS/queue.c **** 
1806:../Dave/Generated/FREERTOS/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 2963              	 .loc 1 1806 0
 2964 0074 FB62     	 str r3,[r7,#44]
 2965              	.LBB185:
1807:../Dave/Generated/FREERTOS/queue.c **** 	{
1808:../Dave/Generated/FREERTOS/queue.c **** 		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 2966              	 .loc 1 1808 0
 2967 0076 3B6B     	 ldr r3,[r7,#48]
 2968 0078 9B6B     	 ldr r3,[r3,#56]
 2969 007a BB62     	 str r3,[r7,#40]
1809:../Dave/Generated/FREERTOS/queue.c **** 
1810:../Dave/Generated/FREERTOS/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1811:../Dave/Generated/FREERTOS/queue.c **** 		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 2970              	 .loc 1 1811 0
 2971 007c BB6A     	 ldr r3,[r7,#40]
 2972 007e 002B     	 cmp r3,#0
 2973 0080 2FD0     	 beq .L221
 2974              	.LBB186:
1812:../Dave/Generated/FREERTOS/queue.c **** 		{
1813:../Dave/Generated/FREERTOS/queue.c **** 			const int8_t cRxLock = pxQueue->cRxLock;
 2975              	 .loc 1 1813 0
 2976 0082 3B6B     	 ldr r3,[r7,#48]
 2977 0084 93F84430 	 ldrb r3,[r3,#68]
 2978 0088 87F82730 	 strb r3,[r7,#39]
1814:../Dave/Generated/FREERTOS/queue.c **** 
1815:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1816:../Dave/Generated/FREERTOS/queue.c **** 
1817:../Dave/Generated/FREERTOS/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 2979              	 .loc 1 1817 0
 2980 008c 386B     	 ldr r0,[r7,#48]
 2981 008e B968     	 ldr r1,[r7,#8]
 2982 0090 FFF7FEFF 	 bl prvCopyDataFromQueue
1818:../Dave/Generated/FREERTOS/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 2983              	 .loc 1 1818 0
 2984 0094 BB6A     	 ldr r3,[r7,#40]
 2985 0096 5A1E     	 subs r2,r3,#1
 2986 0098 3B6B     	 ldr r3,[r7,#48]
 2987 009a 9A63     	 str r2,[r3,#56]
1819:../Dave/Generated/FREERTOS/queue.c **** 
1820:../Dave/Generated/FREERTOS/queue.c **** 			/* If the queue is locked the event list will not be modified.
1821:../Dave/Generated/FREERTOS/queue.c **** 			Instead update the lock count so the task that unlocks the queue
1822:../Dave/Generated/FREERTOS/queue.c **** 			will know that an ISR has removed data while the queue was
1823:../Dave/Generated/FREERTOS/queue.c **** 			locked. */
1824:../Dave/Generated/FREERTOS/queue.c **** 			if( cRxLock == queueUNLOCKED )
 2988              	 .loc 1 1824 0
 2989 009c 97F92730 	 ldrsb r3,[r7,#39]
 2990 00a0 B3F1FF3F 	 cmp r3,#-1
 2991 00a4 12D1     	 bne .L222
1825:../Dave/Generated/FREERTOS/queue.c **** 			{
1826:../Dave/Generated/FREERTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 2992              	 .loc 1 1826 0
 2993 00a6 3B6B     	 ldr r3,[r7,#48]
 2994 00a8 1B69     	 ldr r3,[r3,#16]
 2995 00aa 002B     	 cmp r3,#0
 2996 00ac 16D0     	 beq .L223
1827:../Dave/Generated/FREERTOS/queue.c **** 				{
1828:../Dave/Generated/FREERTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 2997              	 .loc 1 1828 0
 2998 00ae 3B6B     	 ldr r3,[r7,#48]
 2999 00b0 1033     	 adds r3,r3,#16
 3000 00b2 1846     	 mov r0,r3
 3001 00b4 FFF7FEFF 	 bl xTaskRemoveFromEventList
 3002 00b8 0346     	 mov r3,r0
 3003 00ba 002B     	 cmp r3,#0
 3004 00bc 0ED0     	 beq .L223
1829:../Dave/Generated/FREERTOS/queue.c **** 					{
1830:../Dave/Generated/FREERTOS/queue.c **** 						/* The task waiting has a higher priority than us so
1831:../Dave/Generated/FREERTOS/queue.c **** 						force a context switch. */
1832:../Dave/Generated/FREERTOS/queue.c **** 						if( pxHigherPriorityTaskWoken != NULL )
 3005              	 .loc 1 1832 0
 3006 00be 7B68     	 ldr r3,[r7,#4]
 3007 00c0 002B     	 cmp r3,#0
 3008 00c2 0BD0     	 beq .L223
1833:../Dave/Generated/FREERTOS/queue.c **** 						{
1834:../Dave/Generated/FREERTOS/queue.c **** 							*pxHigherPriorityTaskWoken = pdTRUE;
 3009              	 .loc 1 1834 0
 3010 00c4 7B68     	 ldr r3,[r7,#4]
 3011 00c6 0122     	 movs r2,#1
 3012 00c8 1A60     	 str r2,[r3]
 3013 00ca 07E0     	 b .L223
 3014              	.L222:
1835:../Dave/Generated/FREERTOS/queue.c **** 						}
1836:../Dave/Generated/FREERTOS/queue.c **** 						else
1837:../Dave/Generated/FREERTOS/queue.c **** 						{
1838:../Dave/Generated/FREERTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1839:../Dave/Generated/FREERTOS/queue.c **** 						}
1840:../Dave/Generated/FREERTOS/queue.c **** 					}
1841:../Dave/Generated/FREERTOS/queue.c **** 					else
1842:../Dave/Generated/FREERTOS/queue.c **** 					{
1843:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1844:../Dave/Generated/FREERTOS/queue.c **** 					}
1845:../Dave/Generated/FREERTOS/queue.c **** 				}
1846:../Dave/Generated/FREERTOS/queue.c **** 				else
1847:../Dave/Generated/FREERTOS/queue.c **** 				{
1848:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1849:../Dave/Generated/FREERTOS/queue.c **** 				}
1850:../Dave/Generated/FREERTOS/queue.c **** 			}
1851:../Dave/Generated/FREERTOS/queue.c **** 			else
1852:../Dave/Generated/FREERTOS/queue.c **** 			{
1853:../Dave/Generated/FREERTOS/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1854:../Dave/Generated/FREERTOS/queue.c **** 				knows that data was removed while it was locked. */
1855:../Dave/Generated/FREERTOS/queue.c **** 				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 3015              	 .loc 1 1855 0
 3016 00cc 97F82730 	 ldrb r3,[r7,#39]
 3017 00d0 0133     	 adds r3,r3,#1
 3018 00d2 DBB2     	 uxtb r3,r3
 3019 00d4 DAB2     	 uxtb r2,r3
 3020 00d6 3B6B     	 ldr r3,[r7,#48]
 3021 00d8 83F84420 	 strb r2,[r3,#68]
 3022              	.L223:
1856:../Dave/Generated/FREERTOS/queue.c **** 			}
1857:../Dave/Generated/FREERTOS/queue.c **** 
1858:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdPASS;
 3023              	 .loc 1 1858 0
 3024 00dc 0123     	 movs r3,#1
 3025 00de 7B63     	 str r3,[r7,#52]
 3026              	.LBE186:
 3027 00e0 01E0     	 b .L224
 3028              	.L221:
1859:../Dave/Generated/FREERTOS/queue.c **** 		}
1860:../Dave/Generated/FREERTOS/queue.c **** 		else
1861:../Dave/Generated/FREERTOS/queue.c **** 		{
1862:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdFAIL;
 3029              	 .loc 1 1862 0
 3030 00e2 0023     	 movs r3,#0
 3031 00e4 7B63     	 str r3,[r7,#52]
 3032              	.L224:
 3033 00e6 FB6A     	 ldr r3,[r7,#44]
 3034 00e8 3B61     	 str r3,[r7,#16]
 3035              	.LBE185:
 3036              	.LBB187:
 3037              	.LBB188:
 3038              	 .loc 2 229 0
 3039 00ea 3B69     	 ldr r3,[r7,#16]
 3040              	
 3041 00ec 83F31188 	 msr basepri,r3
 3042              	
 3043              	 .thumb
 3044              	.LBE188:
 3045              	.LBE187:
1863:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1864:../Dave/Generated/FREERTOS/queue.c **** 		}
1865:../Dave/Generated/FREERTOS/queue.c **** 	}
1866:../Dave/Generated/FREERTOS/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1867:../Dave/Generated/FREERTOS/queue.c **** 
1868:../Dave/Generated/FREERTOS/queue.c **** 	return xReturn;
 3046              	 .loc 1 1868 0
 3047 00f0 7B6B     	 ldr r3,[r7,#52]
1869:../Dave/Generated/FREERTOS/queue.c **** }
 3048              	 .loc 1 1869 0
 3049 00f2 1846     	 mov r0,r3
 3050 00f4 3837     	 adds r7,r7,#56
 3051              	.LCFI84:
 3052              	 .cfi_def_cfa_offset 8
 3053 00f6 BD46     	 mov sp,r7
 3054              	.LCFI85:
 3055              	 .cfi_def_cfa_register 13
 3056              	 
 3057 00f8 80BD     	 pop {r7,pc}
 3058              	 .cfi_endproc
 3059              	.LFE153:
 3061 00fa 00BF     	 .section .text.xQueuePeekFromISR,"ax",%progbits
 3062              	 .align 2
 3063              	 .global xQueuePeekFromISR
 3064              	 .thumb
 3065              	 .thumb_func
 3067              	xQueuePeekFromISR:
 3068              	.LFB154:
1870:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
1871:../Dave/Generated/FREERTOS/queue.c **** 
1872:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
1873:../Dave/Generated/FREERTOS/queue.c **** {
 3069              	 .loc 1 1873 0
 3070              	 .cfi_startproc
 3071              	 
 3072              	 
 3073 0000 80B5     	 push {r7,lr}
 3074              	.LCFI86:
 3075              	 .cfi_def_cfa_offset 8
 3076              	 .cfi_offset 7,-8
 3077              	 .cfi_offset 14,-4
 3078 0002 8CB0     	 sub sp,sp,#48
 3079              	.LCFI87:
 3080              	 .cfi_def_cfa_offset 56
 3081 0004 00AF     	 add r7,sp,#0
 3082              	.LCFI88:
 3083              	 .cfi_def_cfa_register 7
 3084 0006 7860     	 str r0,[r7,#4]
 3085 0008 3960     	 str r1,[r7]
1874:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xReturn;
1875:../Dave/Generated/FREERTOS/queue.c **** UBaseType_t uxSavedInterruptStatus;
1876:../Dave/Generated/FREERTOS/queue.c **** int8_t *pcOriginalReadPosition;
1877:../Dave/Generated/FREERTOS/queue.c **** Queue_t * const pxQueue = xQueue;
 3086              	 .loc 1 1877 0
 3087 000a 7B68     	 ldr r3,[r7,#4]
 3088 000c BB62     	 str r3,[r7,#40]
1878:../Dave/Generated/FREERTOS/queue.c **** 
1879:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue );
 3089              	 .loc 1 1879 0
 3090 000e BB6A     	 ldr r3,[r7,#40]
 3091 0010 002B     	 cmp r3,#0
 3092 0012 09D1     	 bne .L227
 3093              	.LBB189:
 3094              	.LBB190:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 3095              	 .loc 2 195 0 discriminator 1
 3096              	
 3097 0014 4FF0FC03 	 mov r3,#252
 3098 0018 83F31188 	 msr basepri,r3
 3099 001c BFF36F8F 	 isb 
 3100 0020 BFF34F8F 	 dsb 
 3101              	
 3102              	
 3103              	 .thumb
 3104 0024 FB61     	 str r3,[r7,#28]
 3105              	.L228:
 3106              	.LBE190:
 3107              	.LBE189:
 3108              	 .loc 1 1879 0 discriminator 1
 3109 0026 FEE7     	 b .L228
 3110              	.L227:
1880:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 3111              	 .loc 1 1880 0
 3112 0028 3B68     	 ldr r3,[r7]
 3113 002a 002B     	 cmp r3,#0
 3114 002c 03D1     	 bne .L229
 3115              	 .loc 1 1880 0 is_stmt 0 discriminator 2
 3116 002e BB6A     	 ldr r3,[r7,#40]
 3117 0030 1B6C     	 ldr r3,[r3,#64]
 3118 0032 002B     	 cmp r3,#0
 3119 0034 01D1     	 bne .L230
 3120              	.L229:
 3121              	 .loc 1 1880 0 discriminator 3
 3122 0036 0123     	 movs r3,#1
 3123 0038 00E0     	 b .L231
 3124              	.L230:
 3125              	 .loc 1 1880 0 discriminator 4
 3126 003a 0023     	 movs r3,#0
 3127              	.L231:
 3128              	 .loc 1 1880 0 discriminator 6
 3129 003c 002B     	 cmp r3,#0
 3130 003e 09D1     	 bne .L232
 3131              	.LBB191:
 3132              	.LBB192:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 3133              	 .loc 2 195 0 is_stmt 1 discriminator 7
 3134              	
 3135 0040 4FF0FC03 	 mov r3,#252
 3136 0044 83F31188 	 msr basepri,r3
 3137 0048 BFF36F8F 	 isb 
 3138 004c BFF34F8F 	 dsb 
 3139              	
 3140              	
 3141              	 .thumb
 3142 0050 BB61     	 str r3,[r7,#24]
 3143              	.L233:
 3144              	.LBE192:
 3145              	.LBE191:
 3146              	 .loc 1 1880 0 discriminator 2
 3147 0052 FEE7     	 b .L233
 3148              	.L232:
1881:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
 3149              	 .loc 1 1881 0
 3150 0054 BB6A     	 ldr r3,[r7,#40]
 3151 0056 1B6C     	 ldr r3,[r3,#64]
 3152 0058 002B     	 cmp r3,#0
 3153 005a 09D1     	 bne .L234
 3154              	.LBB193:
 3155              	.LBB194:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 3156              	 .loc 2 195 0 discriminator 1
 3157              	
 3158 005c 4FF0FC03 	 mov r3,#252
 3159 0060 83F31188 	 msr basepri,r3
 3160 0064 BFF36F8F 	 isb 
 3161 0068 BFF34F8F 	 dsb 
 3162              	
 3163              	
 3164              	 .thumb
 3165 006c 7B61     	 str r3,[r7,#20]
 3166              	.L235:
 3167              	.LBE194:
 3168              	.LBE193:
 3169              	 .loc 1 1881 0 discriminator 3
 3170 006e FEE7     	 b .L235
 3171              	.L234:
1882:../Dave/Generated/FREERTOS/queue.c **** 
1883:../Dave/Generated/FREERTOS/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1884:../Dave/Generated/FREERTOS/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1885:../Dave/Generated/FREERTOS/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1886:../Dave/Generated/FREERTOS/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1887:../Dave/Generated/FREERTOS/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1888:../Dave/Generated/FREERTOS/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1889:../Dave/Generated/FREERTOS/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1890:../Dave/Generated/FREERTOS/queue.c **** 	assigned a priority above the configured maximum system call priority.
1891:../Dave/Generated/FREERTOS/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1892:../Dave/Generated/FREERTOS/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1893:../Dave/Generated/FREERTOS/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1894:../Dave/Generated/FREERTOS/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1895:../Dave/Generated/FREERTOS/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1896:../Dave/Generated/FREERTOS/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1897:../Dave/Generated/FREERTOS/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 3172              	 .loc 1 1897 0
 3173 0070 FFF7FEFF 	 bl vPortValidateInterruptPriority
 3174              	.LBB195:
 3175              	.LBB196:
 211:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 3176              	 .loc 2 211 0
 3177              	
 3178 0074 EFF31182 	 mrs r2,basepri
 3179 0078 4FF0FC03 	 mov r3,#252
 3180 007c 83F31188 	 msr basepri,r3
 3181 0080 BFF36F8F 	 isb 
 3182 0084 BFF34F8F 	 dsb 
 3183              	
 3184              	
 3185              	 .thumb
 3186 0088 3A61     	 str r2,[r7,#16]
 3187 008a FB60     	 str r3,[r7,#12]
 223:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** }
 3188              	 .loc 2 223 0
 3189 008c 3B69     	 ldr r3,[r7,#16]
 3190              	.LBE196:
 3191              	.LBE195:
1898:../Dave/Generated/FREERTOS/queue.c **** 
1899:../Dave/Generated/FREERTOS/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 3192              	 .loc 1 1899 0
 3193 008e 7B62     	 str r3,[r7,#36]
1900:../Dave/Generated/FREERTOS/queue.c **** 	{
1901:../Dave/Generated/FREERTOS/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1902:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 3194              	 .loc 1 1902 0
 3195 0090 BB6A     	 ldr r3,[r7,#40]
 3196 0092 9B6B     	 ldr r3,[r3,#56]
 3197 0094 002B     	 cmp r3,#0
 3198 0096 0CD0     	 beq .L237
1903:../Dave/Generated/FREERTOS/queue.c **** 		{
1904:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_PEEK_FROM_ISR( pxQueue );
1905:../Dave/Generated/FREERTOS/queue.c **** 
1906:../Dave/Generated/FREERTOS/queue.c **** 			/* Remember the read position so it can be reset as nothing is
1907:../Dave/Generated/FREERTOS/queue.c **** 			actually being removed from the queue. */
1908:../Dave/Generated/FREERTOS/queue.c **** 			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 3199              	 .loc 1 1908 0
 3200 0098 BB6A     	 ldr r3,[r7,#40]
 3201 009a DB68     	 ldr r3,[r3,#12]
 3202 009c 3B62     	 str r3,[r7,#32]
1909:../Dave/Generated/FREERTOS/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 3203              	 .loc 1 1909 0
 3204 009e B86A     	 ldr r0,[r7,#40]
 3205 00a0 3968     	 ldr r1,[r7]
 3206 00a2 FFF7FEFF 	 bl prvCopyDataFromQueue
1910:../Dave/Generated/FREERTOS/queue.c **** 			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 3207              	 .loc 1 1910 0
 3208 00a6 BB6A     	 ldr r3,[r7,#40]
 3209 00a8 3A6A     	 ldr r2,[r7,#32]
 3210 00aa DA60     	 str r2,[r3,#12]
1911:../Dave/Generated/FREERTOS/queue.c **** 
1912:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdPASS;
 3211              	 .loc 1 1912 0
 3212 00ac 0123     	 movs r3,#1
 3213 00ae FB62     	 str r3,[r7,#44]
 3214 00b0 01E0     	 b .L238
 3215              	.L237:
1913:../Dave/Generated/FREERTOS/queue.c **** 		}
1914:../Dave/Generated/FREERTOS/queue.c **** 		else
1915:../Dave/Generated/FREERTOS/queue.c **** 		{
1916:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdFAIL;
 3216              	 .loc 1 1916 0
 3217 00b2 0023     	 movs r3,#0
 3218 00b4 FB62     	 str r3,[r7,#44]
 3219              	.L238:
 3220 00b6 7B6A     	 ldr r3,[r7,#36]
 3221 00b8 BB60     	 str r3,[r7,#8]
 3222              	.LBB197:
 3223              	.LBB198:
 3224              	 .loc 2 229 0
 3225 00ba BB68     	 ldr r3,[r7,#8]
 3226              	
 3227 00bc 83F31188 	 msr basepri,r3
 3228              	
 3229              	 .thumb
 3230              	.LBE198:
 3231              	.LBE197:
1917:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1918:../Dave/Generated/FREERTOS/queue.c **** 		}
1919:../Dave/Generated/FREERTOS/queue.c **** 	}
1920:../Dave/Generated/FREERTOS/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1921:../Dave/Generated/FREERTOS/queue.c **** 
1922:../Dave/Generated/FREERTOS/queue.c **** 	return xReturn;
 3232              	 .loc 1 1922 0
 3233 00c0 FB6A     	 ldr r3,[r7,#44]
1923:../Dave/Generated/FREERTOS/queue.c **** }
 3234              	 .loc 1 1923 0
 3235 00c2 1846     	 mov r0,r3
 3236 00c4 3037     	 adds r7,r7,#48
 3237              	.LCFI89:
 3238              	 .cfi_def_cfa_offset 8
 3239 00c6 BD46     	 mov sp,r7
 3240              	.LCFI90:
 3241              	 .cfi_def_cfa_register 13
 3242              	 
 3243 00c8 80BD     	 pop {r7,pc}
 3244              	 .cfi_endproc
 3245              	.LFE154:
 3247 00ca 00BF     	 .section .text.uxQueueMessagesWaiting,"ax",%progbits
 3248              	 .align 2
 3249              	 .global uxQueueMessagesWaiting
 3250              	 .thumb
 3251              	 .thumb_func
 3253              	uxQueueMessagesWaiting:
 3254              	.LFB155:
1924:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
1925:../Dave/Generated/FREERTOS/queue.c **** 
1926:../Dave/Generated/FREERTOS/queue.c **** UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
1927:../Dave/Generated/FREERTOS/queue.c **** {
 3255              	 .loc 1 1927 0
 3256              	 .cfi_startproc
 3257              	 
 3258              	 
 3259 0000 80B5     	 push {r7,lr}
 3260              	.LCFI91:
 3261              	 .cfi_def_cfa_offset 8
 3262              	 .cfi_offset 7,-8
 3263              	 .cfi_offset 14,-4
 3264 0002 84B0     	 sub sp,sp,#16
 3265              	.LCFI92:
 3266              	 .cfi_def_cfa_offset 24
 3267 0004 00AF     	 add r7,sp,#0
 3268              	.LCFI93:
 3269              	 .cfi_def_cfa_register 7
 3270 0006 7860     	 str r0,[r7,#4]
1928:../Dave/Generated/FREERTOS/queue.c **** UBaseType_t uxReturn;
1929:../Dave/Generated/FREERTOS/queue.c **** 
1930:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( xQueue );
 3271              	 .loc 1 1930 0
 3272 0008 7B68     	 ldr r3,[r7,#4]
 3273 000a 002B     	 cmp r3,#0
 3274 000c 09D1     	 bne .L241
 3275              	.LBB199:
 3276              	.LBB200:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 3277              	 .loc 2 195 0 discriminator 1
 3278              	
 3279 000e 4FF0FC03 	 mov r3,#252
 3280 0012 83F31188 	 msr basepri,r3
 3281 0016 BFF36F8F 	 isb 
 3282 001a BFF34F8F 	 dsb 
 3283              	
 3284              	
 3285              	 .thumb
 3286 001e BB60     	 str r3,[r7,#8]
 3287              	.L242:
 3288              	.LBE200:
 3289              	.LBE199:
 3290              	 .loc 1 1930 0 discriminator 1
 3291 0020 FEE7     	 b .L242
 3292              	.L241:
1931:../Dave/Generated/FREERTOS/queue.c **** 
1932:../Dave/Generated/FREERTOS/queue.c **** 	taskENTER_CRITICAL();
 3293              	 .loc 1 1932 0
 3294 0022 FFF7FEFF 	 bl vPortEnterCritical
1933:../Dave/Generated/FREERTOS/queue.c **** 	{
1934:../Dave/Generated/FREERTOS/queue.c **** 		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 3295              	 .loc 1 1934 0
 3296 0026 7B68     	 ldr r3,[r7,#4]
 3297 0028 9B6B     	 ldr r3,[r3,#56]
 3298 002a FB60     	 str r3,[r7,#12]
1935:../Dave/Generated/FREERTOS/queue.c **** 	}
1936:../Dave/Generated/FREERTOS/queue.c **** 	taskEXIT_CRITICAL();
 3299              	 .loc 1 1936 0
 3300 002c FFF7FEFF 	 bl vPortExitCritical
1937:../Dave/Generated/FREERTOS/queue.c **** 
1938:../Dave/Generated/FREERTOS/queue.c **** 	return uxReturn;
 3301              	 .loc 1 1938 0
 3302 0030 FB68     	 ldr r3,[r7,#12]
1939:../Dave/Generated/FREERTOS/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 3303              	 .loc 1 1939 0
 3304 0032 1846     	 mov r0,r3
 3305 0034 1037     	 adds r7,r7,#16
 3306              	.LCFI94:
 3307              	 .cfi_def_cfa_offset 8
 3308 0036 BD46     	 mov sp,r7
 3309              	.LCFI95:
 3310              	 .cfi_def_cfa_register 13
 3311              	 
 3312 0038 80BD     	 pop {r7,pc}
 3313              	 .cfi_endproc
 3314              	.LFE155:
 3316 003a 00BF     	 .section .text.uxQueueSpacesAvailable,"ax",%progbits
 3317              	 .align 2
 3318              	 .global uxQueueSpacesAvailable
 3319              	 .thumb
 3320              	 .thumb_func
 3322              	uxQueueSpacesAvailable:
 3323              	.LFB156:
1940:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
1941:../Dave/Generated/FREERTOS/queue.c **** 
1942:../Dave/Generated/FREERTOS/queue.c **** UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
1943:../Dave/Generated/FREERTOS/queue.c **** {
 3324              	 .loc 1 1943 0
 3325              	 .cfi_startproc
 3326              	 
 3327              	 
 3328 0000 80B5     	 push {r7,lr}
 3329              	.LCFI96:
 3330              	 .cfi_def_cfa_offset 8
 3331              	 .cfi_offset 7,-8
 3332              	 .cfi_offset 14,-4
 3333 0002 86B0     	 sub sp,sp,#24
 3334              	.LCFI97:
 3335              	 .cfi_def_cfa_offset 32
 3336 0004 00AF     	 add r7,sp,#0
 3337              	.LCFI98:
 3338              	 .cfi_def_cfa_register 7
 3339 0006 7860     	 str r0,[r7,#4]
1944:../Dave/Generated/FREERTOS/queue.c **** UBaseType_t uxReturn;
1945:../Dave/Generated/FREERTOS/queue.c **** Queue_t * const pxQueue = xQueue;
 3340              	 .loc 1 1945 0
 3341 0008 7B68     	 ldr r3,[r7,#4]
 3342 000a 7B61     	 str r3,[r7,#20]
1946:../Dave/Generated/FREERTOS/queue.c **** 
1947:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue );
 3343              	 .loc 1 1947 0
 3344 000c 7B69     	 ldr r3,[r7,#20]
 3345 000e 002B     	 cmp r3,#0
 3346 0010 09D1     	 bne .L245
 3347              	.LBB201:
 3348              	.LBB202:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 3349              	 .loc 2 195 0 discriminator 1
 3350              	
 3351 0012 4FF0FC03 	 mov r3,#252
 3352 0016 83F31188 	 msr basepri,r3
 3353 001a BFF36F8F 	 isb 
 3354 001e BFF34F8F 	 dsb 
 3355              	
 3356              	
 3357              	 .thumb
 3358 0022 FB60     	 str r3,[r7,#12]
 3359              	.L246:
 3360              	.LBE202:
 3361              	.LBE201:
 3362              	 .loc 1 1947 0 discriminator 1
 3363 0024 FEE7     	 b .L246
 3364              	.L245:
1948:../Dave/Generated/FREERTOS/queue.c **** 
1949:../Dave/Generated/FREERTOS/queue.c **** 	taskENTER_CRITICAL();
 3365              	 .loc 1 1949 0
 3366 0026 FFF7FEFF 	 bl vPortEnterCritical
1950:../Dave/Generated/FREERTOS/queue.c **** 	{
1951:../Dave/Generated/FREERTOS/queue.c **** 		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 3367              	 .loc 1 1951 0
 3368 002a 7B69     	 ldr r3,[r7,#20]
 3369 002c DA6B     	 ldr r2,[r3,#60]
 3370 002e 7B69     	 ldr r3,[r7,#20]
 3371 0030 9B6B     	 ldr r3,[r3,#56]
 3372 0032 D31A     	 subs r3,r2,r3
 3373 0034 3B61     	 str r3,[r7,#16]
1952:../Dave/Generated/FREERTOS/queue.c **** 	}
1953:../Dave/Generated/FREERTOS/queue.c **** 	taskEXIT_CRITICAL();
 3374              	 .loc 1 1953 0
 3375 0036 FFF7FEFF 	 bl vPortExitCritical
1954:../Dave/Generated/FREERTOS/queue.c **** 
1955:../Dave/Generated/FREERTOS/queue.c **** 	return uxReturn;
 3376              	 .loc 1 1955 0
 3377 003a 3B69     	 ldr r3,[r7,#16]
1956:../Dave/Generated/FREERTOS/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 3378              	 .loc 1 1956 0
 3379 003c 1846     	 mov r0,r3
 3380 003e 1837     	 adds r7,r7,#24
 3381              	.LCFI99:
 3382              	 .cfi_def_cfa_offset 8
 3383 0040 BD46     	 mov sp,r7
 3384              	.LCFI100:
 3385              	 .cfi_def_cfa_register 13
 3386              	 
 3387 0042 80BD     	 pop {r7,pc}
 3388              	 .cfi_endproc
 3389              	.LFE156:
 3391              	 .section .text.uxQueueMessagesWaitingFromISR,"ax",%progbits
 3392              	 .align 2
 3393              	 .global uxQueueMessagesWaitingFromISR
 3394              	 .thumb
 3395              	 .thumb_func
 3397              	uxQueueMessagesWaitingFromISR:
 3398              	.LFB157:
1957:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
1958:../Dave/Generated/FREERTOS/queue.c **** 
1959:../Dave/Generated/FREERTOS/queue.c **** UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
1960:../Dave/Generated/FREERTOS/queue.c **** {
 3399              	 .loc 1 1960 0
 3400              	 .cfi_startproc
 3401              	 
 3402              	 
 3403              	 
 3404 0000 80B4     	 push {r7}
 3405              	.LCFI101:
 3406              	 .cfi_def_cfa_offset 4
 3407              	 .cfi_offset 7,-4
 3408 0002 87B0     	 sub sp,sp,#28
 3409              	.LCFI102:
 3410              	 .cfi_def_cfa_offset 32
 3411 0004 00AF     	 add r7,sp,#0
 3412              	.LCFI103:
 3413              	 .cfi_def_cfa_register 7
 3414 0006 7860     	 str r0,[r7,#4]
1961:../Dave/Generated/FREERTOS/queue.c **** UBaseType_t uxReturn;
1962:../Dave/Generated/FREERTOS/queue.c **** Queue_t * const pxQueue = xQueue;
 3415              	 .loc 1 1962 0
 3416 0008 7B68     	 ldr r3,[r7,#4]
 3417 000a 7B61     	 str r3,[r7,#20]
1963:../Dave/Generated/FREERTOS/queue.c **** 
1964:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue );
 3418              	 .loc 1 1964 0
 3419 000c 7B69     	 ldr r3,[r7,#20]
 3420 000e 002B     	 cmp r3,#0
 3421 0010 09D1     	 bne .L249
 3422              	.LBB203:
 3423              	.LBB204:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 3424              	 .loc 2 195 0 discriminator 1
 3425              	
 3426 0012 4FF0FC03 	 mov r3,#252
 3427 0016 83F31188 	 msr basepri,r3
 3428 001a BFF36F8F 	 isb 
 3429 001e BFF34F8F 	 dsb 
 3430              	
 3431              	
 3432              	 .thumb
 3433 0022 FB60     	 str r3,[r7,#12]
 3434              	.L250:
 3435              	.LBE204:
 3436              	.LBE203:
 3437              	 .loc 1 1964 0 discriminator 1
 3438 0024 FEE7     	 b .L250
 3439              	.L249:
1965:../Dave/Generated/FREERTOS/queue.c **** 	uxReturn = pxQueue->uxMessagesWaiting;
 3440              	 .loc 1 1965 0
 3441 0026 7B69     	 ldr r3,[r7,#20]
 3442 0028 9B6B     	 ldr r3,[r3,#56]
 3443 002a 3B61     	 str r3,[r7,#16]
1966:../Dave/Generated/FREERTOS/queue.c **** 
1967:../Dave/Generated/FREERTOS/queue.c **** 	return uxReturn;
 3444              	 .loc 1 1967 0
 3445 002c 3B69     	 ldr r3,[r7,#16]
1968:../Dave/Generated/FREERTOS/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 3446              	 .loc 1 1968 0
 3447 002e 1846     	 mov r0,r3
 3448 0030 1C37     	 adds r7,r7,#28
 3449              	.LCFI104:
 3450              	 .cfi_def_cfa_offset 4
 3451 0032 BD46     	 mov sp,r7
 3452              	.LCFI105:
 3453              	 .cfi_def_cfa_register 13
 3454              	 
 3455 0034 5DF8047B 	 ldr r7,[sp],#4
 3456              	.LCFI106:
 3457              	 .cfi_restore 7
 3458              	 .cfi_def_cfa_offset 0
 3459 0038 7047     	 bx lr
 3460              	 .cfi_endproc
 3461              	.LFE157:
 3463 003a 00BF     	 .section .text.vQueueDelete,"ax",%progbits
 3464              	 .align 2
 3465              	 .global vQueueDelete
 3466              	 .thumb
 3467              	 .thumb_func
 3469              	vQueueDelete:
 3470              	.LFB158:
1969:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
1970:../Dave/Generated/FREERTOS/queue.c **** 
1971:../Dave/Generated/FREERTOS/queue.c **** void vQueueDelete( QueueHandle_t xQueue )
1972:../Dave/Generated/FREERTOS/queue.c **** {
 3471              	 .loc 1 1972 0
 3472              	 .cfi_startproc
 3473              	 
 3474              	 
 3475 0000 80B5     	 push {r7,lr}
 3476              	.LCFI107:
 3477              	 .cfi_def_cfa_offset 8
 3478              	 .cfi_offset 7,-8
 3479              	 .cfi_offset 14,-4
 3480 0002 84B0     	 sub sp,sp,#16
 3481              	.LCFI108:
 3482              	 .cfi_def_cfa_offset 24
 3483 0004 00AF     	 add r7,sp,#0
 3484              	.LCFI109:
 3485              	 .cfi_def_cfa_register 7
 3486 0006 7860     	 str r0,[r7,#4]
1973:../Dave/Generated/FREERTOS/queue.c **** Queue_t * const pxQueue = xQueue;
 3487              	 .loc 1 1973 0
 3488 0008 7B68     	 ldr r3,[r7,#4]
 3489 000a FB60     	 str r3,[r7,#12]
1974:../Dave/Generated/FREERTOS/queue.c **** 
1975:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue );
 3490              	 .loc 1 1975 0
 3491 000c FB68     	 ldr r3,[r7,#12]
 3492 000e 002B     	 cmp r3,#0
 3493 0010 09D1     	 bne .L253
 3494              	.LBB205:
 3495              	.LBB206:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 3496              	 .loc 2 195 0 discriminator 1
 3497              	
 3498 0012 4FF0FC03 	 mov r3,#252
 3499 0016 83F31188 	 msr basepri,r3
 3500 001a BFF36F8F 	 isb 
 3501 001e BFF34F8F 	 dsb 
 3502              	
 3503              	
 3504              	 .thumb
 3505 0022 BB60     	 str r3,[r7,#8]
 3506              	.L254:
 3507              	.LBE206:
 3508              	.LBE205:
 3509              	 .loc 1 1975 0 discriminator 1
 3510 0024 FEE7     	 b .L254
 3511              	.L253:
1976:../Dave/Generated/FREERTOS/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1977:../Dave/Generated/FREERTOS/queue.c **** 
1978:../Dave/Generated/FREERTOS/queue.c **** 	#if ( configQUEUE_REGISTRY_SIZE > 0 )
1979:../Dave/Generated/FREERTOS/queue.c **** 	{
1980:../Dave/Generated/FREERTOS/queue.c **** 		vQueueUnregisterQueue( pxQueue );
 3512              	 .loc 1 1980 0
 3513 0026 F868     	 ldr r0,[r7,#12]
 3514 0028 FFF7FEFF 	 bl vQueueUnregisterQueue
1981:../Dave/Generated/FREERTOS/queue.c **** 	}
1982:../Dave/Generated/FREERTOS/queue.c **** 	#endif
1983:../Dave/Generated/FREERTOS/queue.c **** 
1984:../Dave/Generated/FREERTOS/queue.c **** 	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
1985:../Dave/Generated/FREERTOS/queue.c **** 	{
1986:../Dave/Generated/FREERTOS/queue.c **** 		/* The queue can only have been allocated dynamically - free it
1987:../Dave/Generated/FREERTOS/queue.c **** 		again. */
1988:../Dave/Generated/FREERTOS/queue.c **** 		vPortFree( pxQueue );
 3515              	 .loc 1 1988 0
 3516 002c F868     	 ldr r0,[r7,#12]
 3517 002e FFF7FEFF 	 bl vPortFree
1989:../Dave/Generated/FREERTOS/queue.c **** 	}
1990:../Dave/Generated/FREERTOS/queue.c **** 	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
1991:../Dave/Generated/FREERTOS/queue.c **** 	{
1992:../Dave/Generated/FREERTOS/queue.c **** 		/* The queue could have been allocated statically or dynamically, so
1993:../Dave/Generated/FREERTOS/queue.c **** 		check before attempting to free the memory. */
1994:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
1995:../Dave/Generated/FREERTOS/queue.c **** 		{
1996:../Dave/Generated/FREERTOS/queue.c **** 			vPortFree( pxQueue );
1997:../Dave/Generated/FREERTOS/queue.c **** 		}
1998:../Dave/Generated/FREERTOS/queue.c **** 		else
1999:../Dave/Generated/FREERTOS/queue.c **** 		{
2000:../Dave/Generated/FREERTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2001:../Dave/Generated/FREERTOS/queue.c **** 		}
2002:../Dave/Generated/FREERTOS/queue.c **** 	}
2003:../Dave/Generated/FREERTOS/queue.c **** 	#else
2004:../Dave/Generated/FREERTOS/queue.c **** 	{
2005:../Dave/Generated/FREERTOS/queue.c **** 		/* The queue must have been statically allocated, so is not going to be
2006:../Dave/Generated/FREERTOS/queue.c **** 		deleted.  Avoid compiler warnings about the unused parameter. */
2007:../Dave/Generated/FREERTOS/queue.c **** 		( void ) pxQueue;
2008:../Dave/Generated/FREERTOS/queue.c **** 	}
2009:../Dave/Generated/FREERTOS/queue.c **** 	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
2010:../Dave/Generated/FREERTOS/queue.c **** }
 3518              	 .loc 1 2010 0
 3519 0032 1037     	 adds r7,r7,#16
 3520              	.LCFI110:
 3521              	 .cfi_def_cfa_offset 8
 3522 0034 BD46     	 mov sp,r7
 3523              	.LCFI111:
 3524              	 .cfi_def_cfa_register 13
 3525              	 
 3526 0036 80BD     	 pop {r7,pc}
 3527              	 .cfi_endproc
 3528              	.LFE158:
 3530              	 .section .text.uxQueueGetQueueNumber,"ax",%progbits
 3531              	 .align 2
 3532              	 .global uxQueueGetQueueNumber
 3533              	 .thumb
 3534              	 .thumb_func
 3536              	uxQueueGetQueueNumber:
 3537              	.LFB159:
2011:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2012:../Dave/Generated/FREERTOS/queue.c **** 
2013:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2014:../Dave/Generated/FREERTOS/queue.c **** 
2015:../Dave/Generated/FREERTOS/queue.c **** 	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
2016:../Dave/Generated/FREERTOS/queue.c **** 	{
 3538              	 .loc 1 2016 0
 3539              	 .cfi_startproc
 3540              	 
 3541              	 
 3542              	 
 3543 0000 80B4     	 push {r7}
 3544              	.LCFI112:
 3545              	 .cfi_def_cfa_offset 4
 3546              	 .cfi_offset 7,-4
 3547 0002 83B0     	 sub sp,sp,#12
 3548              	.LCFI113:
 3549              	 .cfi_def_cfa_offset 16
 3550 0004 00AF     	 add r7,sp,#0
 3551              	.LCFI114:
 3552              	 .cfi_def_cfa_register 7
 3553 0006 7860     	 str r0,[r7,#4]
2017:../Dave/Generated/FREERTOS/queue.c **** 		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
 3554              	 .loc 1 2017 0
 3555 0008 7B68     	 ldr r3,[r7,#4]
 3556 000a DB6C     	 ldr r3,[r3,#76]
2018:../Dave/Generated/FREERTOS/queue.c **** 	}
 3557              	 .loc 1 2018 0
 3558 000c 1846     	 mov r0,r3
 3559 000e 0C37     	 adds r7,r7,#12
 3560              	.LCFI115:
 3561              	 .cfi_def_cfa_offset 4
 3562 0010 BD46     	 mov sp,r7
 3563              	.LCFI116:
 3564              	 .cfi_def_cfa_register 13
 3565              	 
 3566 0012 5DF8047B 	 ldr r7,[sp],#4
 3567              	.LCFI117:
 3568              	 .cfi_restore 7
 3569              	 .cfi_def_cfa_offset 0
 3570 0016 7047     	 bx lr
 3571              	 .cfi_endproc
 3572              	.LFE159:
 3574              	 .section .text.vQueueSetQueueNumber,"ax",%progbits
 3575              	 .align 2
 3576              	 .global vQueueSetQueueNumber
 3577              	 .thumb
 3578              	 .thumb_func
 3580              	vQueueSetQueueNumber:
 3581              	.LFB160:
2019:../Dave/Generated/FREERTOS/queue.c **** 
2020:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2021:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2022:../Dave/Generated/FREERTOS/queue.c **** 
2023:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2024:../Dave/Generated/FREERTOS/queue.c **** 
2025:../Dave/Generated/FREERTOS/queue.c **** 	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
2026:../Dave/Generated/FREERTOS/queue.c **** 	{
 3582              	 .loc 1 2026 0
 3583              	 .cfi_startproc
 3584              	 
 3585              	 
 3586              	 
 3587 0000 80B4     	 push {r7}
 3588              	.LCFI118:
 3589              	 .cfi_def_cfa_offset 4
 3590              	 .cfi_offset 7,-4
 3591 0002 83B0     	 sub sp,sp,#12
 3592              	.LCFI119:
 3593              	 .cfi_def_cfa_offset 16
 3594 0004 00AF     	 add r7,sp,#0
 3595              	.LCFI120:
 3596              	 .cfi_def_cfa_register 7
 3597 0006 7860     	 str r0,[r7,#4]
 3598 0008 3960     	 str r1,[r7]
2027:../Dave/Generated/FREERTOS/queue.c **** 		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
 3599              	 .loc 1 2027 0
 3600 000a 7B68     	 ldr r3,[r7,#4]
 3601 000c 3A68     	 ldr r2,[r7]
 3602 000e DA64     	 str r2,[r3,#76]
2028:../Dave/Generated/FREERTOS/queue.c **** 	}
 3603              	 .loc 1 2028 0
 3604 0010 0C37     	 adds r7,r7,#12
 3605              	.LCFI121:
 3606              	 .cfi_def_cfa_offset 4
 3607 0012 BD46     	 mov sp,r7
 3608              	.LCFI122:
 3609              	 .cfi_def_cfa_register 13
 3610              	 
 3611 0014 5DF8047B 	 ldr r7,[sp],#4
 3612              	.LCFI123:
 3613              	 .cfi_restore 7
 3614              	 .cfi_def_cfa_offset 0
 3615 0018 7047     	 bx lr
 3616              	 .cfi_endproc
 3617              	.LFE160:
 3619 001a 00BF     	 .section .text.ucQueueGetQueueType,"ax",%progbits
 3620              	 .align 2
 3621              	 .global ucQueueGetQueueType
 3622              	 .thumb
 3623              	 .thumb_func
 3625              	ucQueueGetQueueType:
 3626              	.LFB161:
2029:../Dave/Generated/FREERTOS/queue.c **** 
2030:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2031:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2032:../Dave/Generated/FREERTOS/queue.c **** 
2033:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2034:../Dave/Generated/FREERTOS/queue.c **** 
2035:../Dave/Generated/FREERTOS/queue.c **** 	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
2036:../Dave/Generated/FREERTOS/queue.c **** 	{
 3627              	 .loc 1 2036 0
 3628              	 .cfi_startproc
 3629              	 
 3630              	 
 3631              	 
 3632 0000 80B4     	 push {r7}
 3633              	.LCFI124:
 3634              	 .cfi_def_cfa_offset 4
 3635              	 .cfi_offset 7,-4
 3636 0002 83B0     	 sub sp,sp,#12
 3637              	.LCFI125:
 3638              	 .cfi_def_cfa_offset 16
 3639 0004 00AF     	 add r7,sp,#0
 3640              	.LCFI126:
 3641              	 .cfi_def_cfa_register 7
 3642 0006 7860     	 str r0,[r7,#4]
2037:../Dave/Generated/FREERTOS/queue.c **** 		return ( ( Queue_t * ) xQueue )->ucQueueType;
 3643              	 .loc 1 2037 0
 3644 0008 7B68     	 ldr r3,[r7,#4]
 3645 000a 93F85030 	 ldrb r3,[r3,#80]
2038:../Dave/Generated/FREERTOS/queue.c **** 	}
 3646              	 .loc 1 2038 0
 3647 000e 1846     	 mov r0,r3
 3648 0010 0C37     	 adds r7,r7,#12
 3649              	.LCFI127:
 3650              	 .cfi_def_cfa_offset 4
 3651 0012 BD46     	 mov sp,r7
 3652              	.LCFI128:
 3653              	 .cfi_def_cfa_register 13
 3654              	 
 3655 0014 5DF8047B 	 ldr r7,[sp],#4
 3656              	.LCFI129:
 3657              	 .cfi_restore 7
 3658              	 .cfi_def_cfa_offset 0
 3659 0018 7047     	 bx lr
 3660              	 .cfi_endproc
 3661              	.LFE161:
 3663 001a 00BF     	 .section .text.prvGetDisinheritPriorityAfterTimeout,"ax",%progbits
 3664              	 .align 2
 3665              	 .thumb
 3666              	 .thumb_func
 3668              	prvGetDisinheritPriorityAfterTimeout:
 3669              	.LFB162:
2039:../Dave/Generated/FREERTOS/queue.c **** 
2040:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2041:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2042:../Dave/Generated/FREERTOS/queue.c **** 
2043:../Dave/Generated/FREERTOS/queue.c **** #if( configUSE_MUTEXES == 1 )
2044:../Dave/Generated/FREERTOS/queue.c **** 
2045:../Dave/Generated/FREERTOS/queue.c **** 	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
2046:../Dave/Generated/FREERTOS/queue.c **** 	{
 3670              	 .loc 1 2046 0
 3671              	 .cfi_startproc
 3672              	 
 3673              	 
 3674              	 
 3675 0000 80B4     	 push {r7}
 3676              	.LCFI130:
 3677              	 .cfi_def_cfa_offset 4
 3678              	 .cfi_offset 7,-4
 3679 0002 85B0     	 sub sp,sp,#20
 3680              	.LCFI131:
 3681              	 .cfi_def_cfa_offset 24
 3682 0004 00AF     	 add r7,sp,#0
 3683              	.LCFI132:
 3684              	 .cfi_def_cfa_register 7
 3685 0006 7860     	 str r0,[r7,#4]
2047:../Dave/Generated/FREERTOS/queue.c **** 	UBaseType_t uxHighestPriorityOfWaitingTasks;
2048:../Dave/Generated/FREERTOS/queue.c **** 
2049:../Dave/Generated/FREERTOS/queue.c **** 		/* If a task waiting for a mutex causes the mutex holder to inherit a
2050:../Dave/Generated/FREERTOS/queue.c **** 		priority, but the waiting task times out, then the holder should
2051:../Dave/Generated/FREERTOS/queue.c **** 		disinherit the priority - but only down to the highest priority of any
2052:../Dave/Generated/FREERTOS/queue.c **** 		other tasks that are waiting for the same mutex.  For this purpose,
2053:../Dave/Generated/FREERTOS/queue.c **** 		return the priority of the highest priority task that is waiting for the
2054:../Dave/Generated/FREERTOS/queue.c **** 		mutex. */
2055:../Dave/Generated/FREERTOS/queue.c **** 		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
 3686              	 .loc 1 2055 0
 3687 0008 7B68     	 ldr r3,[r7,#4]
 3688 000a 5B6A     	 ldr r3,[r3,#36]
 3689 000c 002B     	 cmp r3,#0
 3690 000e 06D0     	 beq .L261
2056:../Dave/Generated/FREERTOS/queue.c **** 		{
2057:../Dave/Generated/FREERTOS/queue.c **** 			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET
 3691              	 .loc 1 2057 0
 3692 0010 7B68     	 ldr r3,[r7,#4]
 3693 0012 1B6B     	 ldr r3,[r3,#48]
 3694 0014 1B68     	 ldr r3,[r3]
 3695 0016 C3F10603 	 rsb r3,r3,#6
 3696 001a FB60     	 str r3,[r7,#12]
 3697 001c 01E0     	 b .L262
 3698              	.L261:
2058:../Dave/Generated/FREERTOS/queue.c **** 		}
2059:../Dave/Generated/FREERTOS/queue.c **** 		else
2060:../Dave/Generated/FREERTOS/queue.c **** 		{
2061:../Dave/Generated/FREERTOS/queue.c **** 			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
 3699              	 .loc 1 2061 0
 3700 001e 0023     	 movs r3,#0
 3701 0020 FB60     	 str r3,[r7,#12]
 3702              	.L262:
2062:../Dave/Generated/FREERTOS/queue.c **** 		}
2063:../Dave/Generated/FREERTOS/queue.c **** 
2064:../Dave/Generated/FREERTOS/queue.c **** 		return uxHighestPriorityOfWaitingTasks;
 3703              	 .loc 1 2064 0
 3704 0022 FB68     	 ldr r3,[r7,#12]
2065:../Dave/Generated/FREERTOS/queue.c **** 	}
 3705              	 .loc 1 2065 0
 3706 0024 1846     	 mov r0,r3
 3707 0026 1437     	 adds r7,r7,#20
 3708              	.LCFI133:
 3709              	 .cfi_def_cfa_offset 4
 3710 0028 BD46     	 mov sp,r7
 3711              	.LCFI134:
 3712              	 .cfi_def_cfa_register 13
 3713              	 
 3714 002a 5DF8047B 	 ldr r7,[sp],#4
 3715              	.LCFI135:
 3716              	 .cfi_restore 7
 3717              	 .cfi_def_cfa_offset 0
 3718 002e 7047     	 bx lr
 3719              	 .cfi_endproc
 3720              	.LFE162:
 3722              	 .section .text.prvCopyDataToQueue,"ax",%progbits
 3723              	 .align 2
 3724              	 .thumb
 3725              	 .thumb_func
 3727              	prvCopyDataToQueue:
 3728              	.LFB163:
2066:../Dave/Generated/FREERTOS/queue.c **** 
2067:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_MUTEXES */
2068:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2069:../Dave/Generated/FREERTOS/queue.c **** 
2070:../Dave/Generated/FREERTOS/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
2071:../Dave/Generated/FREERTOS/queue.c **** {
 3729              	 .loc 1 2071 0
 3730              	 .cfi_startproc
 3731              	 
 3732              	 
 3733 0000 80B5     	 push {r7,lr}
 3734              	.LCFI136:
 3735              	 .cfi_def_cfa_offset 8
 3736              	 .cfi_offset 7,-8
 3737              	 .cfi_offset 14,-4
 3738 0002 86B0     	 sub sp,sp,#24
 3739              	.LCFI137:
 3740              	 .cfi_def_cfa_offset 32
 3741 0004 00AF     	 add r7,sp,#0
 3742              	.LCFI138:
 3743              	 .cfi_def_cfa_register 7
 3744 0006 F860     	 str r0,[r7,#12]
 3745 0008 B960     	 str r1,[r7,#8]
 3746 000a 7A60     	 str r2,[r7,#4]
2072:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xReturn = pdFALSE;
 3747              	 .loc 1 2072 0
 3748 000c 0023     	 movs r3,#0
 3749 000e 7B61     	 str r3,[r7,#20]
2073:../Dave/Generated/FREERTOS/queue.c **** UBaseType_t uxMessagesWaiting;
2074:../Dave/Generated/FREERTOS/queue.c **** 
2075:../Dave/Generated/FREERTOS/queue.c **** 	/* This function is called from a critical section. */
2076:../Dave/Generated/FREERTOS/queue.c **** 
2077:../Dave/Generated/FREERTOS/queue.c **** 	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 3750              	 .loc 1 2077 0
 3751 0010 FB68     	 ldr r3,[r7,#12]
 3752 0012 9B6B     	 ldr r3,[r3,#56]
 3753 0014 3B61     	 str r3,[r7,#16]
2078:../Dave/Generated/FREERTOS/queue.c **** 
2079:../Dave/Generated/FREERTOS/queue.c **** 	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 3754              	 .loc 1 2079 0
 3755 0016 FB68     	 ldr r3,[r7,#12]
 3756 0018 1B6C     	 ldr r3,[r3,#64]
 3757 001a 002B     	 cmp r3,#0
 3758 001c 0DD1     	 bne .L265
2080:../Dave/Generated/FREERTOS/queue.c **** 	{
2081:../Dave/Generated/FREERTOS/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
2082:../Dave/Generated/FREERTOS/queue.c **** 		{
2083:../Dave/Generated/FREERTOS/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 3759              	 .loc 1 2083 0
 3760 001e FB68     	 ldr r3,[r7,#12]
 3761 0020 1B68     	 ldr r3,[r3]
 3762 0022 002B     	 cmp r3,#0
 3763 0024 4FD1     	 bne .L266
2084:../Dave/Generated/FREERTOS/queue.c **** 			{
2085:../Dave/Generated/FREERTOS/queue.c **** 				/* The mutex is no longer being held. */
2086:../Dave/Generated/FREERTOS/queue.c **** 				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 3764              	 .loc 1 2086 0
 3765 0026 FB68     	 ldr r3,[r7,#12]
 3766 0028 9B68     	 ldr r3,[r3,#8]
 3767 002a 1846     	 mov r0,r3
 3768 002c FFF7FEFF 	 bl xTaskPriorityDisinherit
 3769 0030 7861     	 str r0,[r7,#20]
2087:../Dave/Generated/FREERTOS/queue.c **** 				pxQueue->u.xSemaphore.xMutexHolder = NULL;
 3770              	 .loc 1 2087 0
 3771 0032 FB68     	 ldr r3,[r7,#12]
 3772 0034 0022     	 movs r2,#0
 3773 0036 9A60     	 str r2,[r3,#8]
 3774 0038 45E0     	 b .L266
 3775              	.L265:
2088:../Dave/Generated/FREERTOS/queue.c **** 			}
2089:../Dave/Generated/FREERTOS/queue.c **** 			else
2090:../Dave/Generated/FREERTOS/queue.c **** 			{
2091:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2092:../Dave/Generated/FREERTOS/queue.c **** 			}
2093:../Dave/Generated/FREERTOS/queue.c **** 		}
2094:../Dave/Generated/FREERTOS/queue.c **** 		#endif /* configUSE_MUTEXES */
2095:../Dave/Generated/FREERTOS/queue.c **** 	}
2096:../Dave/Generated/FREERTOS/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
 3776              	 .loc 1 2096 0
 3777 003a 7B68     	 ldr r3,[r7,#4]
 3778 003c 002B     	 cmp r3,#0
 3779 003e 1AD1     	 bne .L267
2097:../Dave/Generated/FREERTOS/queue.c **** 	{
2098:../Dave/Generated/FREERTOS/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); 
 3780              	 .loc 1 2098 0
 3781 0040 FB68     	 ldr r3,[r7,#12]
 3782 0042 5A68     	 ldr r2,[r3,#4]
 3783 0044 FB68     	 ldr r3,[r7,#12]
 3784 0046 1B6C     	 ldr r3,[r3,#64]
 3785 0048 1046     	 mov r0,r2
 3786 004a B968     	 ldr r1,[r7,#8]
 3787 004c 1A46     	 mov r2,r3
 3788 004e FFF7FEFF 	 bl memcpy
2099:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, esp
 3789              	 .loc 1 2099 0
 3790 0052 FB68     	 ldr r3,[r7,#12]
 3791 0054 5A68     	 ldr r2,[r3,#4]
 3792 0056 FB68     	 ldr r3,[r7,#12]
 3793 0058 1B6C     	 ldr r3,[r3,#64]
 3794 005a 1A44     	 add r2,r2,r3
 3795 005c FB68     	 ldr r3,[r7,#12]
 3796 005e 5A60     	 str r2,[r3,#4]
2100:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as co
 3797              	 .loc 1 2100 0
 3798 0060 FB68     	 ldr r3,[r7,#12]
 3799 0062 5A68     	 ldr r2,[r3,#4]
 3800 0064 FB68     	 ldr r3,[r7,#12]
 3801 0066 9B68     	 ldr r3,[r3,#8]
 3802 0068 9A42     	 cmp r2,r3
 3803 006a 2CD3     	 bcc .L266
2101:../Dave/Generated/FREERTOS/queue.c **** 		{
2102:../Dave/Generated/FREERTOS/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
 3804              	 .loc 1 2102 0
 3805 006c FB68     	 ldr r3,[r7,#12]
 3806 006e 1A68     	 ldr r2,[r3]
 3807 0070 FB68     	 ldr r3,[r7,#12]
 3808 0072 5A60     	 str r2,[r3,#4]
 3809 0074 27E0     	 b .L266
 3810              	.L267:
2103:../Dave/Generated/FREERTOS/queue.c **** 		}
2104:../Dave/Generated/FREERTOS/queue.c **** 		else
2105:../Dave/Generated/FREERTOS/queue.c **** 		{
2106:../Dave/Generated/FREERTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2107:../Dave/Generated/FREERTOS/queue.c **** 		}
2108:../Dave/Generated/FREERTOS/queue.c **** 	}
2109:../Dave/Generated/FREERTOS/queue.c **** 	else
2110:../Dave/Generated/FREERTOS/queue.c **** 	{
2111:../Dave/Generated/FREERTOS/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxIt
 3811              	 .loc 1 2111 0
 3812 0076 FB68     	 ldr r3,[r7,#12]
 3813 0078 DA68     	 ldr r2,[r3,#12]
 3814 007a FB68     	 ldr r3,[r7,#12]
 3815 007c 1B6C     	 ldr r3,[r3,#64]
 3816 007e 1046     	 mov r0,r2
 3817 0080 B968     	 ldr r1,[r7,#8]
 3818 0082 1A46     	 mov r2,r3
 3819 0084 FFF7FEFF 	 bl memcpy
2112:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 3820              	 .loc 1 2112 0
 3821 0088 FB68     	 ldr r3,[r7,#12]
 3822 008a DA68     	 ldr r2,[r3,#12]
 3823 008c FB68     	 ldr r3,[r7,#12]
 3824 008e 1B6C     	 ldr r3,[r3,#64]
 3825 0090 5B42     	 negs r3,r3
 3826 0092 1A44     	 add r2,r2,r3
 3827 0094 FB68     	 ldr r3,[r7,#12]
 3828 0096 DA60     	 str r2,[r3,#12]
2113:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as co
 3829              	 .loc 1 2113 0
 3830 0098 FB68     	 ldr r3,[r7,#12]
 3831 009a DA68     	 ldr r2,[r3,#12]
 3832 009c FB68     	 ldr r3,[r7,#12]
 3833 009e 1B68     	 ldr r3,[r3]
 3834 00a0 9A42     	 cmp r2,r3
 3835 00a2 07D2     	 bcs .L268
2114:../Dave/Generated/FREERTOS/queue.c **** 		{
2115:../Dave/Generated/FREERTOS/queue.c **** 			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 3836              	 .loc 1 2115 0
 3837 00a4 FB68     	 ldr r3,[r7,#12]
 3838 00a6 9A68     	 ldr r2,[r3,#8]
 3839 00a8 FB68     	 ldr r3,[r7,#12]
 3840 00aa 1B6C     	 ldr r3,[r3,#64]
 3841 00ac 5B42     	 negs r3,r3
 3842 00ae 1A44     	 add r2,r2,r3
 3843 00b0 FB68     	 ldr r3,[r7,#12]
 3844 00b2 DA60     	 str r2,[r3,#12]
 3845              	.L268:
2116:../Dave/Generated/FREERTOS/queue.c **** 		}
2117:../Dave/Generated/FREERTOS/queue.c **** 		else
2118:../Dave/Generated/FREERTOS/queue.c **** 		{
2119:../Dave/Generated/FREERTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2120:../Dave/Generated/FREERTOS/queue.c **** 		}
2121:../Dave/Generated/FREERTOS/queue.c **** 
2122:../Dave/Generated/FREERTOS/queue.c **** 		if( xPosition == queueOVERWRITE )
 3846              	 .loc 1 2122 0
 3847 00b4 7B68     	 ldr r3,[r7,#4]
 3848 00b6 022B     	 cmp r3,#2
 3849 00b8 05D1     	 bne .L266
2123:../Dave/Generated/FREERTOS/queue.c **** 		{
2124:../Dave/Generated/FREERTOS/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 3850              	 .loc 1 2124 0
 3851 00ba 3B69     	 ldr r3,[r7,#16]
 3852 00bc 002B     	 cmp r3,#0
 3853 00be 02D0     	 beq .L266
2125:../Dave/Generated/FREERTOS/queue.c **** 			{
2126:../Dave/Generated/FREERTOS/queue.c **** 				/* An item is not being added but overwritten, so subtract
2127:../Dave/Generated/FREERTOS/queue.c **** 				one from the recorded number of items in the queue so when
2128:../Dave/Generated/FREERTOS/queue.c **** 				one is added again below the number of recorded items remains
2129:../Dave/Generated/FREERTOS/queue.c **** 				correct. */
2130:../Dave/Generated/FREERTOS/queue.c **** 				--uxMessagesWaiting;
 3854              	 .loc 1 2130 0
 3855 00c0 3B69     	 ldr r3,[r7,#16]
 3856 00c2 013B     	 subs r3,r3,#1
 3857 00c4 3B61     	 str r3,[r7,#16]
 3858              	.L266:
2131:../Dave/Generated/FREERTOS/queue.c **** 			}
2132:../Dave/Generated/FREERTOS/queue.c **** 			else
2133:../Dave/Generated/FREERTOS/queue.c **** 			{
2134:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2135:../Dave/Generated/FREERTOS/queue.c **** 			}
2136:../Dave/Generated/FREERTOS/queue.c **** 		}
2137:../Dave/Generated/FREERTOS/queue.c **** 		else
2138:../Dave/Generated/FREERTOS/queue.c **** 		{
2139:../Dave/Generated/FREERTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2140:../Dave/Generated/FREERTOS/queue.c **** 		}
2141:../Dave/Generated/FREERTOS/queue.c **** 	}
2142:../Dave/Generated/FREERTOS/queue.c **** 
2143:../Dave/Generated/FREERTOS/queue.c **** 	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 3859              	 .loc 1 2143 0
 3860 00c6 3B69     	 ldr r3,[r7,#16]
 3861 00c8 5A1C     	 adds r2,r3,#1
 3862 00ca FB68     	 ldr r3,[r7,#12]
 3863 00cc 9A63     	 str r2,[r3,#56]
2144:../Dave/Generated/FREERTOS/queue.c **** 
2145:../Dave/Generated/FREERTOS/queue.c **** 	return xReturn;
 3864              	 .loc 1 2145 0
 3865 00ce 7B69     	 ldr r3,[r7,#20]
2146:../Dave/Generated/FREERTOS/queue.c **** }
 3866              	 .loc 1 2146 0
 3867 00d0 1846     	 mov r0,r3
 3868 00d2 1837     	 adds r7,r7,#24
 3869              	.LCFI139:
 3870              	 .cfi_def_cfa_offset 8
 3871 00d4 BD46     	 mov sp,r7
 3872              	.LCFI140:
 3873              	 .cfi_def_cfa_register 13
 3874              	 
 3875 00d6 80BD     	 pop {r7,pc}
 3876              	 .cfi_endproc
 3877              	.LFE163:
 3879              	 .section .text.prvCopyDataFromQueue,"ax",%progbits
 3880              	 .align 2
 3881              	 .thumb
 3882              	 .thumb_func
 3884              	prvCopyDataFromQueue:
 3885              	.LFB164:
2147:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2148:../Dave/Generated/FREERTOS/queue.c **** 
2149:../Dave/Generated/FREERTOS/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
2150:../Dave/Generated/FREERTOS/queue.c **** {
 3886              	 .loc 1 2150 0
 3887              	 .cfi_startproc
 3888              	 
 3889              	 
 3890 0000 80B5     	 push {r7,lr}
 3891              	.LCFI141:
 3892              	 .cfi_def_cfa_offset 8
 3893              	 .cfi_offset 7,-8
 3894              	 .cfi_offset 14,-4
 3895 0002 82B0     	 sub sp,sp,#8
 3896              	.LCFI142:
 3897              	 .cfi_def_cfa_offset 16
 3898 0004 00AF     	 add r7,sp,#0
 3899              	.LCFI143:
 3900              	 .cfi_def_cfa_register 7
 3901 0006 7860     	 str r0,[r7,#4]
 3902 0008 3960     	 str r1,[r7]
2151:../Dave/Generated/FREERTOS/queue.c **** 	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 3903              	 .loc 1 2151 0
 3904 000a 7B68     	 ldr r3,[r7,#4]
 3905 000c 1B6C     	 ldr r3,[r3,#64]
 3906 000e 002B     	 cmp r3,#0
 3907 0010 19D0     	 beq .L270
2152:../Dave/Generated/FREERTOS/queue.c **** 	{
2153:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char typ
 3908              	 .loc 1 2153 0
 3909 0012 7B68     	 ldr r3,[r7,#4]
 3910 0014 DA68     	 ldr r2,[r3,#12]
 3911 0016 7B68     	 ldr r3,[r7,#4]
 3912 0018 1B6C     	 ldr r3,[r3,#64]
 3913 001a 1A44     	 add r2,r2,r3
 3914 001c 7B68     	 ldr r3,[r7,#4]
 3915 001e DA60     	 str r2,[r3,#12]
2154:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justi
 3916              	 .loc 1 2154 0
 3917 0020 7B68     	 ldr r3,[r7,#4]
 3918 0022 DA68     	 ldr r2,[r3,#12]
 3919 0024 7B68     	 ldr r3,[r7,#4]
 3920 0026 9B68     	 ldr r3,[r3,#8]
 3921 0028 9A42     	 cmp r2,r3
 3922 002a 03D3     	 bcc .L272
2155:../Dave/Generated/FREERTOS/queue.c **** 		{
2156:../Dave/Generated/FREERTOS/queue.c **** 			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 3923              	 .loc 1 2156 0
 3924 002c 7B68     	 ldr r3,[r7,#4]
 3925 002e 1A68     	 ldr r2,[r3]
 3926 0030 7B68     	 ldr r3,[r7,#4]
 3927 0032 DA60     	 str r2,[r3,#12]
 3928              	.L272:
2157:../Dave/Generated/FREERTOS/queue.c **** 		}
2158:../Dave/Generated/FREERTOS/queue.c **** 		else
2159:../Dave/Generated/FREERTOS/queue.c **** 		{
2160:../Dave/Generated/FREERTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2161:../Dave/Generated/FREERTOS/queue.c **** 		}
2162:../Dave/Generated/FREERTOS/queue.c **** 		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue
 3929              	 .loc 1 2162 0
 3930 0034 7B68     	 ldr r3,[r7,#4]
 3931 0036 DA68     	 ldr r2,[r3,#12]
 3932 0038 7B68     	 ldr r3,[r7,#4]
 3933 003a 1B6C     	 ldr r3,[r3,#64]
 3934 003c 3868     	 ldr r0,[r7]
 3935 003e 1146     	 mov r1,r2
 3936 0040 1A46     	 mov r2,r3
 3937 0042 FFF7FEFF 	 bl memcpy
 3938              	.L270:
2163:../Dave/Generated/FREERTOS/queue.c **** 	}
2164:../Dave/Generated/FREERTOS/queue.c **** }
 3939              	 .loc 1 2164 0
 3940 0046 0837     	 adds r7,r7,#8
 3941              	.LCFI144:
 3942              	 .cfi_def_cfa_offset 8
 3943 0048 BD46     	 mov sp,r7
 3944              	.LCFI145:
 3945              	 .cfi_def_cfa_register 13
 3946              	 
 3947 004a 80BD     	 pop {r7,pc}
 3948              	 .cfi_endproc
 3949              	.LFE164:
 3951              	 .section .text.prvUnlockQueue,"ax",%progbits
 3952              	 .align 2
 3953              	 .thumb
 3954              	 .thumb_func
 3956              	prvUnlockQueue:
 3957              	.LFB165:
2165:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2166:../Dave/Generated/FREERTOS/queue.c **** 
2167:../Dave/Generated/FREERTOS/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue )
2168:../Dave/Generated/FREERTOS/queue.c **** {
 3958              	 .loc 1 2168 0
 3959              	 .cfi_startproc
 3960              	 
 3961              	 
 3962 0000 80B5     	 push {r7,lr}
 3963              	.LCFI146:
 3964              	 .cfi_def_cfa_offset 8
 3965              	 .cfi_offset 7,-8
 3966              	 .cfi_offset 14,-4
 3967 0002 84B0     	 sub sp,sp,#16
 3968              	.LCFI147:
 3969              	 .cfi_def_cfa_offset 24
 3970 0004 00AF     	 add r7,sp,#0
 3971              	.LCFI148:
 3972              	 .cfi_def_cfa_register 7
 3973 0006 7860     	 str r0,[r7,#4]
2169:../Dave/Generated/FREERTOS/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
2170:../Dave/Generated/FREERTOS/queue.c **** 
2171:../Dave/Generated/FREERTOS/queue.c **** 	/* The lock counts contains the number of extra data items placed or
2172:../Dave/Generated/FREERTOS/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
2173:../Dave/Generated/FREERTOS/queue.c **** 	locked items can be added or removed, but the event lists cannot be
2174:../Dave/Generated/FREERTOS/queue.c **** 	updated. */
2175:../Dave/Generated/FREERTOS/queue.c **** 	taskENTER_CRITICAL();
 3974              	 .loc 1 2175 0
 3975 0008 FFF7FEFF 	 bl vPortEnterCritical
 3976              	.LBB207:
2176:../Dave/Generated/FREERTOS/queue.c **** 	{
2177:../Dave/Generated/FREERTOS/queue.c **** 		int8_t cTxLock = pxQueue->cTxLock;
 3977              	 .loc 1 2177 0
 3978 000c 7B68     	 ldr r3,[r7,#4]
 3979 000e 93F84530 	 ldrb r3,[r3,#69]
 3980 0012 FB73     	 strb r3,[r7,#15]
2178:../Dave/Generated/FREERTOS/queue.c **** 
2179:../Dave/Generated/FREERTOS/queue.c **** 		/* See if data was added to the queue while it was locked. */
2180:../Dave/Generated/FREERTOS/queue.c **** 		while( cTxLock > queueLOCKED_UNMODIFIED )
 3981              	 .loc 1 2180 0
 3982 0014 21E0     	 b .L274
 3983              	.L279:
2181:../Dave/Generated/FREERTOS/queue.c **** 		{
2182:../Dave/Generated/FREERTOS/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
2183:../Dave/Generated/FREERTOS/queue.c **** 			blocked waiting for data to become available? */
2184:../Dave/Generated/FREERTOS/queue.c **** 			#if ( configUSE_QUEUE_SETS == 1 )
2185:../Dave/Generated/FREERTOS/queue.c **** 			{
2186:../Dave/Generated/FREERTOS/queue.c **** 				if( pxQueue->pxQueueSetContainer != NULL )
 3984              	 .loc 1 2186 0
 3985 0016 7B68     	 ldr r3,[r7,#4]
 3986 0018 9B6C     	 ldr r3,[r3,#72]
 3987 001a 002B     	 cmp r3,#0
 3988 001c 09D0     	 beq .L275
2187:../Dave/Generated/FREERTOS/queue.c **** 				{
2188:../Dave/Generated/FREERTOS/queue.c **** 					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
 3989              	 .loc 1 2188 0
 3990 001e 7868     	 ldr r0,[r7,#4]
 3991 0020 0021     	 movs r1,#0
 3992 0022 FFF7FEFF 	 bl prvNotifyQueueSetContainer
 3993 0026 0346     	 mov r3,r0
 3994 0028 002B     	 cmp r3,#0
 3995 002a 12D0     	 beq .L276
2189:../Dave/Generated/FREERTOS/queue.c **** 					{
2190:../Dave/Generated/FREERTOS/queue.c **** 						/* The queue is a member of a queue set, and posting to
2191:../Dave/Generated/FREERTOS/queue.c **** 						the queue set caused a higher priority task to unblock.
2192:../Dave/Generated/FREERTOS/queue.c **** 						A context switch is required. */
2193:../Dave/Generated/FREERTOS/queue.c **** 						vTaskMissedYield();
 3996              	 .loc 1 2193 0
 3997 002c FFF7FEFF 	 bl vTaskMissedYield
 3998 0030 0FE0     	 b .L276
 3999              	.L275:
2194:../Dave/Generated/FREERTOS/queue.c **** 					}
2195:../Dave/Generated/FREERTOS/queue.c **** 					else
2196:../Dave/Generated/FREERTOS/queue.c **** 					{
2197:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2198:../Dave/Generated/FREERTOS/queue.c **** 					}
2199:../Dave/Generated/FREERTOS/queue.c **** 				}
2200:../Dave/Generated/FREERTOS/queue.c **** 				else
2201:../Dave/Generated/FREERTOS/queue.c **** 				{
2202:../Dave/Generated/FREERTOS/queue.c **** 					/* Tasks that are removed from the event list will get
2203:../Dave/Generated/FREERTOS/queue.c **** 					added to the pending ready list as the scheduler is still
2204:../Dave/Generated/FREERTOS/queue.c **** 					suspended. */
2205:../Dave/Generated/FREERTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 4000              	 .loc 1 2205 0
 4001 0032 7B68     	 ldr r3,[r7,#4]
 4002 0034 5B6A     	 ldr r3,[r3,#36]
 4003 0036 002B     	 cmp r3,#0
 4004 0038 0AD0     	 beq .L277
2206:../Dave/Generated/FREERTOS/queue.c **** 					{
2207:../Dave/Generated/FREERTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 4005              	 .loc 1 2207 0
 4006 003a 7B68     	 ldr r3,[r7,#4]
 4007 003c 2433     	 adds r3,r3,#36
 4008 003e 1846     	 mov r0,r3
 4009 0040 FFF7FEFF 	 bl xTaskRemoveFromEventList
 4010 0044 0346     	 mov r3,r0
 4011 0046 002B     	 cmp r3,#0
 4012 0048 03D0     	 beq .L276
2208:../Dave/Generated/FREERTOS/queue.c **** 						{
2209:../Dave/Generated/FREERTOS/queue.c **** 							/* The task waiting has a higher priority so record that a
2210:../Dave/Generated/FREERTOS/queue.c **** 							context	switch is required. */
2211:../Dave/Generated/FREERTOS/queue.c **** 							vTaskMissedYield();
 4013              	 .loc 1 2211 0
 4014 004a FFF7FEFF 	 bl vTaskMissedYield
 4015 004e 00E0     	 b .L276
 4016              	.L277:
2212:../Dave/Generated/FREERTOS/queue.c **** 						}
2213:../Dave/Generated/FREERTOS/queue.c **** 						else
2214:../Dave/Generated/FREERTOS/queue.c **** 						{
2215:../Dave/Generated/FREERTOS/queue.c **** 							mtCOVERAGE_TEST_MARKER();
2216:../Dave/Generated/FREERTOS/queue.c **** 						}
2217:../Dave/Generated/FREERTOS/queue.c **** 					}
2218:../Dave/Generated/FREERTOS/queue.c **** 					else
2219:../Dave/Generated/FREERTOS/queue.c **** 					{
2220:../Dave/Generated/FREERTOS/queue.c **** 						break;
 4017              	 .loc 1 2220 0
 4018 0050 07E0     	 b .L278
 4019              	.L276:
2221:../Dave/Generated/FREERTOS/queue.c **** 					}
2222:../Dave/Generated/FREERTOS/queue.c **** 				}
2223:../Dave/Generated/FREERTOS/queue.c **** 			}
2224:../Dave/Generated/FREERTOS/queue.c **** 			#else /* configUSE_QUEUE_SETS */
2225:../Dave/Generated/FREERTOS/queue.c **** 			{
2226:../Dave/Generated/FREERTOS/queue.c **** 				/* Tasks that are removed from the event list will get added to
2227:../Dave/Generated/FREERTOS/queue.c **** 				the pending ready list as the scheduler is still suspended. */
2228:../Dave/Generated/FREERTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2229:../Dave/Generated/FREERTOS/queue.c **** 				{
2230:../Dave/Generated/FREERTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2231:../Dave/Generated/FREERTOS/queue.c **** 					{
2232:../Dave/Generated/FREERTOS/queue.c **** 						/* The task waiting has a higher priority so record that
2233:../Dave/Generated/FREERTOS/queue.c **** 						a context switch is required. */
2234:../Dave/Generated/FREERTOS/queue.c **** 						vTaskMissedYield();
2235:../Dave/Generated/FREERTOS/queue.c **** 					}
2236:../Dave/Generated/FREERTOS/queue.c **** 					else
2237:../Dave/Generated/FREERTOS/queue.c **** 					{
2238:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2239:../Dave/Generated/FREERTOS/queue.c **** 					}
2240:../Dave/Generated/FREERTOS/queue.c **** 				}
2241:../Dave/Generated/FREERTOS/queue.c **** 				else
2242:../Dave/Generated/FREERTOS/queue.c **** 				{
2243:../Dave/Generated/FREERTOS/queue.c **** 					break;
2244:../Dave/Generated/FREERTOS/queue.c **** 				}
2245:../Dave/Generated/FREERTOS/queue.c **** 			}
2246:../Dave/Generated/FREERTOS/queue.c **** 			#endif /* configUSE_QUEUE_SETS */
2247:../Dave/Generated/FREERTOS/queue.c **** 
2248:../Dave/Generated/FREERTOS/queue.c **** 			--cTxLock;
 4020              	 .loc 1 2248 0
 4021 0052 FB7B     	 ldrb r3,[r7,#15]
 4022 0054 013B     	 subs r3,r3,#1
 4023 0056 DBB2     	 uxtb r3,r3
 4024 0058 FB73     	 strb r3,[r7,#15]
 4025              	.L274:
2180:../Dave/Generated/FREERTOS/queue.c **** 		{
 4026              	 .loc 1 2180 0
 4027 005a 97F90F30 	 ldrsb r3,[r7,#15]
 4028 005e 002B     	 cmp r3,#0
 4029 0060 D9DC     	 bgt .L279
 4030              	.L278:
2249:../Dave/Generated/FREERTOS/queue.c **** 		}
2250:../Dave/Generated/FREERTOS/queue.c **** 
2251:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
 4031              	 .loc 1 2251 0
 4032 0062 7B68     	 ldr r3,[r7,#4]
 4033 0064 FF22     	 movs r2,#255
 4034 0066 83F84520 	 strb r2,[r3,#69]
 4035              	.LBE207:
2252:../Dave/Generated/FREERTOS/queue.c **** 	}
2253:../Dave/Generated/FREERTOS/queue.c **** 	taskEXIT_CRITICAL();
 4036              	 .loc 1 2253 0
 4037 006a FFF7FEFF 	 bl vPortExitCritical
2254:../Dave/Generated/FREERTOS/queue.c **** 
2255:../Dave/Generated/FREERTOS/queue.c **** 	/* Do the same for the Rx lock. */
2256:../Dave/Generated/FREERTOS/queue.c **** 	taskENTER_CRITICAL();
 4038              	 .loc 1 2256 0
 4039 006e FFF7FEFF 	 bl vPortEnterCritical
 4040              	.LBB208:
2257:../Dave/Generated/FREERTOS/queue.c **** 	{
2258:../Dave/Generated/FREERTOS/queue.c **** 		int8_t cRxLock = pxQueue->cRxLock;
 4041              	 .loc 1 2258 0
 4042 0072 7B68     	 ldr r3,[r7,#4]
 4043 0074 93F84430 	 ldrb r3,[r3,#68]
 4044 0078 BB73     	 strb r3,[r7,#14]
2259:../Dave/Generated/FREERTOS/queue.c **** 
2260:../Dave/Generated/FREERTOS/queue.c **** 		while( cRxLock > queueLOCKED_UNMODIFIED )
 4045              	 .loc 1 2260 0
 4046 007a 13E0     	 b .L280
 4047              	.L284:
2261:../Dave/Generated/FREERTOS/queue.c **** 		{
2262:../Dave/Generated/FREERTOS/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 4048              	 .loc 1 2262 0
 4049 007c 7B68     	 ldr r3,[r7,#4]
 4050 007e 1B69     	 ldr r3,[r3,#16]
 4051 0080 002B     	 cmp r3,#0
 4052 0082 0ED0     	 beq .L281
2263:../Dave/Generated/FREERTOS/queue.c **** 			{
2264:../Dave/Generated/FREERTOS/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 4053              	 .loc 1 2264 0
 4054 0084 7B68     	 ldr r3,[r7,#4]
 4055 0086 1033     	 adds r3,r3,#16
 4056 0088 1846     	 mov r0,r3
 4057 008a FFF7FEFF 	 bl xTaskRemoveFromEventList
 4058 008e 0346     	 mov r3,r0
 4059 0090 002B     	 cmp r3,#0
 4060 0092 01D0     	 beq .L282
2265:../Dave/Generated/FREERTOS/queue.c **** 				{
2266:../Dave/Generated/FREERTOS/queue.c **** 					vTaskMissedYield();
 4061              	 .loc 1 2266 0
 4062 0094 FFF7FEFF 	 bl vTaskMissedYield
 4063              	.L282:
2267:../Dave/Generated/FREERTOS/queue.c **** 				}
2268:../Dave/Generated/FREERTOS/queue.c **** 				else
2269:../Dave/Generated/FREERTOS/queue.c **** 				{
2270:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2271:../Dave/Generated/FREERTOS/queue.c **** 				}
2272:../Dave/Generated/FREERTOS/queue.c **** 
2273:../Dave/Generated/FREERTOS/queue.c **** 				--cRxLock;
 4064              	 .loc 1 2273 0
 4065 0098 BB7B     	 ldrb r3,[r7,#14]
 4066 009a 013B     	 subs r3,r3,#1
 4067 009c DBB2     	 uxtb r3,r3
 4068 009e BB73     	 strb r3,[r7,#14]
 4069 00a0 00E0     	 b .L280
 4070              	.L281:
2274:../Dave/Generated/FREERTOS/queue.c **** 			}
2275:../Dave/Generated/FREERTOS/queue.c **** 			else
2276:../Dave/Generated/FREERTOS/queue.c **** 			{
2277:../Dave/Generated/FREERTOS/queue.c **** 				break;
 4071              	 .loc 1 2277 0
 4072 00a2 03E0     	 b .L283
 4073              	.L280:
2260:../Dave/Generated/FREERTOS/queue.c **** 		{
 4074              	 .loc 1 2260 0
 4075 00a4 97F90E30 	 ldrsb r3,[r7,#14]
 4076 00a8 002B     	 cmp r3,#0
 4077 00aa E7DC     	 bgt .L284
 4078              	.L283:
2278:../Dave/Generated/FREERTOS/queue.c **** 			}
2279:../Dave/Generated/FREERTOS/queue.c **** 		}
2280:../Dave/Generated/FREERTOS/queue.c **** 
2281:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
 4079              	 .loc 1 2281 0
 4080 00ac 7B68     	 ldr r3,[r7,#4]
 4081 00ae FF22     	 movs r2,#255
 4082 00b0 83F84420 	 strb r2,[r3,#68]
 4083              	.LBE208:
2282:../Dave/Generated/FREERTOS/queue.c **** 	}
2283:../Dave/Generated/FREERTOS/queue.c **** 	taskEXIT_CRITICAL();
 4084              	 .loc 1 2283 0
 4085 00b4 FFF7FEFF 	 bl vPortExitCritical
2284:../Dave/Generated/FREERTOS/queue.c **** }
 4086              	 .loc 1 2284 0
 4087 00b8 1037     	 adds r7,r7,#16
 4088              	.LCFI149:
 4089              	 .cfi_def_cfa_offset 8
 4090 00ba BD46     	 mov sp,r7
 4091              	.LCFI150:
 4092              	 .cfi_def_cfa_register 13
 4093              	 
 4094 00bc 80BD     	 pop {r7,pc}
 4095              	 .cfi_endproc
 4096              	.LFE165:
 4098 00be 00BF     	 .section .text.prvIsQueueEmpty,"ax",%progbits
 4099              	 .align 2
 4100              	 .thumb
 4101              	 .thumb_func
 4103              	prvIsQueueEmpty:
 4104              	.LFB166:
2285:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2286:../Dave/Generated/FREERTOS/queue.c **** 
2287:../Dave/Generated/FREERTOS/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
2288:../Dave/Generated/FREERTOS/queue.c **** {
 4105              	 .loc 1 2288 0
 4106              	 .cfi_startproc
 4107              	 
 4108              	 
 4109 0000 80B5     	 push {r7,lr}
 4110              	.LCFI151:
 4111              	 .cfi_def_cfa_offset 8
 4112              	 .cfi_offset 7,-8
 4113              	 .cfi_offset 14,-4
 4114 0002 84B0     	 sub sp,sp,#16
 4115              	.LCFI152:
 4116              	 .cfi_def_cfa_offset 24
 4117 0004 00AF     	 add r7,sp,#0
 4118              	.LCFI153:
 4119              	 .cfi_def_cfa_register 7
 4120 0006 7860     	 str r0,[r7,#4]
2289:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xReturn;
2290:../Dave/Generated/FREERTOS/queue.c **** 
2291:../Dave/Generated/FREERTOS/queue.c **** 	taskENTER_CRITICAL();
 4121              	 .loc 1 2291 0
 4122 0008 FFF7FEFF 	 bl vPortEnterCritical
2292:../Dave/Generated/FREERTOS/queue.c **** 	{
2293:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 4123              	 .loc 1 2293 0
 4124 000c 7B68     	 ldr r3,[r7,#4]
 4125 000e 9B6B     	 ldr r3,[r3,#56]
 4126 0010 002B     	 cmp r3,#0
 4127 0012 02D1     	 bne .L286
2294:../Dave/Generated/FREERTOS/queue.c **** 		{
2295:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdTRUE;
 4128              	 .loc 1 2295 0
 4129 0014 0123     	 movs r3,#1
 4130 0016 FB60     	 str r3,[r7,#12]
 4131 0018 01E0     	 b .L287
 4132              	.L286:
2296:../Dave/Generated/FREERTOS/queue.c **** 		}
2297:../Dave/Generated/FREERTOS/queue.c **** 		else
2298:../Dave/Generated/FREERTOS/queue.c **** 		{
2299:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdFALSE;
 4133              	 .loc 1 2299 0
 4134 001a 0023     	 movs r3,#0
 4135 001c FB60     	 str r3,[r7,#12]
 4136              	.L287:
2300:../Dave/Generated/FREERTOS/queue.c **** 		}
2301:../Dave/Generated/FREERTOS/queue.c **** 	}
2302:../Dave/Generated/FREERTOS/queue.c **** 	taskEXIT_CRITICAL();
 4137              	 .loc 1 2302 0
 4138 001e FFF7FEFF 	 bl vPortExitCritical
2303:../Dave/Generated/FREERTOS/queue.c **** 
2304:../Dave/Generated/FREERTOS/queue.c **** 	return xReturn;
 4139              	 .loc 1 2304 0
 4140 0022 FB68     	 ldr r3,[r7,#12]
2305:../Dave/Generated/FREERTOS/queue.c **** }
 4141              	 .loc 1 2305 0
 4142 0024 1846     	 mov r0,r3
 4143 0026 1037     	 adds r7,r7,#16
 4144              	.LCFI154:
 4145              	 .cfi_def_cfa_offset 8
 4146 0028 BD46     	 mov sp,r7
 4147              	.LCFI155:
 4148              	 .cfi_def_cfa_register 13
 4149              	 
 4150 002a 80BD     	 pop {r7,pc}
 4151              	 .cfi_endproc
 4152              	.LFE166:
 4154              	 .section .text.xQueueIsQueueEmptyFromISR,"ax",%progbits
 4155              	 .align 2
 4156              	 .global xQueueIsQueueEmptyFromISR
 4157              	 .thumb
 4158              	 .thumb_func
 4160              	xQueueIsQueueEmptyFromISR:
 4161              	.LFB167:
2306:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2307:../Dave/Generated/FREERTOS/queue.c **** 
2308:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
2309:../Dave/Generated/FREERTOS/queue.c **** {
 4162              	 .loc 1 2309 0
 4163              	 .cfi_startproc
 4164              	 
 4165              	 
 4166              	 
 4167 0000 80B4     	 push {r7}
 4168              	.LCFI156:
 4169              	 .cfi_def_cfa_offset 4
 4170              	 .cfi_offset 7,-4
 4171 0002 87B0     	 sub sp,sp,#28
 4172              	.LCFI157:
 4173              	 .cfi_def_cfa_offset 32
 4174 0004 00AF     	 add r7,sp,#0
 4175              	.LCFI158:
 4176              	 .cfi_def_cfa_register 7
 4177 0006 7860     	 str r0,[r7,#4]
2310:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xReturn;
2311:../Dave/Generated/FREERTOS/queue.c **** Queue_t * const pxQueue = xQueue;
 4178              	 .loc 1 2311 0
 4179 0008 7B68     	 ldr r3,[r7,#4]
 4180 000a 3B61     	 str r3,[r7,#16]
2312:../Dave/Generated/FREERTOS/queue.c **** 
2313:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue );
 4181              	 .loc 1 2313 0
 4182 000c 3B69     	 ldr r3,[r7,#16]
 4183 000e 002B     	 cmp r3,#0
 4184 0010 09D1     	 bne .L290
 4185              	.LBB209:
 4186              	.LBB210:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 4187              	 .loc 2 195 0 discriminator 1
 4188              	
 4189 0012 4FF0FC03 	 mov r3,#252
 4190 0016 83F31188 	 msr basepri,r3
 4191 001a BFF36F8F 	 isb 
 4192 001e BFF34F8F 	 dsb 
 4193              	
 4194              	
 4195              	 .thumb
 4196 0022 FB60     	 str r3,[r7,#12]
 4197              	.L291:
 4198              	.LBE210:
 4199              	.LBE209:
 4200              	 .loc 1 2313 0 discriminator 1
 4201 0024 FEE7     	 b .L291
 4202              	.L290:
2314:../Dave/Generated/FREERTOS/queue.c **** 	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 4203              	 .loc 1 2314 0
 4204 0026 3B69     	 ldr r3,[r7,#16]
 4205 0028 9B6B     	 ldr r3,[r3,#56]
 4206 002a 002B     	 cmp r3,#0
 4207 002c 02D1     	 bne .L292
2315:../Dave/Generated/FREERTOS/queue.c **** 	{
2316:../Dave/Generated/FREERTOS/queue.c **** 		xReturn = pdTRUE;
 4208              	 .loc 1 2316 0
 4209 002e 0123     	 movs r3,#1
 4210 0030 7B61     	 str r3,[r7,#20]
 4211 0032 01E0     	 b .L293
 4212              	.L292:
2317:../Dave/Generated/FREERTOS/queue.c **** 	}
2318:../Dave/Generated/FREERTOS/queue.c **** 	else
2319:../Dave/Generated/FREERTOS/queue.c **** 	{
2320:../Dave/Generated/FREERTOS/queue.c **** 		xReturn = pdFALSE;
 4213              	 .loc 1 2320 0
 4214 0034 0023     	 movs r3,#0
 4215 0036 7B61     	 str r3,[r7,#20]
 4216              	.L293:
2321:../Dave/Generated/FREERTOS/queue.c **** 	}
2322:../Dave/Generated/FREERTOS/queue.c **** 
2323:../Dave/Generated/FREERTOS/queue.c **** 	return xReturn;
 4217              	 .loc 1 2323 0
 4218 0038 7B69     	 ldr r3,[r7,#20]
2324:../Dave/Generated/FREERTOS/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 4219              	 .loc 1 2324 0
 4220 003a 1846     	 mov r0,r3
 4221 003c 1C37     	 adds r7,r7,#28
 4222              	.LCFI159:
 4223              	 .cfi_def_cfa_offset 4
 4224 003e BD46     	 mov sp,r7
 4225              	.LCFI160:
 4226              	 .cfi_def_cfa_register 13
 4227              	 
 4228 0040 5DF8047B 	 ldr r7,[sp],#4
 4229              	.LCFI161:
 4230              	 .cfi_restore 7
 4231              	 .cfi_def_cfa_offset 0
 4232 0044 7047     	 bx lr
 4233              	 .cfi_endproc
 4234              	.LFE167:
 4236 0046 00BF     	 .section .text.prvIsQueueFull,"ax",%progbits
 4237              	 .align 2
 4238              	 .thumb
 4239              	 .thumb_func
 4241              	prvIsQueueFull:
 4242              	.LFB168:
2325:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2326:../Dave/Generated/FREERTOS/queue.c **** 
2327:../Dave/Generated/FREERTOS/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
2328:../Dave/Generated/FREERTOS/queue.c **** {
 4243              	 .loc 1 2328 0
 4244              	 .cfi_startproc
 4245              	 
 4246              	 
 4247 0000 80B5     	 push {r7,lr}
 4248              	.LCFI162:
 4249              	 .cfi_def_cfa_offset 8
 4250              	 .cfi_offset 7,-8
 4251              	 .cfi_offset 14,-4
 4252 0002 84B0     	 sub sp,sp,#16
 4253              	.LCFI163:
 4254              	 .cfi_def_cfa_offset 24
 4255 0004 00AF     	 add r7,sp,#0
 4256              	.LCFI164:
 4257              	 .cfi_def_cfa_register 7
 4258 0006 7860     	 str r0,[r7,#4]
2329:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xReturn;
2330:../Dave/Generated/FREERTOS/queue.c **** 
2331:../Dave/Generated/FREERTOS/queue.c **** 	taskENTER_CRITICAL();
 4259              	 .loc 1 2331 0
 4260 0008 FFF7FEFF 	 bl vPortEnterCritical
2332:../Dave/Generated/FREERTOS/queue.c **** 	{
2333:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 4261              	 .loc 1 2333 0
 4262 000c 7B68     	 ldr r3,[r7,#4]
 4263 000e 9A6B     	 ldr r2,[r3,#56]
 4264 0010 7B68     	 ldr r3,[r7,#4]
 4265 0012 DB6B     	 ldr r3,[r3,#60]
 4266 0014 9A42     	 cmp r2,r3
 4267 0016 02D1     	 bne .L296
2334:../Dave/Generated/FREERTOS/queue.c **** 		{
2335:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdTRUE;
 4268              	 .loc 1 2335 0
 4269 0018 0123     	 movs r3,#1
 4270 001a FB60     	 str r3,[r7,#12]
 4271 001c 01E0     	 b .L297
 4272              	.L296:
2336:../Dave/Generated/FREERTOS/queue.c **** 		}
2337:../Dave/Generated/FREERTOS/queue.c **** 		else
2338:../Dave/Generated/FREERTOS/queue.c **** 		{
2339:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdFALSE;
 4273              	 .loc 1 2339 0
 4274 001e 0023     	 movs r3,#0
 4275 0020 FB60     	 str r3,[r7,#12]
 4276              	.L297:
2340:../Dave/Generated/FREERTOS/queue.c **** 		}
2341:../Dave/Generated/FREERTOS/queue.c **** 	}
2342:../Dave/Generated/FREERTOS/queue.c **** 	taskEXIT_CRITICAL();
 4277              	 .loc 1 2342 0
 4278 0022 FFF7FEFF 	 bl vPortExitCritical
2343:../Dave/Generated/FREERTOS/queue.c **** 
2344:../Dave/Generated/FREERTOS/queue.c **** 	return xReturn;
 4279              	 .loc 1 2344 0
 4280 0026 FB68     	 ldr r3,[r7,#12]
2345:../Dave/Generated/FREERTOS/queue.c **** }
 4281              	 .loc 1 2345 0
 4282 0028 1846     	 mov r0,r3
 4283 002a 1037     	 adds r7,r7,#16
 4284              	.LCFI165:
 4285              	 .cfi_def_cfa_offset 8
 4286 002c BD46     	 mov sp,r7
 4287              	.LCFI166:
 4288              	 .cfi_def_cfa_register 13
 4289              	 
 4290 002e 80BD     	 pop {r7,pc}
 4291              	 .cfi_endproc
 4292              	.LFE168:
 4294              	 .section .text.xQueueIsQueueFullFromISR,"ax",%progbits
 4295              	 .align 2
 4296              	 .global xQueueIsQueueFullFromISR
 4297              	 .thumb
 4298              	 .thumb_func
 4300              	xQueueIsQueueFullFromISR:
 4301              	.LFB169:
2346:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2347:../Dave/Generated/FREERTOS/queue.c **** 
2348:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
2349:../Dave/Generated/FREERTOS/queue.c **** {
 4302              	 .loc 1 2349 0
 4303              	 .cfi_startproc
 4304              	 
 4305              	 
 4306              	 
 4307 0000 80B4     	 push {r7}
 4308              	.LCFI167:
 4309              	 .cfi_def_cfa_offset 4
 4310              	 .cfi_offset 7,-4
 4311 0002 87B0     	 sub sp,sp,#28
 4312              	.LCFI168:
 4313              	 .cfi_def_cfa_offset 32
 4314 0004 00AF     	 add r7,sp,#0
 4315              	.LCFI169:
 4316              	 .cfi_def_cfa_register 7
 4317 0006 7860     	 str r0,[r7,#4]
2350:../Dave/Generated/FREERTOS/queue.c **** BaseType_t xReturn;
2351:../Dave/Generated/FREERTOS/queue.c **** Queue_t * const pxQueue = xQueue;
 4318              	 .loc 1 2351 0
 4319 0008 7B68     	 ldr r3,[r7,#4]
 4320 000a 3B61     	 str r3,[r7,#16]
2352:../Dave/Generated/FREERTOS/queue.c **** 
2353:../Dave/Generated/FREERTOS/queue.c **** 	configASSERT( pxQueue );
 4321              	 .loc 1 2353 0
 4322 000c 3B69     	 ldr r3,[r7,#16]
 4323 000e 002B     	 cmp r3,#0
 4324 0010 09D1     	 bne .L300
 4325              	.LBB211:
 4326              	.LBB212:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 4327              	 .loc 2 195 0 discriminator 1
 4328              	
 4329 0012 4FF0FC03 	 mov r3,#252
 4330 0016 83F31188 	 msr basepri,r3
 4331 001a BFF36F8F 	 isb 
 4332 001e BFF34F8F 	 dsb 
 4333              	
 4334              	
 4335              	 .thumb
 4336 0022 FB60     	 str r3,[r7,#12]
 4337              	.L301:
 4338              	.LBE212:
 4339              	.LBE211:
 4340              	 .loc 1 2353 0 discriminator 1
 4341 0024 FEE7     	 b .L301
 4342              	.L300:
2354:../Dave/Generated/FREERTOS/queue.c **** 	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 4343              	 .loc 1 2354 0
 4344 0026 3B69     	 ldr r3,[r7,#16]
 4345 0028 9A6B     	 ldr r2,[r3,#56]
 4346 002a 3B69     	 ldr r3,[r7,#16]
 4347 002c DB6B     	 ldr r3,[r3,#60]
 4348 002e 9A42     	 cmp r2,r3
 4349 0030 02D1     	 bne .L302
2355:../Dave/Generated/FREERTOS/queue.c **** 	{
2356:../Dave/Generated/FREERTOS/queue.c **** 		xReturn = pdTRUE;
 4350              	 .loc 1 2356 0
 4351 0032 0123     	 movs r3,#1
 4352 0034 7B61     	 str r3,[r7,#20]
 4353 0036 01E0     	 b .L303
 4354              	.L302:
2357:../Dave/Generated/FREERTOS/queue.c **** 	}
2358:../Dave/Generated/FREERTOS/queue.c **** 	else
2359:../Dave/Generated/FREERTOS/queue.c **** 	{
2360:../Dave/Generated/FREERTOS/queue.c **** 		xReturn = pdFALSE;
 4355              	 .loc 1 2360 0
 4356 0038 0023     	 movs r3,#0
 4357 003a 7B61     	 str r3,[r7,#20]
 4358              	.L303:
2361:../Dave/Generated/FREERTOS/queue.c **** 	}
2362:../Dave/Generated/FREERTOS/queue.c **** 
2363:../Dave/Generated/FREERTOS/queue.c **** 	return xReturn;
 4359              	 .loc 1 2363 0
 4360 003c 7B69     	 ldr r3,[r7,#20]
2364:../Dave/Generated/FREERTOS/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 4361              	 .loc 1 2364 0
 4362 003e 1846     	 mov r0,r3
 4363 0040 1C37     	 adds r7,r7,#28
 4364              	.LCFI170:
 4365              	 .cfi_def_cfa_offset 4
 4366 0042 BD46     	 mov sp,r7
 4367              	.LCFI171:
 4368              	 .cfi_def_cfa_register 13
 4369              	 
 4370 0044 5DF8047B 	 ldr r7,[sp],#4
 4371              	.LCFI172:
 4372              	 .cfi_restore 7
 4373              	 .cfi_def_cfa_offset 0
 4374 0048 7047     	 bx lr
 4375              	 .cfi_endproc
 4376              	.LFE169:
 4378 004a 00BF     	 .section .text.vQueueAddToRegistry,"ax",%progbits
 4379              	 .align 2
 4380              	 .global vQueueAddToRegistry
 4381              	 .thumb
 4382              	 .thumb_func
 4384              	vQueueAddToRegistry:
 4385              	.LFB170:
2365:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2366:../Dave/Generated/FREERTOS/queue.c **** 
2367:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2368:../Dave/Generated/FREERTOS/queue.c **** 
2369:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait 
2370:../Dave/Generated/FREERTOS/queue.c **** 	{
2371:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xReturn;
2372:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t * const pxQueue = xQueue;
2373:../Dave/Generated/FREERTOS/queue.c **** 
2374:../Dave/Generated/FREERTOS/queue.c **** 		/* If the queue is already full we may have to block.  A critical section
2375:../Dave/Generated/FREERTOS/queue.c **** 		is required to prevent an interrupt removing something from the queue
2376:../Dave/Generated/FREERTOS/queue.c **** 		between the check to see if the queue is full and blocking on the queue. */
2377:../Dave/Generated/FREERTOS/queue.c **** 		portDISABLE_INTERRUPTS();
2378:../Dave/Generated/FREERTOS/queue.c **** 		{
2379:../Dave/Generated/FREERTOS/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
2380:../Dave/Generated/FREERTOS/queue.c **** 			{
2381:../Dave/Generated/FREERTOS/queue.c **** 				/* The queue is full - do we want to block or just leave without
2382:../Dave/Generated/FREERTOS/queue.c **** 				posting? */
2383:../Dave/Generated/FREERTOS/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
2384:../Dave/Generated/FREERTOS/queue.c **** 				{
2385:../Dave/Generated/FREERTOS/queue.c **** 					/* As this is called from a coroutine we cannot block directly, but
2386:../Dave/Generated/FREERTOS/queue.c **** 					return indicating that we need to block. */
2387:../Dave/Generated/FREERTOS/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
2388:../Dave/Generated/FREERTOS/queue.c **** 					portENABLE_INTERRUPTS();
2389:../Dave/Generated/FREERTOS/queue.c **** 					return errQUEUE_BLOCKED;
2390:../Dave/Generated/FREERTOS/queue.c **** 				}
2391:../Dave/Generated/FREERTOS/queue.c **** 				else
2392:../Dave/Generated/FREERTOS/queue.c **** 				{
2393:../Dave/Generated/FREERTOS/queue.c **** 					portENABLE_INTERRUPTS();
2394:../Dave/Generated/FREERTOS/queue.c **** 					return errQUEUE_FULL;
2395:../Dave/Generated/FREERTOS/queue.c **** 				}
2396:../Dave/Generated/FREERTOS/queue.c **** 			}
2397:../Dave/Generated/FREERTOS/queue.c **** 		}
2398:../Dave/Generated/FREERTOS/queue.c **** 		portENABLE_INTERRUPTS();
2399:../Dave/Generated/FREERTOS/queue.c **** 
2400:../Dave/Generated/FREERTOS/queue.c **** 		portDISABLE_INTERRUPTS();
2401:../Dave/Generated/FREERTOS/queue.c **** 		{
2402:../Dave/Generated/FREERTOS/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2403:../Dave/Generated/FREERTOS/queue.c **** 			{
2404:../Dave/Generated/FREERTOS/queue.c **** 				/* There is room in the queue, copy the data into the queue. */
2405:../Dave/Generated/FREERTOS/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2406:../Dave/Generated/FREERTOS/queue.c **** 				xReturn = pdPASS;
2407:../Dave/Generated/FREERTOS/queue.c **** 
2408:../Dave/Generated/FREERTOS/queue.c **** 				/* Were any co-routines waiting for data to become available? */
2409:../Dave/Generated/FREERTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2410:../Dave/Generated/FREERTOS/queue.c **** 				{
2411:../Dave/Generated/FREERTOS/queue.c **** 					/* In this instance the co-routine could be placed directly
2412:../Dave/Generated/FREERTOS/queue.c **** 					into the ready list as we are within a critical section.
2413:../Dave/Generated/FREERTOS/queue.c **** 					Instead the same pending ready list mechanism is used as if
2414:../Dave/Generated/FREERTOS/queue.c **** 					the event were caused from within an interrupt. */
2415:../Dave/Generated/FREERTOS/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2416:../Dave/Generated/FREERTOS/queue.c **** 					{
2417:../Dave/Generated/FREERTOS/queue.c **** 						/* The co-routine waiting has a higher priority so record
2418:../Dave/Generated/FREERTOS/queue.c **** 						that a yield might be appropriate. */
2419:../Dave/Generated/FREERTOS/queue.c **** 						xReturn = errQUEUE_YIELD;
2420:../Dave/Generated/FREERTOS/queue.c **** 					}
2421:../Dave/Generated/FREERTOS/queue.c **** 					else
2422:../Dave/Generated/FREERTOS/queue.c **** 					{
2423:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2424:../Dave/Generated/FREERTOS/queue.c **** 					}
2425:../Dave/Generated/FREERTOS/queue.c **** 				}
2426:../Dave/Generated/FREERTOS/queue.c **** 				else
2427:../Dave/Generated/FREERTOS/queue.c **** 				{
2428:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2429:../Dave/Generated/FREERTOS/queue.c **** 				}
2430:../Dave/Generated/FREERTOS/queue.c **** 			}
2431:../Dave/Generated/FREERTOS/queue.c **** 			else
2432:../Dave/Generated/FREERTOS/queue.c **** 			{
2433:../Dave/Generated/FREERTOS/queue.c **** 				xReturn = errQUEUE_FULL;
2434:../Dave/Generated/FREERTOS/queue.c **** 			}
2435:../Dave/Generated/FREERTOS/queue.c **** 		}
2436:../Dave/Generated/FREERTOS/queue.c **** 		portENABLE_INTERRUPTS();
2437:../Dave/Generated/FREERTOS/queue.c **** 
2438:../Dave/Generated/FREERTOS/queue.c **** 		return xReturn;
2439:../Dave/Generated/FREERTOS/queue.c **** 	}
2440:../Dave/Generated/FREERTOS/queue.c **** 
2441:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_CO_ROUTINES */
2442:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2443:../Dave/Generated/FREERTOS/queue.c **** 
2444:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2445:../Dave/Generated/FREERTOS/queue.c **** 
2446:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
2447:../Dave/Generated/FREERTOS/queue.c **** 	{
2448:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xReturn;
2449:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t * const pxQueue = xQueue;
2450:../Dave/Generated/FREERTOS/queue.c **** 
2451:../Dave/Generated/FREERTOS/queue.c **** 		/* If the queue is already empty we may have to block.  A critical section
2452:../Dave/Generated/FREERTOS/queue.c **** 		is required to prevent an interrupt adding something to the queue
2453:../Dave/Generated/FREERTOS/queue.c **** 		between the check to see if the queue is empty and blocking on the queue. */
2454:../Dave/Generated/FREERTOS/queue.c **** 		portDISABLE_INTERRUPTS();
2455:../Dave/Generated/FREERTOS/queue.c **** 		{
2456:../Dave/Generated/FREERTOS/queue.c **** 			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
2457:../Dave/Generated/FREERTOS/queue.c **** 			{
2458:../Dave/Generated/FREERTOS/queue.c **** 				/* There are no messages in the queue, do we want to block or just
2459:../Dave/Generated/FREERTOS/queue.c **** 				leave with nothing? */
2460:../Dave/Generated/FREERTOS/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
2461:../Dave/Generated/FREERTOS/queue.c **** 				{
2462:../Dave/Generated/FREERTOS/queue.c **** 					/* As this is a co-routine we cannot block directly, but return
2463:../Dave/Generated/FREERTOS/queue.c **** 					indicating that we need to block. */
2464:../Dave/Generated/FREERTOS/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
2465:../Dave/Generated/FREERTOS/queue.c **** 					portENABLE_INTERRUPTS();
2466:../Dave/Generated/FREERTOS/queue.c **** 					return errQUEUE_BLOCKED;
2467:../Dave/Generated/FREERTOS/queue.c **** 				}
2468:../Dave/Generated/FREERTOS/queue.c **** 				else
2469:../Dave/Generated/FREERTOS/queue.c **** 				{
2470:../Dave/Generated/FREERTOS/queue.c **** 					portENABLE_INTERRUPTS();
2471:../Dave/Generated/FREERTOS/queue.c **** 					return errQUEUE_FULL;
2472:../Dave/Generated/FREERTOS/queue.c **** 				}
2473:../Dave/Generated/FREERTOS/queue.c **** 			}
2474:../Dave/Generated/FREERTOS/queue.c **** 			else
2475:../Dave/Generated/FREERTOS/queue.c **** 			{
2476:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2477:../Dave/Generated/FREERTOS/queue.c **** 			}
2478:../Dave/Generated/FREERTOS/queue.c **** 		}
2479:../Dave/Generated/FREERTOS/queue.c **** 		portENABLE_INTERRUPTS();
2480:../Dave/Generated/FREERTOS/queue.c **** 
2481:../Dave/Generated/FREERTOS/queue.c **** 		portDISABLE_INTERRUPTS();
2482:../Dave/Generated/FREERTOS/queue.c **** 		{
2483:../Dave/Generated/FREERTOS/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2484:../Dave/Generated/FREERTOS/queue.c **** 			{
2485:../Dave/Generated/FREERTOS/queue.c **** 				/* Data is available from the queue. */
2486:../Dave/Generated/FREERTOS/queue.c **** 				pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
2487:../Dave/Generated/FREERTOS/queue.c **** 				if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
2488:../Dave/Generated/FREERTOS/queue.c **** 				{
2489:../Dave/Generated/FREERTOS/queue.c **** 					pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
2490:../Dave/Generated/FREERTOS/queue.c **** 				}
2491:../Dave/Generated/FREERTOS/queue.c **** 				else
2492:../Dave/Generated/FREERTOS/queue.c **** 				{
2493:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2494:../Dave/Generated/FREERTOS/queue.c **** 				}
2495:../Dave/Generated/FREERTOS/queue.c **** 				--( pxQueue->uxMessagesWaiting );
2496:../Dave/Generated/FREERTOS/queue.c **** 				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQ
2497:../Dave/Generated/FREERTOS/queue.c **** 
2498:../Dave/Generated/FREERTOS/queue.c **** 				xReturn = pdPASS;
2499:../Dave/Generated/FREERTOS/queue.c **** 
2500:../Dave/Generated/FREERTOS/queue.c **** 				/* Were any co-routines waiting for space to become available? */
2501:../Dave/Generated/FREERTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2502:../Dave/Generated/FREERTOS/queue.c **** 				{
2503:../Dave/Generated/FREERTOS/queue.c **** 					/* In this instance the co-routine could be placed directly
2504:../Dave/Generated/FREERTOS/queue.c **** 					into the ready list as we are within a critical section.
2505:../Dave/Generated/FREERTOS/queue.c **** 					Instead the same pending ready list mechanism is used as if
2506:../Dave/Generated/FREERTOS/queue.c **** 					the event were caused from within an interrupt. */
2507:../Dave/Generated/FREERTOS/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2508:../Dave/Generated/FREERTOS/queue.c **** 					{
2509:../Dave/Generated/FREERTOS/queue.c **** 						xReturn = errQUEUE_YIELD;
2510:../Dave/Generated/FREERTOS/queue.c **** 					}
2511:../Dave/Generated/FREERTOS/queue.c **** 					else
2512:../Dave/Generated/FREERTOS/queue.c **** 					{
2513:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2514:../Dave/Generated/FREERTOS/queue.c **** 					}
2515:../Dave/Generated/FREERTOS/queue.c **** 				}
2516:../Dave/Generated/FREERTOS/queue.c **** 				else
2517:../Dave/Generated/FREERTOS/queue.c **** 				{
2518:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2519:../Dave/Generated/FREERTOS/queue.c **** 				}
2520:../Dave/Generated/FREERTOS/queue.c **** 			}
2521:../Dave/Generated/FREERTOS/queue.c **** 			else
2522:../Dave/Generated/FREERTOS/queue.c **** 			{
2523:../Dave/Generated/FREERTOS/queue.c **** 				xReturn = pdFAIL;
2524:../Dave/Generated/FREERTOS/queue.c **** 			}
2525:../Dave/Generated/FREERTOS/queue.c **** 		}
2526:../Dave/Generated/FREERTOS/queue.c **** 		portENABLE_INTERRUPTS();
2527:../Dave/Generated/FREERTOS/queue.c **** 
2528:../Dave/Generated/FREERTOS/queue.c **** 		return xReturn;
2529:../Dave/Generated/FREERTOS/queue.c **** 	}
2530:../Dave/Generated/FREERTOS/queue.c **** 
2531:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_CO_ROUTINES */
2532:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2533:../Dave/Generated/FREERTOS/queue.c **** 
2534:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2535:../Dave/Generated/FREERTOS/queue.c **** 
2536:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRou
2537:../Dave/Generated/FREERTOS/queue.c **** 	{
2538:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t * const pxQueue = xQueue;
2539:../Dave/Generated/FREERTOS/queue.c **** 
2540:../Dave/Generated/FREERTOS/queue.c **** 		/* Cannot block within an ISR so if there is no space on the queue then
2541:../Dave/Generated/FREERTOS/queue.c **** 		exit without doing anything. */
2542:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2543:../Dave/Generated/FREERTOS/queue.c **** 		{
2544:../Dave/Generated/FREERTOS/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2545:../Dave/Generated/FREERTOS/queue.c **** 
2546:../Dave/Generated/FREERTOS/queue.c **** 			/* We only want to wake one co-routine per ISR, so check that a
2547:../Dave/Generated/FREERTOS/queue.c **** 			co-routine has not already been woken. */
2548:../Dave/Generated/FREERTOS/queue.c **** 			if( xCoRoutinePreviouslyWoken == pdFALSE )
2549:../Dave/Generated/FREERTOS/queue.c **** 			{
2550:../Dave/Generated/FREERTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2551:../Dave/Generated/FREERTOS/queue.c **** 				{
2552:../Dave/Generated/FREERTOS/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2553:../Dave/Generated/FREERTOS/queue.c **** 					{
2554:../Dave/Generated/FREERTOS/queue.c **** 						return pdTRUE;
2555:../Dave/Generated/FREERTOS/queue.c **** 					}
2556:../Dave/Generated/FREERTOS/queue.c **** 					else
2557:../Dave/Generated/FREERTOS/queue.c **** 					{
2558:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2559:../Dave/Generated/FREERTOS/queue.c **** 					}
2560:../Dave/Generated/FREERTOS/queue.c **** 				}
2561:../Dave/Generated/FREERTOS/queue.c **** 				else
2562:../Dave/Generated/FREERTOS/queue.c **** 				{
2563:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2564:../Dave/Generated/FREERTOS/queue.c **** 				}
2565:../Dave/Generated/FREERTOS/queue.c **** 			}
2566:../Dave/Generated/FREERTOS/queue.c **** 			else
2567:../Dave/Generated/FREERTOS/queue.c **** 			{
2568:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2569:../Dave/Generated/FREERTOS/queue.c **** 			}
2570:../Dave/Generated/FREERTOS/queue.c **** 		}
2571:../Dave/Generated/FREERTOS/queue.c **** 		else
2572:../Dave/Generated/FREERTOS/queue.c **** 		{
2573:../Dave/Generated/FREERTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2574:../Dave/Generated/FREERTOS/queue.c **** 		}
2575:../Dave/Generated/FREERTOS/queue.c **** 
2576:../Dave/Generated/FREERTOS/queue.c **** 		return xCoRoutinePreviouslyWoken;
2577:../Dave/Generated/FREERTOS/queue.c **** 	}
2578:../Dave/Generated/FREERTOS/queue.c **** 
2579:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_CO_ROUTINES */
2580:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2581:../Dave/Generated/FREERTOS/queue.c **** 
2582:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2583:../Dave/Generated/FREERTOS/queue.c **** 
2584:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWo
2585:../Dave/Generated/FREERTOS/queue.c **** 	{
2586:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xReturn;
2587:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t * const pxQueue = xQueue;
2588:../Dave/Generated/FREERTOS/queue.c **** 
2589:../Dave/Generated/FREERTOS/queue.c **** 		/* We cannot block from an ISR, so check there is data available. If
2590:../Dave/Generated/FREERTOS/queue.c **** 		not then just leave without doing anything. */
2591:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2592:../Dave/Generated/FREERTOS/queue.c **** 		{
2593:../Dave/Generated/FREERTOS/queue.c **** 			/* Copy the data from the queue. */
2594:../Dave/Generated/FREERTOS/queue.c **** 			pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
2595:../Dave/Generated/FREERTOS/queue.c **** 			if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
2596:../Dave/Generated/FREERTOS/queue.c **** 			{
2597:../Dave/Generated/FREERTOS/queue.c **** 				pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
2598:../Dave/Generated/FREERTOS/queue.c **** 			}
2599:../Dave/Generated/FREERTOS/queue.c **** 			else
2600:../Dave/Generated/FREERTOS/queue.c **** 			{
2601:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2602:../Dave/Generated/FREERTOS/queue.c **** 			}
2603:../Dave/Generated/FREERTOS/queue.c **** 			--( pxQueue->uxMessagesWaiting );
2604:../Dave/Generated/FREERTOS/queue.c **** 			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQu
2605:../Dave/Generated/FREERTOS/queue.c **** 
2606:../Dave/Generated/FREERTOS/queue.c **** 			if( ( *pxCoRoutineWoken ) == pdFALSE )
2607:../Dave/Generated/FREERTOS/queue.c **** 			{
2608:../Dave/Generated/FREERTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2609:../Dave/Generated/FREERTOS/queue.c **** 				{
2610:../Dave/Generated/FREERTOS/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2611:../Dave/Generated/FREERTOS/queue.c **** 					{
2612:../Dave/Generated/FREERTOS/queue.c **** 						*pxCoRoutineWoken = pdTRUE;
2613:../Dave/Generated/FREERTOS/queue.c **** 					}
2614:../Dave/Generated/FREERTOS/queue.c **** 					else
2615:../Dave/Generated/FREERTOS/queue.c **** 					{
2616:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2617:../Dave/Generated/FREERTOS/queue.c **** 					}
2618:../Dave/Generated/FREERTOS/queue.c **** 				}
2619:../Dave/Generated/FREERTOS/queue.c **** 				else
2620:../Dave/Generated/FREERTOS/queue.c **** 				{
2621:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2622:../Dave/Generated/FREERTOS/queue.c **** 				}
2623:../Dave/Generated/FREERTOS/queue.c **** 			}
2624:../Dave/Generated/FREERTOS/queue.c **** 			else
2625:../Dave/Generated/FREERTOS/queue.c **** 			{
2626:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2627:../Dave/Generated/FREERTOS/queue.c **** 			}
2628:../Dave/Generated/FREERTOS/queue.c **** 
2629:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdPASS;
2630:../Dave/Generated/FREERTOS/queue.c **** 		}
2631:../Dave/Generated/FREERTOS/queue.c **** 		else
2632:../Dave/Generated/FREERTOS/queue.c **** 		{
2633:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdFAIL;
2634:../Dave/Generated/FREERTOS/queue.c **** 		}
2635:../Dave/Generated/FREERTOS/queue.c **** 
2636:../Dave/Generated/FREERTOS/queue.c **** 		return xReturn;
2637:../Dave/Generated/FREERTOS/queue.c **** 	}
2638:../Dave/Generated/FREERTOS/queue.c **** 
2639:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_CO_ROUTINES */
2640:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2641:../Dave/Generated/FREERTOS/queue.c **** 
2642:../Dave/Generated/FREERTOS/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2643:../Dave/Generated/FREERTOS/queue.c **** 
2644:../Dave/Generated/FREERTOS/queue.c **** 	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified
2645:../Dave/Generated/FREERTOS/queue.c **** 	{
 4386              	 .loc 1 2645 0
 4387              	 .cfi_startproc
 4388              	 
 4389              	 
 4390              	 
 4391 0000 80B4     	 push {r7}
 4392              	.LCFI173:
 4393              	 .cfi_def_cfa_offset 4
 4394              	 .cfi_offset 7,-4
 4395 0002 85B0     	 sub sp,sp,#20
 4396              	.LCFI174:
 4397              	 .cfi_def_cfa_offset 24
 4398 0004 00AF     	 add r7,sp,#0
 4399              	.LCFI175:
 4400              	 .cfi_def_cfa_register 7
 4401 0006 7860     	 str r0,[r7,#4]
 4402 0008 3960     	 str r1,[r7]
2646:../Dave/Generated/FREERTOS/queue.c **** 	UBaseType_t ux;
2647:../Dave/Generated/FREERTOS/queue.c **** 
2648:../Dave/Generated/FREERTOS/queue.c **** 		/* See if there is an empty space in the registry.  A NULL name denotes
2649:../Dave/Generated/FREERTOS/queue.c **** 		a free slot. */
2650:../Dave/Generated/FREERTOS/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 4403              	 .loc 1 2650 0
 4404 000a 0023     	 movs r3,#0
 4405 000c FB60     	 str r3,[r7,#12]
 4406 000e 14E0     	 b .L306
 4407              	.L309:
2651:../Dave/Generated/FREERTOS/queue.c **** 		{
2652:../Dave/Generated/FREERTOS/queue.c **** 			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 4408              	 .loc 1 2652 0
 4409 0010 0E4A     	 ldr r2,.L310
 4410 0012 FB68     	 ldr r3,[r7,#12]
 4411 0014 52F83330 	 ldr r3,[r2,r3,lsl#3]
 4412 0018 002B     	 cmp r3,#0
 4413 001a 0BD1     	 bne .L307
2653:../Dave/Generated/FREERTOS/queue.c **** 			{
2654:../Dave/Generated/FREERTOS/queue.c **** 				/* Store the information on this queue. */
2655:../Dave/Generated/FREERTOS/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 4414              	 .loc 1 2655 0
 4415 001c 0B49     	 ldr r1,.L310
 4416 001e FB68     	 ldr r3,[r7,#12]
 4417 0020 3A68     	 ldr r2,[r7]
 4418 0022 41F83320 	 str r2,[r1,r3,lsl#3]
2656:../Dave/Generated/FREERTOS/queue.c **** 				xQueueRegistry[ ux ].xHandle = xQueue;
 4419              	 .loc 1 2656 0
 4420 0026 094A     	 ldr r2,.L310
 4421 0028 FB68     	 ldr r3,[r7,#12]
 4422 002a DB00     	 lsls r3,r3,#3
 4423 002c 1344     	 add r3,r3,r2
 4424 002e 7A68     	 ldr r2,[r7,#4]
 4425 0030 5A60     	 str r2,[r3,#4]
2657:../Dave/Generated/FREERTOS/queue.c **** 
2658:../Dave/Generated/FREERTOS/queue.c **** 				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
2659:../Dave/Generated/FREERTOS/queue.c **** 				break;
 4426              	 .loc 1 2659 0
 4427 0032 05E0     	 b .L305
 4428              	.L307:
2650:../Dave/Generated/FREERTOS/queue.c **** 		{
 4429              	 .loc 1 2650 0 discriminator 2
 4430 0034 FB68     	 ldr r3,[r7,#12]
 4431 0036 0133     	 adds r3,r3,#1
 4432 0038 FB60     	 str r3,[r7,#12]
 4433              	.L306:
2650:../Dave/Generated/FREERTOS/queue.c **** 		{
 4434              	 .loc 1 2650 0 is_stmt 0 discriminator 1
 4435 003a FB68     	 ldr r3,[r7,#12]
 4436 003c 072B     	 cmp r3,#7
 4437 003e E7D9     	 bls .L309
 4438              	.L305:
2660:../Dave/Generated/FREERTOS/queue.c **** 			}
2661:../Dave/Generated/FREERTOS/queue.c **** 			else
2662:../Dave/Generated/FREERTOS/queue.c **** 			{
2663:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2664:../Dave/Generated/FREERTOS/queue.c **** 			}
2665:../Dave/Generated/FREERTOS/queue.c **** 		}
2666:../Dave/Generated/FREERTOS/queue.c **** 	}
 4439              	 .loc 1 2666 0 is_stmt 1
 4440 0040 1437     	 adds r7,r7,#20
 4441              	.LCFI176:
 4442              	 .cfi_def_cfa_offset 4
 4443 0042 BD46     	 mov sp,r7
 4444              	.LCFI177:
 4445              	 .cfi_def_cfa_register 13
 4446              	 
 4447 0044 5DF8047B 	 ldr r7,[sp],#4
 4448              	.LCFI178:
 4449              	 .cfi_restore 7
 4450              	 .cfi_def_cfa_offset 0
 4451 0048 7047     	 bx lr
 4452              	.L311:
 4453 004a 00BF     	 .align 2
 4454              	.L310:
 4455 004c 00000000 	 .word xQueueRegistry
 4456              	 .cfi_endproc
 4457              	.LFE170:
 4459              	 .section .text.pcQueueGetName,"ax",%progbits
 4460              	 .align 2
 4461              	 .global pcQueueGetName
 4462              	 .thumb
 4463              	 .thumb_func
 4465              	pcQueueGetName:
 4466              	.LFB171:
2667:../Dave/Generated/FREERTOS/queue.c **** 
2668:../Dave/Generated/FREERTOS/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2669:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2670:../Dave/Generated/FREERTOS/queue.c **** 
2671:../Dave/Generated/FREERTOS/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2672:../Dave/Generated/FREERTOS/queue.c **** 
2673:../Dave/Generated/FREERTOS/queue.c **** 	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed
2674:../Dave/Generated/FREERTOS/queue.c **** 	{
 4467              	 .loc 1 2674 0
 4468              	 .cfi_startproc
 4469              	 
 4470              	 
 4471              	 
 4472 0000 80B4     	 push {r7}
 4473              	.LCFI179:
 4474              	 .cfi_def_cfa_offset 4
 4475              	 .cfi_offset 7,-4
 4476 0002 85B0     	 sub sp,sp,#20
 4477              	.LCFI180:
 4478              	 .cfi_def_cfa_offset 24
 4479 0004 00AF     	 add r7,sp,#0
 4480              	.LCFI181:
 4481              	 .cfi_def_cfa_register 7
 4482 0006 7860     	 str r0,[r7,#4]
2675:../Dave/Generated/FREERTOS/queue.c **** 	UBaseType_t ux;
2676:../Dave/Generated/FREERTOS/queue.c **** 	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and singl
 4483              	 .loc 1 2676 0
 4484 0008 0023     	 movs r3,#0
 4485 000a BB60     	 str r3,[r7,#8]
2677:../Dave/Generated/FREERTOS/queue.c **** 
2678:../Dave/Generated/FREERTOS/queue.c **** 		/* Note there is nothing here to protect against another task adding or
2679:../Dave/Generated/FREERTOS/queue.c **** 		removing entries from the registry while it is being searched. */
2680:../Dave/Generated/FREERTOS/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 4486              	 .loc 1 2680 0
 4487 000c 0023     	 movs r3,#0
 4488 000e FB60     	 str r3,[r7,#12]
 4489 0010 10E0     	 b .L313
 4490              	.L316:
2681:../Dave/Generated/FREERTOS/queue.c **** 		{
2682:../Dave/Generated/FREERTOS/queue.c **** 			if( xQueueRegistry[ ux ].xHandle == xQueue )
 4491              	 .loc 1 2682 0
 4492 0012 0D4A     	 ldr r2,.L318
 4493 0014 FB68     	 ldr r3,[r7,#12]
 4494 0016 DB00     	 lsls r3,r3,#3
 4495 0018 1344     	 add r3,r3,r2
 4496 001a 5A68     	 ldr r2,[r3,#4]
 4497 001c 7B68     	 ldr r3,[r7,#4]
 4498 001e 9A42     	 cmp r2,r3
 4499 0020 05D1     	 bne .L314
2683:../Dave/Generated/FREERTOS/queue.c **** 			{
2684:../Dave/Generated/FREERTOS/queue.c **** 				pcReturn = xQueueRegistry[ ux ].pcQueueName;
 4500              	 .loc 1 2684 0
 4501 0022 094A     	 ldr r2,.L318
 4502 0024 FB68     	 ldr r3,[r7,#12]
 4503 0026 52F83330 	 ldr r3,[r2,r3,lsl#3]
 4504 002a BB60     	 str r3,[r7,#8]
2685:../Dave/Generated/FREERTOS/queue.c **** 				break;
 4505              	 .loc 1 2685 0
 4506 002c 05E0     	 b .L315
 4507              	.L314:
2680:../Dave/Generated/FREERTOS/queue.c **** 		{
 4508              	 .loc 1 2680 0 discriminator 2
 4509 002e FB68     	 ldr r3,[r7,#12]
 4510 0030 0133     	 adds r3,r3,#1
 4511 0032 FB60     	 str r3,[r7,#12]
 4512              	.L313:
2680:../Dave/Generated/FREERTOS/queue.c **** 		{
 4513              	 .loc 1 2680 0 is_stmt 0 discriminator 1
 4514 0034 FB68     	 ldr r3,[r7,#12]
 4515 0036 072B     	 cmp r3,#7
 4516 0038 EBD9     	 bls .L316
 4517              	.L315:
2686:../Dave/Generated/FREERTOS/queue.c **** 			}
2687:../Dave/Generated/FREERTOS/queue.c **** 			else
2688:../Dave/Generated/FREERTOS/queue.c **** 			{
2689:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2690:../Dave/Generated/FREERTOS/queue.c **** 			}
2691:../Dave/Generated/FREERTOS/queue.c **** 		}
2692:../Dave/Generated/FREERTOS/queue.c **** 
2693:../Dave/Generated/FREERTOS/queue.c **** 		return pcReturn;
 4518              	 .loc 1 2693 0 is_stmt 1
 4519 003a BB68     	 ldr r3,[r7,#8]
2694:../Dave/Generated/FREERTOS/queue.c **** 	} /*lint !e818 xQueue cannot be a pointer to const because it is a typedef. */
 4520              	 .loc 1 2694 0
 4521 003c 1846     	 mov r0,r3
 4522 003e 1437     	 adds r7,r7,#20
 4523              	.LCFI182:
 4524              	 .cfi_def_cfa_offset 4
 4525 0040 BD46     	 mov sp,r7
 4526              	.LCFI183:
 4527              	 .cfi_def_cfa_register 13
 4528              	 
 4529 0042 5DF8047B 	 ldr r7,[sp],#4
 4530              	.LCFI184:
 4531              	 .cfi_restore 7
 4532              	 .cfi_def_cfa_offset 0
 4533 0046 7047     	 bx lr
 4534              	.L319:
 4535              	 .align 2
 4536              	.L318:
 4537 0048 00000000 	 .word xQueueRegistry
 4538              	 .cfi_endproc
 4539              	.LFE171:
 4541              	 .section .text.vQueueUnregisterQueue,"ax",%progbits
 4542              	 .align 2
 4543              	 .global vQueueUnregisterQueue
 4544              	 .thumb
 4545              	 .thumb_func
 4547              	vQueueUnregisterQueue:
 4548              	.LFB172:
2695:../Dave/Generated/FREERTOS/queue.c **** 
2696:../Dave/Generated/FREERTOS/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2697:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2698:../Dave/Generated/FREERTOS/queue.c **** 
2699:../Dave/Generated/FREERTOS/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2700:../Dave/Generated/FREERTOS/queue.c **** 
2701:../Dave/Generated/FREERTOS/queue.c **** 	void vQueueUnregisterQueue( QueueHandle_t xQueue )
2702:../Dave/Generated/FREERTOS/queue.c **** 	{
 4549              	 .loc 1 2702 0
 4550              	 .cfi_startproc
 4551              	 
 4552              	 
 4553              	 
 4554 0000 80B4     	 push {r7}
 4555              	.LCFI185:
 4556              	 .cfi_def_cfa_offset 4
 4557              	 .cfi_offset 7,-4
 4558 0002 85B0     	 sub sp,sp,#20
 4559              	.LCFI186:
 4560              	 .cfi_def_cfa_offset 24
 4561 0004 00AF     	 add r7,sp,#0
 4562              	.LCFI187:
 4563              	 .cfi_def_cfa_register 7
 4564 0006 7860     	 str r0,[r7,#4]
2703:../Dave/Generated/FREERTOS/queue.c **** 	UBaseType_t ux;
2704:../Dave/Generated/FREERTOS/queue.c **** 
2705:../Dave/Generated/FREERTOS/queue.c **** 		/* See if the handle of the queue being unregistered in actually in the
2706:../Dave/Generated/FREERTOS/queue.c **** 		registry. */
2707:../Dave/Generated/FREERTOS/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 4565              	 .loc 1 2707 0
 4566 0008 0023     	 movs r3,#0
 4567 000a FB60     	 str r3,[r7,#12]
 4568 000c 16E0     	 b .L321
 4569              	.L324:
2708:../Dave/Generated/FREERTOS/queue.c **** 		{
2709:../Dave/Generated/FREERTOS/queue.c **** 			if( xQueueRegistry[ ux ].xHandle == xQueue )
 4570              	 .loc 1 2709 0
 4571 000e 0F4A     	 ldr r2,.L325
 4572 0010 FB68     	 ldr r3,[r7,#12]
 4573 0012 DB00     	 lsls r3,r3,#3
 4574 0014 1344     	 add r3,r3,r2
 4575 0016 5A68     	 ldr r2,[r3,#4]
 4576 0018 7B68     	 ldr r3,[r7,#4]
 4577 001a 9A42     	 cmp r2,r3
 4578 001c 0BD1     	 bne .L322
2710:../Dave/Generated/FREERTOS/queue.c **** 			{
2711:../Dave/Generated/FREERTOS/queue.c **** 				/* Set the name to NULL to show that this slot if free again. */
2712:../Dave/Generated/FREERTOS/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = NULL;
 4579              	 .loc 1 2712 0
 4580 001e 0B4A     	 ldr r2,.L325
 4581 0020 FB68     	 ldr r3,[r7,#12]
 4582 0022 0021     	 movs r1,#0
 4583 0024 42F83310 	 str r1,[r2,r3,lsl#3]
2713:../Dave/Generated/FREERTOS/queue.c **** 
2714:../Dave/Generated/FREERTOS/queue.c **** 				/* Set the handle to NULL to ensure the same queue handle cannot
2715:../Dave/Generated/FREERTOS/queue.c **** 				appear in the registry twice if it is added, removed, then
2716:../Dave/Generated/FREERTOS/queue.c **** 				added again. */
2717:../Dave/Generated/FREERTOS/queue.c **** 				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
 4584              	 .loc 1 2717 0
 4585 0028 084A     	 ldr r2,.L325
 4586 002a FB68     	 ldr r3,[r7,#12]
 4587 002c DB00     	 lsls r3,r3,#3
 4588 002e 1344     	 add r3,r3,r2
 4589 0030 0022     	 movs r2,#0
 4590 0032 5A60     	 str r2,[r3,#4]
2718:../Dave/Generated/FREERTOS/queue.c **** 				break;
 4591              	 .loc 1 2718 0
 4592 0034 05E0     	 b .L320
 4593              	.L322:
2707:../Dave/Generated/FREERTOS/queue.c **** 		{
 4594              	 .loc 1 2707 0 discriminator 2
 4595 0036 FB68     	 ldr r3,[r7,#12]
 4596 0038 0133     	 adds r3,r3,#1
 4597 003a FB60     	 str r3,[r7,#12]
 4598              	.L321:
2707:../Dave/Generated/FREERTOS/queue.c **** 		{
 4599              	 .loc 1 2707 0 is_stmt 0 discriminator 1
 4600 003c FB68     	 ldr r3,[r7,#12]
 4601 003e 072B     	 cmp r3,#7
 4602 0040 E5D9     	 bls .L324
 4603              	.L320:
2719:../Dave/Generated/FREERTOS/queue.c **** 			}
2720:../Dave/Generated/FREERTOS/queue.c **** 			else
2721:../Dave/Generated/FREERTOS/queue.c **** 			{
2722:../Dave/Generated/FREERTOS/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2723:../Dave/Generated/FREERTOS/queue.c **** 			}
2724:../Dave/Generated/FREERTOS/queue.c **** 		}
2725:../Dave/Generated/FREERTOS/queue.c **** 
2726:../Dave/Generated/FREERTOS/queue.c **** 	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 4604              	 .loc 1 2726 0 is_stmt 1
 4605 0042 1437     	 adds r7,r7,#20
 4606              	.LCFI188:
 4607              	 .cfi_def_cfa_offset 4
 4608 0044 BD46     	 mov sp,r7
 4609              	.LCFI189:
 4610              	 .cfi_def_cfa_register 13
 4611              	 
 4612 0046 5DF8047B 	 ldr r7,[sp],#4
 4613              	.LCFI190:
 4614              	 .cfi_restore 7
 4615              	 .cfi_def_cfa_offset 0
 4616 004a 7047     	 bx lr
 4617              	.L326:
 4618              	 .align 2
 4619              	.L325:
 4620 004c 00000000 	 .word xQueueRegistry
 4621              	 .cfi_endproc
 4622              	.LFE172:
 4624              	 .section .text.vQueueWaitForMessageRestricted,"ax",%progbits
 4625              	 .align 2
 4626              	 .global vQueueWaitForMessageRestricted
 4627              	 .thumb
 4628              	 .thumb_func
 4630              	vQueueWaitForMessageRestricted:
 4631              	.LFB173:
2727:../Dave/Generated/FREERTOS/queue.c **** 
2728:../Dave/Generated/FREERTOS/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2729:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2730:../Dave/Generated/FREERTOS/queue.c **** 
2731:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_TIMERS == 1 )
2732:../Dave/Generated/FREERTOS/queue.c **** 
2733:../Dave/Generated/FREERTOS/queue.c **** 	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType
2734:../Dave/Generated/FREERTOS/queue.c **** 	{
 4632              	 .loc 1 2734 0
 4633              	 .cfi_startproc
 4634              	 
 4635              	 
 4636 0000 80B5     	 push {r7,lr}
 4637              	.LCFI191:
 4638              	 .cfi_def_cfa_offset 8
 4639              	 .cfi_offset 7,-8
 4640              	 .cfi_offset 14,-4
 4641 0002 86B0     	 sub sp,sp,#24
 4642              	.LCFI192:
 4643              	 .cfi_def_cfa_offset 32
 4644 0004 00AF     	 add r7,sp,#0
 4645              	.LCFI193:
 4646              	 .cfi_def_cfa_register 7
 4647 0006 F860     	 str r0,[r7,#12]
 4648 0008 B960     	 str r1,[r7,#8]
 4649 000a 7A60     	 str r2,[r7,#4]
2735:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t * const pxQueue = xQueue;
 4650              	 .loc 1 2735 0
 4651 000c FB68     	 ldr r3,[r7,#12]
 4652 000e 7B61     	 str r3,[r7,#20]
2736:../Dave/Generated/FREERTOS/queue.c **** 
2737:../Dave/Generated/FREERTOS/queue.c **** 		/* This function should not be called by application code hence the
2738:../Dave/Generated/FREERTOS/queue.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
2739:../Dave/Generated/FREERTOS/queue.c **** 		designed for use by kernel code, and has special calling requirements.
2740:../Dave/Generated/FREERTOS/queue.c **** 		It can result in vListInsert() being called on a list that can only
2741:../Dave/Generated/FREERTOS/queue.c **** 		possibly ever have one item in it, so the list will be fast, but even
2742:../Dave/Generated/FREERTOS/queue.c **** 		so it should be called with the scheduler locked and not from a critical
2743:../Dave/Generated/FREERTOS/queue.c **** 		section. */
2744:../Dave/Generated/FREERTOS/queue.c **** 
2745:../Dave/Generated/FREERTOS/queue.c **** 		/* Only do anything if there are no messages in the queue.  This function
2746:../Dave/Generated/FREERTOS/queue.c **** 		will not actually cause the task to block, just place it on a blocked
2747:../Dave/Generated/FREERTOS/queue.c **** 		list.  It will not block until the scheduler is unlocked - at which
2748:../Dave/Generated/FREERTOS/queue.c **** 		time a yield will be performed.  If an item is added to the queue while
2749:../Dave/Generated/FREERTOS/queue.c **** 		the queue is locked, and the calling task blocks on the queue, then the
2750:../Dave/Generated/FREERTOS/queue.c **** 		calling task will be immediately unblocked when the queue is unlocked. */
2751:../Dave/Generated/FREERTOS/queue.c **** 		prvLockQueue( pxQueue );
 4653              	 .loc 1 2751 0
 4654 0010 FFF7FEFF 	 bl vPortEnterCritical
 4655 0014 7B69     	 ldr r3,[r7,#20]
 4656 0016 93F84430 	 ldrb r3,[r3,#68]
 4657 001a DBB2     	 uxtb r3,r3
 4658 001c 5BB2     	 sxtb r3,r3
 4659 001e B3F1FF3F 	 cmp r3,#-1
 4660 0022 03D1     	 bne .L328
 4661              	 .loc 1 2751 0 is_stmt 0 discriminator 1
 4662 0024 7B69     	 ldr r3,[r7,#20]
 4663 0026 0022     	 movs r2,#0
 4664 0028 83F84420 	 strb r2,[r3,#68]
 4665              	.L328:
 4666              	 .loc 1 2751 0 discriminator 3
 4667 002c 7B69     	 ldr r3,[r7,#20]
 4668 002e 93F84530 	 ldrb r3,[r3,#69]
 4669 0032 DBB2     	 uxtb r3,r3
 4670 0034 5BB2     	 sxtb r3,r3
 4671 0036 B3F1FF3F 	 cmp r3,#-1
 4672 003a 03D1     	 bne .L329
 4673              	 .loc 1 2751 0 discriminator 4
 4674 003c 7B69     	 ldr r3,[r7,#20]
 4675 003e 0022     	 movs r2,#0
 4676 0040 83F84520 	 strb r2,[r3,#69]
 4677              	.L329:
 4678              	 .loc 1 2751 0 discriminator 6
 4679 0044 FFF7FEFF 	 bl vPortExitCritical
2752:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 4680              	 .loc 1 2752 0 is_stmt 1 discriminator 6
 4681 0048 7B69     	 ldr r3,[r7,#20]
 4682 004a 9B6B     	 ldr r3,[r3,#56]
 4683 004c 002B     	 cmp r3,#0
 4684 004e 06D1     	 bne .L330
2753:../Dave/Generated/FREERTOS/queue.c **** 		{
2754:../Dave/Generated/FREERTOS/queue.c **** 			/* There is nothing in the queue, block for the specified period. */
2755:../Dave/Generated/FREERTOS/queue.c **** 			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefi
 4685              	 .loc 1 2755 0
 4686 0050 7B69     	 ldr r3,[r7,#20]
 4687 0052 2433     	 adds r3,r3,#36
 4688 0054 1846     	 mov r0,r3
 4689 0056 B968     	 ldr r1,[r7,#8]
 4690 0058 7A68     	 ldr r2,[r7,#4]
 4691 005a FFF7FEFF 	 bl vTaskPlaceOnEventListRestricted
 4692              	.L330:
2756:../Dave/Generated/FREERTOS/queue.c **** 		}
2757:../Dave/Generated/FREERTOS/queue.c **** 		else
2758:../Dave/Generated/FREERTOS/queue.c **** 		{
2759:../Dave/Generated/FREERTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2760:../Dave/Generated/FREERTOS/queue.c **** 		}
2761:../Dave/Generated/FREERTOS/queue.c **** 		prvUnlockQueue( pxQueue );
 4693              	 .loc 1 2761 0
 4694 005e 7869     	 ldr r0,[r7,#20]
 4695 0060 FFF7FEFF 	 bl prvUnlockQueue
2762:../Dave/Generated/FREERTOS/queue.c **** 	}
 4696              	 .loc 1 2762 0
 4697 0064 1837     	 adds r7,r7,#24
 4698              	.LCFI194:
 4699              	 .cfi_def_cfa_offset 8
 4700 0066 BD46     	 mov sp,r7
 4701              	.LCFI195:
 4702              	 .cfi_def_cfa_register 13
 4703              	 
 4704 0068 80BD     	 pop {r7,pc}
 4705              	 .cfi_endproc
 4706              	.LFE173:
 4708 006a 00BF     	 .section .text.xQueueCreateSet,"ax",%progbits
 4709              	 .align 2
 4710              	 .global xQueueCreateSet
 4711              	 .thumb
 4712              	 .thumb_func
 4714              	xQueueCreateSet:
 4715              	.LFB174:
2763:../Dave/Generated/FREERTOS/queue.c **** 
2764:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_TIMERS */
2765:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2766:../Dave/Generated/FREERTOS/queue.c **** 
2767:../Dave/Generated/FREERTOS/queue.c **** #if( ( configUSE_QUEUE_SETS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
2768:../Dave/Generated/FREERTOS/queue.c **** 
2769:../Dave/Generated/FREERTOS/queue.c **** 	QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength )
2770:../Dave/Generated/FREERTOS/queue.c **** 	{
 4716              	 .loc 1 2770 0
 4717              	 .cfi_startproc
 4718              	 
 4719              	 
 4720 0000 80B5     	 push {r7,lr}
 4721              	.LCFI196:
 4722              	 .cfi_def_cfa_offset 8
 4723              	 .cfi_offset 7,-8
 4724              	 .cfi_offset 14,-4
 4725 0002 84B0     	 sub sp,sp,#16
 4726              	.LCFI197:
 4727              	 .cfi_def_cfa_offset 24
 4728 0004 00AF     	 add r7,sp,#0
 4729              	.LCFI198:
 4730              	 .cfi_def_cfa_register 7
 4731 0006 7860     	 str r0,[r7,#4]
2771:../Dave/Generated/FREERTOS/queue.c **** 	QueueSetHandle_t pxQueue;
2772:../Dave/Generated/FREERTOS/queue.c **** 
2773:../Dave/Generated/FREERTOS/queue.c **** 		pxQueue = xQueueGenericCreate( uxEventQueueLength, ( UBaseType_t ) sizeof( Queue_t * ), queueQUEU
 4732              	 .loc 1 2773 0
 4733 0008 7868     	 ldr r0,[r7,#4]
 4734 000a 0421     	 movs r1,#4
 4735 000c 0022     	 movs r2,#0
 4736 000e FFF7FEFF 	 bl xQueueGenericCreate
 4737 0012 F860     	 str r0,[r7,#12]
2774:../Dave/Generated/FREERTOS/queue.c **** 
2775:../Dave/Generated/FREERTOS/queue.c **** 		return pxQueue;
 4738              	 .loc 1 2775 0
 4739 0014 FB68     	 ldr r3,[r7,#12]
2776:../Dave/Generated/FREERTOS/queue.c **** 	}
 4740              	 .loc 1 2776 0
 4741 0016 1846     	 mov r0,r3
 4742 0018 1037     	 adds r7,r7,#16
 4743              	.LCFI199:
 4744              	 .cfi_def_cfa_offset 8
 4745 001a BD46     	 mov sp,r7
 4746              	.LCFI200:
 4747              	 .cfi_def_cfa_register 13
 4748              	 
 4749 001c 80BD     	 pop {r7,pc}
 4750              	 .cfi_endproc
 4751              	.LFE174:
 4753 001e 00BF     	 .section .text.xQueueAddToSet,"ax",%progbits
 4754              	 .align 2
 4755              	 .global xQueueAddToSet
 4756              	 .thumb
 4757              	 .thumb_func
 4759              	xQueueAddToSet:
 4760              	.LFB175:
2777:../Dave/Generated/FREERTOS/queue.c **** 
2778:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_QUEUE_SETS */
2779:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2780:../Dave/Generated/FREERTOS/queue.c **** 
2781:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
2782:../Dave/Generated/FREERTOS/queue.c **** 
2783:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
2784:../Dave/Generated/FREERTOS/queue.c **** 	{
 4761              	 .loc 1 2784 0
 4762              	 .cfi_startproc
 4763              	 
 4764              	 
 4765 0000 80B5     	 push {r7,lr}
 4766              	.LCFI201:
 4767              	 .cfi_def_cfa_offset 8
 4768              	 .cfi_offset 7,-8
 4769              	 .cfi_offset 14,-4
 4770 0002 84B0     	 sub sp,sp,#16
 4771              	.LCFI202:
 4772              	 .cfi_def_cfa_offset 24
 4773 0004 00AF     	 add r7,sp,#0
 4774              	.LCFI203:
 4775              	 .cfi_def_cfa_register 7
 4776 0006 7860     	 str r0,[r7,#4]
 4777 0008 3960     	 str r1,[r7]
2785:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xReturn;
2786:../Dave/Generated/FREERTOS/queue.c **** 
2787:../Dave/Generated/FREERTOS/queue.c **** 		taskENTER_CRITICAL();
 4778              	 .loc 1 2787 0
 4779 000a FFF7FEFF 	 bl vPortEnterCritical
2788:../Dave/Generated/FREERTOS/queue.c **** 		{
2789:../Dave/Generated/FREERTOS/queue.c **** 			if( ( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer != NULL )
 4780              	 .loc 1 2789 0
 4781 000e 7B68     	 ldr r3,[r7,#4]
 4782 0010 9B6C     	 ldr r3,[r3,#72]
 4783 0012 002B     	 cmp r3,#0
 4784 0014 02D0     	 beq .L334
2790:../Dave/Generated/FREERTOS/queue.c **** 			{
2791:../Dave/Generated/FREERTOS/queue.c **** 				/* Cannot add a queue/semaphore to more than one queue set. */
2792:../Dave/Generated/FREERTOS/queue.c **** 				xReturn = pdFAIL;
 4785              	 .loc 1 2792 0
 4786 0016 0023     	 movs r3,#0
 4787 0018 FB60     	 str r3,[r7,#12]
 4788 001a 0BE0     	 b .L335
 4789              	.L334:
2793:../Dave/Generated/FREERTOS/queue.c **** 			}
2794:../Dave/Generated/FREERTOS/queue.c **** 			else if( ( ( Queue_t * ) xQueueOrSemaphore )->uxMessagesWaiting != ( UBaseType_t ) 0 )
 4790              	 .loc 1 2794 0
 4791 001c 7B68     	 ldr r3,[r7,#4]
 4792 001e 9B6B     	 ldr r3,[r3,#56]
 4793 0020 002B     	 cmp r3,#0
 4794 0022 02D0     	 beq .L336
2795:../Dave/Generated/FREERTOS/queue.c **** 			{
2796:../Dave/Generated/FREERTOS/queue.c **** 				/* Cannot add a queue/semaphore to a queue set if there are already
2797:../Dave/Generated/FREERTOS/queue.c **** 				items in the queue/semaphore. */
2798:../Dave/Generated/FREERTOS/queue.c **** 				xReturn = pdFAIL;
 4795              	 .loc 1 2798 0
 4796 0024 0023     	 movs r3,#0
 4797 0026 FB60     	 str r3,[r7,#12]
 4798 0028 04E0     	 b .L335
 4799              	.L336:
2799:../Dave/Generated/FREERTOS/queue.c **** 			}
2800:../Dave/Generated/FREERTOS/queue.c **** 			else
2801:../Dave/Generated/FREERTOS/queue.c **** 			{
2802:../Dave/Generated/FREERTOS/queue.c **** 				( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer = xQueueSet;
 4800              	 .loc 1 2802 0
 4801 002a 7B68     	 ldr r3,[r7,#4]
 4802 002c 3A68     	 ldr r2,[r7]
 4803 002e 9A64     	 str r2,[r3,#72]
2803:../Dave/Generated/FREERTOS/queue.c **** 				xReturn = pdPASS;
 4804              	 .loc 1 2803 0
 4805 0030 0123     	 movs r3,#1
 4806 0032 FB60     	 str r3,[r7,#12]
 4807              	.L335:
2804:../Dave/Generated/FREERTOS/queue.c **** 			}
2805:../Dave/Generated/FREERTOS/queue.c **** 		}
2806:../Dave/Generated/FREERTOS/queue.c **** 		taskEXIT_CRITICAL();
 4808              	 .loc 1 2806 0
 4809 0034 FFF7FEFF 	 bl vPortExitCritical
2807:../Dave/Generated/FREERTOS/queue.c **** 
2808:../Dave/Generated/FREERTOS/queue.c **** 		return xReturn;
 4810              	 .loc 1 2808 0
 4811 0038 FB68     	 ldr r3,[r7,#12]
2809:../Dave/Generated/FREERTOS/queue.c **** 	}
 4812              	 .loc 1 2809 0
 4813 003a 1846     	 mov r0,r3
 4814 003c 1037     	 adds r7,r7,#16
 4815              	.LCFI204:
 4816              	 .cfi_def_cfa_offset 8
 4817 003e BD46     	 mov sp,r7
 4818              	.LCFI205:
 4819              	 .cfi_def_cfa_register 13
 4820              	 
 4821 0040 80BD     	 pop {r7,pc}
 4822              	 .cfi_endproc
 4823              	.LFE175:
 4825 0042 00BF     	 .section .text.xQueueRemoveFromSet,"ax",%progbits
 4826              	 .align 2
 4827              	 .global xQueueRemoveFromSet
 4828              	 .thumb
 4829              	 .thumb_func
 4831              	xQueueRemoveFromSet:
 4832              	.LFB176:
2810:../Dave/Generated/FREERTOS/queue.c **** 
2811:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_QUEUE_SETS */
2812:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2813:../Dave/Generated/FREERTOS/queue.c **** 
2814:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
2815:../Dave/Generated/FREERTOS/queue.c **** 
2816:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueS
2817:../Dave/Generated/FREERTOS/queue.c **** 	{
 4833              	 .loc 1 2817 0
 4834              	 .cfi_startproc
 4835              	 
 4836              	 
 4837 0000 80B5     	 push {r7,lr}
 4838              	.LCFI206:
 4839              	 .cfi_def_cfa_offset 8
 4840              	 .cfi_offset 7,-8
 4841              	 .cfi_offset 14,-4
 4842 0002 84B0     	 sub sp,sp,#16
 4843              	.LCFI207:
 4844              	 .cfi_def_cfa_offset 24
 4845 0004 00AF     	 add r7,sp,#0
 4846              	.LCFI208:
 4847              	 .cfi_def_cfa_register 7
 4848 0006 7860     	 str r0,[r7,#4]
 4849 0008 3960     	 str r1,[r7]
2818:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xReturn;
2819:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t * const pxQueueOrSemaphore = ( Queue_t * ) xQueueOrSemaphore;
 4850              	 .loc 1 2819 0
 4851 000a 7B68     	 ldr r3,[r7,#4]
 4852 000c BB60     	 str r3,[r7,#8]
2820:../Dave/Generated/FREERTOS/queue.c **** 
2821:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueueOrSemaphore->pxQueueSetContainer != xQueueSet )
 4853              	 .loc 1 2821 0
 4854 000e BB68     	 ldr r3,[r7,#8]
 4855 0010 9A6C     	 ldr r2,[r3,#72]
 4856 0012 3B68     	 ldr r3,[r7]
 4857 0014 9A42     	 cmp r2,r3
 4858 0016 02D0     	 beq .L339
2822:../Dave/Generated/FREERTOS/queue.c **** 		{
2823:../Dave/Generated/FREERTOS/queue.c **** 			/* The queue was not a member of the set. */
2824:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdFAIL;
 4859              	 .loc 1 2824 0
 4860 0018 0023     	 movs r3,#0
 4861 001a FB60     	 str r3,[r7,#12]
 4862 001c 0FE0     	 b .L340
 4863              	.L339:
2825:../Dave/Generated/FREERTOS/queue.c **** 		}
2826:../Dave/Generated/FREERTOS/queue.c **** 		else if( pxQueueOrSemaphore->uxMessagesWaiting != ( UBaseType_t ) 0 )
 4864              	 .loc 1 2826 0
 4865 001e BB68     	 ldr r3,[r7,#8]
 4866 0020 9B6B     	 ldr r3,[r3,#56]
 4867 0022 002B     	 cmp r3,#0
 4868 0024 02D0     	 beq .L341
2827:../Dave/Generated/FREERTOS/queue.c **** 		{
2828:../Dave/Generated/FREERTOS/queue.c **** 			/* It is dangerous to remove a queue from a set when the queue is
2829:../Dave/Generated/FREERTOS/queue.c **** 			not empty because the queue set will still hold pending events for
2830:../Dave/Generated/FREERTOS/queue.c **** 			the queue. */
2831:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdFAIL;
 4869              	 .loc 1 2831 0
 4870 0026 0023     	 movs r3,#0
 4871 0028 FB60     	 str r3,[r7,#12]
 4872 002a 08E0     	 b .L340
 4873              	.L341:
2832:../Dave/Generated/FREERTOS/queue.c **** 		}
2833:../Dave/Generated/FREERTOS/queue.c **** 		else
2834:../Dave/Generated/FREERTOS/queue.c **** 		{
2835:../Dave/Generated/FREERTOS/queue.c **** 			taskENTER_CRITICAL();
 4874              	 .loc 1 2835 0
 4875 002c FFF7FEFF 	 bl vPortEnterCritical
2836:../Dave/Generated/FREERTOS/queue.c **** 			{
2837:../Dave/Generated/FREERTOS/queue.c **** 				/* The queue is no longer contained in the set. */
2838:../Dave/Generated/FREERTOS/queue.c **** 				pxQueueOrSemaphore->pxQueueSetContainer = NULL;
 4876              	 .loc 1 2838 0
 4877 0030 BB68     	 ldr r3,[r7,#8]
 4878 0032 0022     	 movs r2,#0
 4879 0034 9A64     	 str r2,[r3,#72]
2839:../Dave/Generated/FREERTOS/queue.c **** 			}
2840:../Dave/Generated/FREERTOS/queue.c **** 			taskEXIT_CRITICAL();
 4880              	 .loc 1 2840 0
 4881 0036 FFF7FEFF 	 bl vPortExitCritical
2841:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = pdPASS;
 4882              	 .loc 1 2841 0
 4883 003a 0123     	 movs r3,#1
 4884 003c FB60     	 str r3,[r7,#12]
 4885              	.L340:
2842:../Dave/Generated/FREERTOS/queue.c **** 		}
2843:../Dave/Generated/FREERTOS/queue.c **** 
2844:../Dave/Generated/FREERTOS/queue.c **** 		return xReturn;
 4886              	 .loc 1 2844 0
 4887 003e FB68     	 ldr r3,[r7,#12]
2845:../Dave/Generated/FREERTOS/queue.c **** 	} /*lint !e818 xQueueSet could not be declared as pointing to const as it is a typedef. */
 4888              	 .loc 1 2845 0
 4889 0040 1846     	 mov r0,r3
 4890 0042 1037     	 adds r7,r7,#16
 4891              	.LCFI209:
 4892              	 .cfi_def_cfa_offset 8
 4893 0044 BD46     	 mov sp,r7
 4894              	.LCFI210:
 4895              	 .cfi_def_cfa_register 13
 4896              	 
 4897 0046 80BD     	 pop {r7,pc}
 4898              	 .cfi_endproc
 4899              	.LFE176:
 4901              	 .section .text.xQueueSelectFromSet,"ax",%progbits
 4902              	 .align 2
 4903              	 .global xQueueSelectFromSet
 4904              	 .thumb
 4905              	 .thumb_func
 4907              	xQueueSelectFromSet:
 4908              	.LFB177:
2846:../Dave/Generated/FREERTOS/queue.c **** 
2847:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_QUEUE_SETS */
2848:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2849:../Dave/Generated/FREERTOS/queue.c **** 
2850:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
2851:../Dave/Generated/FREERTOS/queue.c **** 
2852:../Dave/Generated/FREERTOS/queue.c **** 	QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, TickType_t const xTicksToW
2853:../Dave/Generated/FREERTOS/queue.c **** 	{
 4909              	 .loc 1 2853 0
 4910              	 .cfi_startproc
 4911              	 
 4912              	 
 4913 0000 80B5     	 push {r7,lr}
 4914              	.LCFI211:
 4915              	 .cfi_def_cfa_offset 8
 4916              	 .cfi_offset 7,-8
 4917              	 .cfi_offset 14,-4
 4918 0002 84B0     	 sub sp,sp,#16
 4919              	.LCFI212:
 4920              	 .cfi_def_cfa_offset 24
 4921 0004 00AF     	 add r7,sp,#0
 4922              	.LCFI213:
 4923              	 .cfi_def_cfa_register 7
 4924 0006 7860     	 str r0,[r7,#4]
 4925 0008 3960     	 str r1,[r7]
2854:../Dave/Generated/FREERTOS/queue.c **** 	QueueSetMemberHandle_t xReturn = NULL;
 4926              	 .loc 1 2854 0
 4927 000a 0023     	 movs r3,#0
 4928 000c FB60     	 str r3,[r7,#12]
2855:../Dave/Generated/FREERTOS/queue.c **** 
2856:../Dave/Generated/FREERTOS/queue.c **** 		( void ) xQueueReceive( ( QueueHandle_t ) xQueueSet, &xReturn, xTicksToWait ); /*lint !e961 Casti
 4929              	 .loc 1 2856 0
 4930 000e 07F10C03 	 add r3,r7,#12
 4931 0012 7868     	 ldr r0,[r7,#4]
 4932 0014 1946     	 mov r1,r3
 4933 0016 3A68     	 ldr r2,[r7]
 4934 0018 FFF7FEFF 	 bl xQueueReceive
2857:../Dave/Generated/FREERTOS/queue.c **** 		return xReturn;
 4935              	 .loc 1 2857 0
 4936 001c FB68     	 ldr r3,[r7,#12]
2858:../Dave/Generated/FREERTOS/queue.c **** 	}
 4937              	 .loc 1 2858 0
 4938 001e 1846     	 mov r0,r3
 4939 0020 1037     	 adds r7,r7,#16
 4940              	.LCFI214:
 4941              	 .cfi_def_cfa_offset 8
 4942 0022 BD46     	 mov sp,r7
 4943              	.LCFI215:
 4944              	 .cfi_def_cfa_register 13
 4945              	 
 4946 0024 80BD     	 pop {r7,pc}
 4947              	 .cfi_endproc
 4948              	.LFE177:
 4950 0026 00BF     	 .section .text.xQueueSelectFromSetFromISR,"ax",%progbits
 4951              	 .align 2
 4952              	 .global xQueueSelectFromSetFromISR
 4953              	 .thumb
 4954              	 .thumb_func
 4956              	xQueueSelectFromSetFromISR:
 4957              	.LFB178:
2859:../Dave/Generated/FREERTOS/queue.c **** 
2860:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_QUEUE_SETS */
2861:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2862:../Dave/Generated/FREERTOS/queue.c **** 
2863:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
2864:../Dave/Generated/FREERTOS/queue.c **** 
2865:../Dave/Generated/FREERTOS/queue.c **** 	QueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet )
2866:../Dave/Generated/FREERTOS/queue.c **** 	{
 4958              	 .loc 1 2866 0
 4959              	 .cfi_startproc
 4960              	 
 4961              	 
 4962 0000 80B5     	 push {r7,lr}
 4963              	.LCFI216:
 4964              	 .cfi_def_cfa_offset 8
 4965              	 .cfi_offset 7,-8
 4966              	 .cfi_offset 14,-4
 4967 0002 84B0     	 sub sp,sp,#16
 4968              	.LCFI217:
 4969              	 .cfi_def_cfa_offset 24
 4970 0004 00AF     	 add r7,sp,#0
 4971              	.LCFI218:
 4972              	 .cfi_def_cfa_register 7
 4973 0006 7860     	 str r0,[r7,#4]
2867:../Dave/Generated/FREERTOS/queue.c **** 	QueueSetMemberHandle_t xReturn = NULL;
 4974              	 .loc 1 2867 0
 4975 0008 0023     	 movs r3,#0
 4976 000a FB60     	 str r3,[r7,#12]
2868:../Dave/Generated/FREERTOS/queue.c **** 
2869:../Dave/Generated/FREERTOS/queue.c **** 		( void ) xQueueReceiveFromISR( ( QueueHandle_t ) xQueueSet, &xReturn, NULL ); /*lint !e961 Castin
 4977              	 .loc 1 2869 0
 4978 000c 07F10C03 	 add r3,r7,#12
 4979 0010 7868     	 ldr r0,[r7,#4]
 4980 0012 1946     	 mov r1,r3
 4981 0014 0022     	 movs r2,#0
 4982 0016 FFF7FEFF 	 bl xQueueReceiveFromISR
2870:../Dave/Generated/FREERTOS/queue.c **** 		return xReturn;
 4983              	 .loc 1 2870 0
 4984 001a FB68     	 ldr r3,[r7,#12]
2871:../Dave/Generated/FREERTOS/queue.c **** 	}
 4985              	 .loc 1 2871 0
 4986 001c 1846     	 mov r0,r3
 4987 001e 1037     	 adds r7,r7,#16
 4988              	.LCFI219:
 4989              	 .cfi_def_cfa_offset 8
 4990 0020 BD46     	 mov sp,r7
 4991              	.LCFI220:
 4992              	 .cfi_def_cfa_register 13
 4993              	 
 4994 0022 80BD     	 pop {r7,pc}
 4995              	 .cfi_endproc
 4996              	.LFE178:
 4998              	 .section .text.prvNotifyQueueSetContainer,"ax",%progbits
 4999              	 .align 2
 5000              	 .thumb
 5001              	 .thumb_func
 5003              	prvNotifyQueueSetContainer:
 5004              	.LFB179:
2872:../Dave/Generated/FREERTOS/queue.c **** 
2873:../Dave/Generated/FREERTOS/queue.c **** #endif /* configUSE_QUEUE_SETS */
2874:../Dave/Generated/FREERTOS/queue.c **** /*-----------------------------------------------------------*/
2875:../Dave/Generated/FREERTOS/queue.c **** 
2876:../Dave/Generated/FREERTOS/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
2877:../Dave/Generated/FREERTOS/queue.c **** 
2878:../Dave/Generated/FREERTOS/queue.c **** 	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCop
2879:../Dave/Generated/FREERTOS/queue.c **** 	{
 5005              	 .loc 1 2879 0
 5006              	 .cfi_startproc
 5007              	 
 5008              	 
 5009 0000 80B5     	 push {r7,lr}
 5010              	.LCFI221:
 5011              	 .cfi_def_cfa_offset 8
 5012              	 .cfi_offset 7,-8
 5013              	 .cfi_offset 14,-4
 5014 0002 88B0     	 sub sp,sp,#32
 5015              	.LCFI222:
 5016              	 .cfi_def_cfa_offset 40
 5017 0004 00AF     	 add r7,sp,#0
 5018              	.LCFI223:
 5019              	 .cfi_def_cfa_register 7
 5020 0006 7860     	 str r0,[r7,#4]
 5021 0008 3960     	 str r1,[r7]
2880:../Dave/Generated/FREERTOS/queue.c **** 	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
 5022              	 .loc 1 2880 0
 5023 000a 7B68     	 ldr r3,[r7,#4]
 5024 000c 9B6C     	 ldr r3,[r3,#72]
 5025 000e BB61     	 str r3,[r7,#24]
2881:../Dave/Generated/FREERTOS/queue.c **** 	BaseType_t xReturn = pdFALSE;
 5026              	 .loc 1 2881 0
 5027 0010 0023     	 movs r3,#0
 5028 0012 FB61     	 str r3,[r7,#28]
2882:../Dave/Generated/FREERTOS/queue.c **** 
2883:../Dave/Generated/FREERTOS/queue.c **** 		/* This function must be called form a critical section. */
2884:../Dave/Generated/FREERTOS/queue.c **** 
2885:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( pxQueueSetContainer );
 5029              	 .loc 1 2885 0
 5030 0014 BB69     	 ldr r3,[r7,#24]
 5031 0016 002B     	 cmp r3,#0
 5032 0018 09D1     	 bne .L348
 5033              	.LBB213:
 5034              	.LBB214:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 5035              	 .loc 2 195 0 discriminator 1
 5036              	
 5037 001a 4FF0FC03 	 mov r3,#252
 5038 001e 83F31188 	 msr basepri,r3
 5039 0022 BFF36F8F 	 isb 
 5040 0026 BFF34F8F 	 dsb 
 5041              	
 5042              	
 5043              	 .thumb
 5044 002a 3B61     	 str r3,[r7,#16]
 5045              	.L349:
 5046              	.LBE214:
 5047              	.LBE213:
 5048              	 .loc 1 2885 0 discriminator 1
 5049 002c FEE7     	 b .L349
 5050              	.L348:
2886:../Dave/Generated/FREERTOS/queue.c **** 		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
 5051              	 .loc 1 2886 0
 5052 002e BB69     	 ldr r3,[r7,#24]
 5053 0030 9A6B     	 ldr r2,[r3,#56]
 5054 0032 BB69     	 ldr r3,[r7,#24]
 5055 0034 DB6B     	 ldr r3,[r3,#60]
 5056 0036 9A42     	 cmp r2,r3
 5057 0038 09D3     	 bcc .L350
 5058              	.LBB215:
 5059              	.LBB216:
 195:../Dave/Generated/FREERTOS/portable/GCC/portmacro.h **** 	(
 5060              	 .loc 2 195 0 discriminator 1
 5061              	
 5062 003a 4FF0FC03 	 mov r3,#252
 5063 003e 83F31188 	 msr basepri,r3
 5064 0042 BFF36F8F 	 isb 
 5065 0046 BFF34F8F 	 dsb 
 5066              	
 5067              	
 5068              	 .thumb
 5069 004a FB60     	 str r3,[r7,#12]
 5070              	.L351:
 5071              	.LBE216:
 5072              	.LBE215:
 5073              	 .loc 1 2886 0 discriminator 2
 5074 004c FEE7     	 b .L351
 5075              	.L350:
2887:../Dave/Generated/FREERTOS/queue.c **** 
2888:../Dave/Generated/FREERTOS/queue.c **** 		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
 5076              	 .loc 1 2888 0
 5077 004e BB69     	 ldr r3,[r7,#24]
 5078 0050 9A6B     	 ldr r2,[r3,#56]
 5079 0052 BB69     	 ldr r3,[r7,#24]
 5080 0054 DB6B     	 ldr r3,[r3,#60]
 5081 0056 9A42     	 cmp r2,r3
 5082 0058 26D2     	 bcs .L352
 5083              	.LBB217:
2889:../Dave/Generated/FREERTOS/queue.c **** 		{
2890:../Dave/Generated/FREERTOS/queue.c **** 			const int8_t cTxLock = pxQueueSetContainer->cTxLock;
 5084              	 .loc 1 2890 0
 5085 005a BB69     	 ldr r3,[r7,#24]
 5086 005c 93F84530 	 ldrb r3,[r3,#69]
 5087 0060 FB75     	 strb r3,[r7,#23]
2891:../Dave/Generated/FREERTOS/queue.c **** 
2892:../Dave/Generated/FREERTOS/queue.c **** 			traceQUEUE_SEND( pxQueueSetContainer );
2893:../Dave/Generated/FREERTOS/queue.c **** 
2894:../Dave/Generated/FREERTOS/queue.c **** 			/* The data copied is the handle of the queue that contains data. */
2895:../Dave/Generated/FREERTOS/queue.c **** 			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
 5088              	 .loc 1 2895 0
 5089 0062 3B1D     	 adds r3,r7,#4
 5090 0064 B869     	 ldr r0,[r7,#24]
 5091 0066 1946     	 mov r1,r3
 5092 0068 3A68     	 ldr r2,[r7]
 5093 006a FFF7FEFF 	 bl prvCopyDataToQueue
 5094 006e F861     	 str r0,[r7,#28]
2896:../Dave/Generated/FREERTOS/queue.c **** 
2897:../Dave/Generated/FREERTOS/queue.c **** 			if( cTxLock == queueUNLOCKED )
 5095              	 .loc 1 2897 0
 5096 0070 97F91730 	 ldrsb r3,[r7,#23]
 5097 0074 B3F1FF3F 	 cmp r3,#-1
 5098 0078 0ED1     	 bne .L353
2898:../Dave/Generated/FREERTOS/queue.c **** 			{
2899:../Dave/Generated/FREERTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
 5099              	 .loc 1 2899 0
 5100 007a BB69     	 ldr r3,[r7,#24]
 5101 007c 5B6A     	 ldr r3,[r3,#36]
 5102 007e 002B     	 cmp r3,#0
 5103 0080 12D0     	 beq .L354
2900:../Dave/Generated/FREERTOS/queue.c **** 				{
2901:../Dave/Generated/FREERTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
 5104              	 .loc 1 2901 0
 5105 0082 BB69     	 ldr r3,[r7,#24]
 5106 0084 2433     	 adds r3,r3,#36
 5107 0086 1846     	 mov r0,r3
 5108 0088 FFF7FEFF 	 bl xTaskRemoveFromEventList
 5109 008c 0346     	 mov r3,r0
 5110 008e 002B     	 cmp r3,#0
 5111 0090 0AD0     	 beq .L354
2902:../Dave/Generated/FREERTOS/queue.c **** 					{
2903:../Dave/Generated/FREERTOS/queue.c **** 						/* The task waiting has a higher priority. */
2904:../Dave/Generated/FREERTOS/queue.c **** 						xReturn = pdTRUE;
 5112              	 .loc 1 2904 0
 5113 0092 0123     	 movs r3,#1
 5114 0094 FB61     	 str r3,[r7,#28]
 5115 0096 07E0     	 b .L354
 5116              	.L353:
2905:../Dave/Generated/FREERTOS/queue.c **** 					}
2906:../Dave/Generated/FREERTOS/queue.c **** 					else
2907:../Dave/Generated/FREERTOS/queue.c **** 					{
2908:../Dave/Generated/FREERTOS/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2909:../Dave/Generated/FREERTOS/queue.c **** 					}
2910:../Dave/Generated/FREERTOS/queue.c **** 				}
2911:../Dave/Generated/FREERTOS/queue.c **** 				else
2912:../Dave/Generated/FREERTOS/queue.c **** 				{
2913:../Dave/Generated/FREERTOS/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2914:../Dave/Generated/FREERTOS/queue.c **** 				}
2915:../Dave/Generated/FREERTOS/queue.c **** 			}
2916:../Dave/Generated/FREERTOS/queue.c **** 			else
2917:../Dave/Generated/FREERTOS/queue.c **** 			{
2918:../Dave/Generated/FREERTOS/queue.c **** 				pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );
 5117              	 .loc 1 2918 0
 5118 0098 FB7D     	 ldrb r3,[r7,#23]
 5119 009a 0133     	 adds r3,r3,#1
 5120 009c DBB2     	 uxtb r3,r3
 5121 009e DAB2     	 uxtb r2,r3
 5122 00a0 BB69     	 ldr r3,[r7,#24]
 5123 00a2 83F84520 	 strb r2,[r3,#69]
 5124              	.LBE217:
 5125 00a6 FFE7     	 b .L352
 5126              	.L354:
 5127              	.L352:
2919:../Dave/Generated/FREERTOS/queue.c **** 			}
2920:../Dave/Generated/FREERTOS/queue.c **** 		}
2921:../Dave/Generated/FREERTOS/queue.c **** 		else
2922:../Dave/Generated/FREERTOS/queue.c **** 		{
2923:../Dave/Generated/FREERTOS/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2924:../Dave/Generated/FREERTOS/queue.c **** 		}
2925:../Dave/Generated/FREERTOS/queue.c **** 
2926:../Dave/Generated/FREERTOS/queue.c **** 		return xReturn;
 5128              	 .loc 1 2926 0
 5129 00a8 FB69     	 ldr r3,[r7,#28]
2927:../Dave/Generated/FREERTOS/queue.c **** 	}
 5130              	 .loc 1 2927 0
 5131 00aa 1846     	 mov r0,r3
 5132 00ac 2037     	 adds r7,r7,#32
 5133              	.LCFI224:
 5134              	 .cfi_def_cfa_offset 8
 5135 00ae BD46     	 mov sp,r7
 5136              	.LCFI225:
 5137              	 .cfi_def_cfa_register 13
 5138              	 
 5139 00b0 80BD     	 pop {r7,pc}
 5140              	 .cfi_endproc
 5141              	.LFE179:
 5143 00b2 00BF     	 .text
 5144              	.Letext0:
 5145              	 .file 3 "c:\\dave\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\lib\\gcc\\arm-none-eabi\\4.9.3\\include\\stddef.h"
 5146              	 .file 4 "c:\\dave\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 5147              	 .file 5 "c:\\dave\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 5148              	 .file 6 "../Dave/Generated/FREERTOS/list.h"
 5149              	 .file 7 "../Dave/Generated/FREERTOS/task.h"
 5150              	 .file 8 "../Dave/Generated/FREERTOS/queue.h"
 5151              	 .file 9 "C:/Users/Yoshi/Documents/GitHub/Software/01_jrg/03_VCUJR20/2021_07_25_VCU_jr20_Source/Libraries/CMSIS/Include/cmsis_gcc.h"
 5152              	 .file 10 "C:/Users/Yoshi/Documents/GitHub/Software/01_jrg/03_VCUJR20/2021_07_25_VCU_jr20_Source/Libraries/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 queue.c
                            *COM*:00000040 xQueueRegistry
    {standard input}:21     .text.xQueueGenericReset:00000000 $t
    {standard input}:26     .text.xQueueGenericReset:00000000 xQueueGenericReset
    {standard input}:172    .text.xQueueGenericReset:000000cc $d
    {standard input}:177    .text.xQueueGenericCreate:00000000 $t
    {standard input}:182    .text.xQueueGenericCreate:00000000 xQueueGenericCreate
    {standard input}:288    .text.prvInitialiseNewQueue:00000000 prvInitialiseNewQueue
    {standard input}:284    .text.prvInitialiseNewQueue:00000000 $t
    {standard input}:357    .text.prvInitialiseMutex:00000000 $t
    {standard input}:361    .text.prvInitialiseMutex:00000000 prvInitialiseMutex
    {standard input}:915    .text.xQueueGenericSend:00000000 xQueueGenericSend
    {standard input}:415    .text.xQueueCreateMutex:00000000 $t
    {standard input}:420    .text.xQueueCreateMutex:00000000 xQueueCreateMutex
    {standard input}:470    .text.xQueueGetMutexHolder:00000000 $t
    {standard input}:475    .text.xQueueGetMutexHolder:00000000 xQueueGetMutexHolder
    {standard input}:531    .text.xQueueGetMutexHolderFromISR:00000000 $t
    {standard input}:536    .text.xQueueGetMutexHolderFromISR:00000000 xQueueGetMutexHolderFromISR
    {standard input}:611    .text.xQueueGiveMutexRecursive:00000000 $t
    {standard input}:616    .text.xQueueGiveMutexRecursive:00000000 xQueueGiveMutexRecursive
    {standard input}:710    .text.xQueueTakeMutexRecursive:00000000 $t
    {standard input}:715    .text.xQueueTakeMutexRecursive:00000000 xQueueTakeMutexRecursive
    {standard input}:2164   .text.xQueueSemaphoreTake:00000000 xQueueSemaphoreTake
    {standard input}:810    .text.xQueueCreateCountingSemaphore:00000000 $t
    {standard input}:815    .text.xQueueCreateCountingSemaphore:00000000 xQueueCreateCountingSemaphore
    {standard input}:910    .text.xQueueGenericSend:00000000 $t
    {standard input}:3727   .text.prvCopyDataToQueue:00000000 prvCopyDataToQueue
    {standard input}:5003   .text.prvNotifyQueueSetContainer:00000000 prvNotifyQueueSetContainer
    {standard input}:4241   .text.prvIsQueueFull:00000000 prvIsQueueFull
    {standard input}:3956   .text.prvUnlockQueue:00000000 prvUnlockQueue
    {standard input}:1317   .text.xQueueGenericSend:00000238 $d
    {standard input}:1322   .text.xQueueGenericSendFromISR:00000000 $t
    {standard input}:1327   .text.xQueueGenericSendFromISR:00000000 xQueueGenericSendFromISR
    {standard input}:1589   .text.xQueueGiveFromISR:00000000 $t
    {standard input}:1594   .text.xQueueGiveFromISR:00000000 xQueueGiveFromISR
    {standard input}:1839   .text.xQueueReceive:00000000 $t
    {standard input}:1844   .text.xQueueReceive:00000000 xQueueReceive
    {standard input}:3884   .text.prvCopyDataFromQueue:00000000 prvCopyDataFromQueue
    {standard input}:4103   .text.prvIsQueueEmpty:00000000 prvIsQueueEmpty
    {standard input}:2154   .text.xQueueReceive:000001bc $d
    {standard input}:2159   .text.xQueueSemaphoreTake:00000000 $t
    {standard input}:3668   .text.prvGetDisinheritPriorityAfterTimeout:00000000 prvGetDisinheritPriorityAfterTimeout
    {standard input}:2527   .text.xQueueSemaphoreTake:00000210 $d
    {standard input}:2532   .text.xQueuePeek:00000000 $t
    {standard input}:2537   .text.xQueuePeek:00000000 xQueuePeek
    {standard input}:2850   .text.xQueuePeek:000001c0 $d
    {standard input}:2855   .text.xQueueReceiveFromISR:00000000 $t
    {standard input}:2860   .text.xQueueReceiveFromISR:00000000 xQueueReceiveFromISR
    {standard input}:3062   .text.xQueuePeekFromISR:00000000 $t
    {standard input}:3067   .text.xQueuePeekFromISR:00000000 xQueuePeekFromISR
    {standard input}:3248   .text.uxQueueMessagesWaiting:00000000 $t
    {standard input}:3253   .text.uxQueueMessagesWaiting:00000000 uxQueueMessagesWaiting
    {standard input}:3317   .text.uxQueueSpacesAvailable:00000000 $t
    {standard input}:3322   .text.uxQueueSpacesAvailable:00000000 uxQueueSpacesAvailable
    {standard input}:3392   .text.uxQueueMessagesWaitingFromISR:00000000 $t
    {standard input}:3397   .text.uxQueueMessagesWaitingFromISR:00000000 uxQueueMessagesWaitingFromISR
    {standard input}:3464   .text.vQueueDelete:00000000 $t
    {standard input}:3469   .text.vQueueDelete:00000000 vQueueDelete
    {standard input}:4547   .text.vQueueUnregisterQueue:00000000 vQueueUnregisterQueue
    {standard input}:3531   .text.uxQueueGetQueueNumber:00000000 $t
    {standard input}:3536   .text.uxQueueGetQueueNumber:00000000 uxQueueGetQueueNumber
    {standard input}:3575   .text.vQueueSetQueueNumber:00000000 $t
    {standard input}:3580   .text.vQueueSetQueueNumber:00000000 vQueueSetQueueNumber
    {standard input}:3620   .text.ucQueueGetQueueType:00000000 $t
    {standard input}:3625   .text.ucQueueGetQueueType:00000000 ucQueueGetQueueType
    {standard input}:3664   .text.prvGetDisinheritPriorityAfterTimeout:00000000 $t
    {standard input}:3723   .text.prvCopyDataToQueue:00000000 $t
    {standard input}:3880   .text.prvCopyDataFromQueue:00000000 $t
    {standard input}:3952   .text.prvUnlockQueue:00000000 $t
    {standard input}:4099   .text.prvIsQueueEmpty:00000000 $t
    {standard input}:4155   .text.xQueueIsQueueEmptyFromISR:00000000 $t
    {standard input}:4160   .text.xQueueIsQueueEmptyFromISR:00000000 xQueueIsQueueEmptyFromISR
    {standard input}:4237   .text.prvIsQueueFull:00000000 $t
    {standard input}:4295   .text.xQueueIsQueueFullFromISR:00000000 $t
    {standard input}:4300   .text.xQueueIsQueueFullFromISR:00000000 xQueueIsQueueFullFromISR
    {standard input}:4379   .text.vQueueAddToRegistry:00000000 $t
    {standard input}:4384   .text.vQueueAddToRegistry:00000000 vQueueAddToRegistry
    {standard input}:4455   .text.vQueueAddToRegistry:0000004c $d
    {standard input}:4460   .text.pcQueueGetName:00000000 $t
    {standard input}:4465   .text.pcQueueGetName:00000000 pcQueueGetName
    {standard input}:4537   .text.pcQueueGetName:00000048 $d
    {standard input}:4542   .text.vQueueUnregisterQueue:00000000 $t
    {standard input}:4620   .text.vQueueUnregisterQueue:0000004c $d
    {standard input}:4625   .text.vQueueWaitForMessageRestricted:00000000 $t
    {standard input}:4630   .text.vQueueWaitForMessageRestricted:00000000 vQueueWaitForMessageRestricted
    {standard input}:4709   .text.xQueueCreateSet:00000000 $t
    {standard input}:4714   .text.xQueueCreateSet:00000000 xQueueCreateSet
    {standard input}:4754   .text.xQueueAddToSet:00000000 $t
    {standard input}:4759   .text.xQueueAddToSet:00000000 xQueueAddToSet
    {standard input}:4826   .text.xQueueRemoveFromSet:00000000 $t
    {standard input}:4831   .text.xQueueRemoveFromSet:00000000 xQueueRemoveFromSet
    {standard input}:4902   .text.xQueueSelectFromSet:00000000 $t
    {standard input}:4907   .text.xQueueSelectFromSet:00000000 xQueueSelectFromSet
    {standard input}:4951   .text.xQueueSelectFromSetFromISR:00000000 $t
    {standard input}:4956   .text.xQueueSelectFromSetFromISR:00000000 xQueueSelectFromSetFromISR
    {standard input}:4999   .text.prvNotifyQueueSetContainer:00000000 $t
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
vPortEnterCritical
xTaskRemoveFromEventList
vListInitialise
vPortExitCritical
pvPortMalloc
xTaskGetCurrentTaskHandle
xTaskGetSchedulerState
vTaskInternalSetTimeOutState
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskResumeAll
vPortValidateInterruptPriority
pvTaskIncrementMutexHeldCount
xTaskPriorityInherit
vTaskPriorityDisinheritAfterTimeout
vPortFree
xTaskPriorityDisinherit
memcpy
vTaskMissedYield
vTaskPlaceOnEventListRestricted
